<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Uknow, uknowsec.cn, uknowsec, uknow's blog, Uknow’s Blog" />





  <link rel="alternate" href="/atom.xml" title="Uknow’s Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="点击阅读全文">
<meta property="og:type" content="article">
<meta property="og:title" content="《细说PHP》学习笔记">
<meta property="og:url" content="http://uknowsec.cn/posts/notes/《细说PHP》学习笔记.html">
<meta property="og:site_name" content="Uknow’s Blog">
<meta property="og:description" content="点击阅读全文">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/t01db525962d3cb177e.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170115191035.jpg">
<meta property="og:updated_time" content="2017-08-28T03:29:34.774Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《细说PHP》学习笔记">
<meta name="twitter:description" content="点击阅读全文">
<meta name="twitter:image" content="http://obr4sfdq7.bkt.clouddn.com/t01db525962d3cb177e.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6316725929833924000,
      author: 'Uknow'
    }
  };
</script>

  <title> 《细说PHP》学习笔记 | Uknow’s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?225ebcce29d319519ac7c7690425d1d4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Uknow’s Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                《细说PHP》学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-15T17:00:50+08:00" content="2017-01-15">
              2017-01-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/notes/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/posts/notes/《细说PHP》学习笔记.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="posts/notes/《细说PHP》学习笔记.html" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/posts/notes/《细说PHP》学习笔记.html" class="leancloud_visitors" data-flag-title="《细说PHP》学习笔记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>点击阅读全文<br><a id="more"></a></p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/t01db525962d3cb177e.jpg" alt="php"></p>
<h1 id="PHP的基本语法"><a href="#PHP的基本语法" class="headerlink" title="PHP的基本语法"></a>PHP的基本语法</h1><h2 id="PHP第一个程序"><a href="#PHP第一个程序" class="headerlink" title="PHP第一个程序"></a>PHP第一个程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;</div><div class="line">		&lt;title&gt;获取服务器信息的第一个PHP程序&lt;/title&gt;	</div><div class="line">	&lt;/head&gt;	</div><div class="line">	&lt;body&gt;			</div><div class="line">&lt;?php		</div><div class="line">	$sysos = $_SERVER[&quot;SERVER_SOFTWARE&quot;];	     //获取服务器标识的字串</div><div class="line">	$sysversion = PHP_VERSION;                   //获取PHP服务器版本	</div><div class="line"></div><div class="line">	//以下两条代码连接MySQL数据库并获取MySQL数据库版本信息</div><div class="line">	mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;); 	</div><div class="line">	$mysqlinfo = mysql_get_server_info();	</div><div class="line"></div><div class="line">	//从服务器中获取GD库的信息</div><div class="line">	if(function_exists(&quot;gd_info&quot;))&#123;                   </div><div class="line">		$gd = gd_info();</div><div class="line">		$gdinfo = $gd[&apos;GD Version&apos;];</div><div class="line">	&#125;else &#123;</div><div class="line">		$gdinfo = &quot;未知&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">        //从GD库中查看是否支持FreeType字体</div><div class="line">	$freetype = $gd[&quot;FreeType Support&quot;] ? &quot;支持&quot; : &quot;不支持&quot;;  </div><div class="line">	</div><div class="line">	//从PHP配置文件中获得是否可以远程文件获取</div><div class="line">	$allowurl= ini_get(&quot;allow_url_fopen&quot;) ? &quot;支持&quot; : &quot;不支持&quot;;</div><div class="line">	</div><div class="line">	//从PHP配置文件中获得最大上传限制</div><div class="line">	$max_upload = ini_get(&quot;file_uploads&quot;) ? ini_get(&quot;upload_max_filesize&quot;) : &quot;Disabled&quot;;</div><div class="line">	</div><div class="line">	//从PHP配置文件中获得脚本的最大执行时间</div><div class="line">	$max_ex_time= ini_get(&quot;max_execution_time&quot;).&quot;秒&quot;;</div><div class="line"></div><div class="line">	//以下两条获取服务器时间，中国大陆采用的是东八区的时间,设置时区写成Etc/GMT-8</div><div class="line">	date_default_timezone_set(&quot;Etc/GMT-8&quot;);</div><div class="line">	$systemtime = date(&quot;Y-m-d H:i:s&quot;,time());</div><div class="line">	</div><div class="line">	/*  *******************************************************************  */	</div><div class="line">	/*   以HTML表格的形式将以上获取到的服务器信息输出给客户端浏览器          */	</div><div class="line">	/*  *******************************************************************  */	</div><div class="line">	echo &quot;&lt;table align=center cellspacing=0 cellpadding=0&gt;&quot;;</div><div class="line">	echo &quot;&lt;caption&gt; &lt;h2&gt; 系统信息  &lt;/h2&gt; &lt;/caption&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; Web服务器：    &lt;/td&gt; &lt;td&gt; $sysos        &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">        echo &quot;&lt;tr&gt; &lt;td&gt; PHP版本：      &lt;/td&gt; &lt;td&gt; $sysversion   &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; MySQL版本：    &lt;/td&gt; &lt;td&gt; $mysqlinfo    &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; GD库版本：     &lt;/td&gt; &lt;td&gt; $gdinfo       &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; FreeType：     &lt;/td&gt; &lt;td&gt; $freetype     &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; 远程文件获取： &lt;/td&gt; &lt;td&gt; $allowurl     &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; 最大上传限制： &lt;/td&gt; &lt;td&gt; $max_upload   &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; 最大执行时间： &lt;/td&gt; &lt;td&gt; $max_ex_time  &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;tr&gt; &lt;td&gt; 服务器时间：   &lt;/td&gt; &lt;td&gt; $systemtime   &lt;/td&gt; &lt;/tr&gt;&quot;;</div><div class="line">	echo &quot;&lt;/table&gt;&quot;;</div><div class="line">?&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="PHP语言标记"><a href="#PHP语言标记" class="headerlink" title="PHP语言标记"></a>PHP语言标记</h3><h4 id="PHP语言嵌入HTML中的位置"><a href="#PHP语言嵌入HTML中的位置" class="headerlink" title="PHP语言嵌入HTML中的位置"></a>PHP语言嵌入HTML中的位置</h4><p>可以将PHP嵌入到以后缀名为.php的HTML文件中的任何地方，只要在文件中使用&lt;?php起始和终止标识符？&gt;就会开启PHP模式</p>
<h4 id="使用四对不同的开始和结束标记"><a href="#使用四对不同的开始和结束标记" class="headerlink" title="使用四对不同的开始和结束标记"></a>使用四对不同的开始和结束标记</h4><ul>
<li>1.xml风格（标准风格推荐使用）    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">echo&quot;这是xml风格的标记&quot;; </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>xml风格的标记是常用的标记，也是推荐使用的标记，服务器不能禁用，该风格的标记在xml，xhtml中都可以使用。</p>
<ul>
<li><p>2.脚本风格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script languange=&quot;php&quot;&gt; </div><div class="line">echo&apos;这是脚本风格的标记&apos;; </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>3.简短风格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?这是简短风格的标记;?&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注：需要在php.ini中设置short _open_tag=on，默认是on,或者在 PHP 编译时加入了 Cenable-short-tags 选项。(PHP 3版本还可以通过 short_tags() 函数激活使用短标记。)</p>
<ul>
<li>4.asp风格<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;% </div><div class="line">echo&apos;这是asp风格的标记&apos;; </div><div class="line">%&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注：需要在 php.ini 配置文件中开启 asp_tags = on;<br>上面asp风格与简短风格需要在php.ini中设置下。默认是不支持的。</p>
<h3 id="指令分隔符-“分号”"><a href="#指令分隔符-“分号”" class="headerlink" title="指令分隔符 “分号”"></a>指令分隔符 “分号”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	echo &quot;This is a test&quot;;</div><div class="line">?&gt;   //这是一个PHP指令，后面一定要加上分号表示结束</div><div class="line"></div><div class="line">&lt;?php echo &quot;This is a test&quot;</div><div class="line">?&gt;  //最后的结束标记?&gt;隐含表示了一个分号，所以这粒可以不用分号结束</div></pre></td></tr></table></figure>
<h3 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h3><p>  PHP支持C，C++和Unix shell风格的注释，PHP的注释符号有三种：以“/<em>”和“</em>/”闭合的多行注释符，以及用“//”和“#”开始的单行注释符。注释一定要卸载被注释代码的上面或是右面，不要写到代码的下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	/*这是一个多行注释</div><div class="line">	可以有多行文字   */</div><div class="line">	</div><div class="line">	echo &quot;this is a test&quot;;</div><div class="line">	echo &quot;this is another test&quot;;    //这是一行C++风格的注释</div><div class="line">	echo &quot;One final test &quot;; 	# 这是Unix Shell风格的注释</div></pre></td></tr></table></figure>
<p>注：多行注释是无法嵌套的，但是在多行注释里可以包含单行注释，在单行注释中也可以包括多行注释。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>在PHP中的声明变量必须是使用“$”后面跟上变量名表示，使用赋值操作符（=）给变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a=100;		//声明一个变量a赋上一个整型数据值100；</div><div class="line">	$b=&quot;string&quot;;   //声明一个变量b赋上一个字符串值“string”</div><div class="line">	$c=true;	//声明一个变量c赋上一个布尔数据值</div><div class="line">	$d=99.99;	//声明一个变量d赋上一个浮点型数值</div><div class="line">	</div><div class="line">	$key1=$a;	//声明一个变量key1，将a变量的值赋给它</div><div class="line">	$key2=$b;	//声明一个变量key2，将b变量的值赋给它</div><div class="line">	</div><div class="line">	$a=$b=$c=$d=&quot;value&quot;; 	//同时声明多个变量，并赋上相同的值</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>在变量的使用范围周期内，我们可以通过借助unset()函数释放指定的变量，用isset()函数检测变量是否设置和使用empty()函数检查一个变量是否为空。</p>
<h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>变量名是严格区分大小写的，相同单词组成的变量，但大小写不同就是不同变量。<br>一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。<br>正则表达式为：‘[a-zA-Z<em>\x7f-\xff][a-zA-Z0-9</em>\x7f-\xff]*’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$name=&quot;a&quot;;</div><div class="line">	$Name=&quot;b&quot;;</div><div class="line">	$NAME=&quot;c&quot;;</div><div class="line">	</div><div class="line">	echo name;		//输出 a</div><div class="line">	echo Name;		//输出 b</div><div class="line">	echo NAME; 	 	//输出 c</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>一个变量的变量名可以动态地设置和使用，一个普通的变量通过声明来设置，而一个可变变量获取一个普通变量的值作为这个可变变量的变量名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$hi=&quot;hello;&quot;		//声明一个普通的变量$hi值为“hello”</div><div class="line">	$$hi=&quot;world;&quot;   //声明一个可变变量$$hi,$hi的值为hello，相当于声明$hello的值是“world”</div><div class="line">	</div><div class="line">	ehco &quot;$hi $hello&quot;;  //输出 hello world</div><div class="line">	echo &quot;$hi $&#123;$hi&#125;&quot;;	//同上</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="变量的引用赋值"><a href="#变量的引用赋值" class="headerlink" title="变量的引用赋值"></a>变量的引用赋值</h3><p>新的变量简单的引用了原始变量，改动新的变量将影响到原始变量，反之亦然。使用引用复制，简单地将一个“&amp;”符号加到将要赋值的变量前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$foo=&apos;Bob&apos;;</div><div class="line">	$bar=&amp;$foo;</div><div class="line">	</div><div class="line">	$bar=&apos;a&apos;;</div><div class="line">	echo $bar;     //a</div><div class="line">	echo $foo;		//a</div><div class="line">	</div><div class="line">	$foo=&apos;b&apos;;</div><div class="line">	echo $bar;   //b</div><div class="line">	echo $foo;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170115191035.jpg" alt=""><br>可以使用函数var_dump()查看某表达式的值和类型。</p>
<h3 id="布尔型（boolean）"><a href="#布尔型（boolean）" class="headerlink" title="布尔型（boolean）"></a>布尔型（boolean）</h3><p>以下值被认为是FALSE，所有其他值都被认为是TRUE（包括任何资源）。</p>
<ul>
<li>布尔值FALSE</li>
<li>整型值0为假，-1和其他非零值一样，被认为TRUE</li>
<li>浮点型值0.0</li>
<li>空白字符串和字符串“0”</li>
<li>没有成员变量的数组</li>
<li>没有单元的对象（仅适用与PHP4）</li>
<li>特殊类型NULL（包括尚未设定的变量）</li>
</ul>
<h3 id="整型（integer）"><a href="#整型（integer）" class="headerlink" title="整型（integer）"></a>整型（integer）</h3><p>整数数值有最大的使用范围，整型数的字长和平台有关，如果给定的一个数超出了integer的这个范围，将会被解释为float。同时如果执行的运算结果超出了integer这个范围，也会返回float.</p>
<h3 id="浮点型（float）"><a href="#浮点型（float）" class="headerlink" title="浮点型（float）"></a>浮点型（float）</h3><p>浮点数的字长也是和平台相关，允许表示范围在1.7E-308-1.7E+38之间，精确到小数点后15位。不要比较两个浮点数是否相等。如果确实需要更高的精度，应该是使用任意精度数学函数或者gmp()函数。</p>
<h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h3><p>字符串可以使用单引号、双引号、界定符三种字面上的方法定义。</p>
<ul>
<li>1.单引号：指定一个简单字符串的最简单的方法就是用单引号括起来。</li>
<li>2.双引号：更多的特殊字符的转义，可以解析双引号里面的包含变量。</li>
<li>3.界定符（&lt;&lt;&lt;）：在&lt;&lt;&lt;之后提供一个标识符开始，然后是包含的字符串，最后是同样的标识符结束。结束标识符必须从行的第一列开始，并且后面除了分号以外不能包含任何其他的字符，空格以及空白制表符都不可以。</li>
</ul>
<h3 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h3><p>用array()语言结构来新建一个array,它接受一定数量用逗号分隔的key=&gt;value参数对。<br>key 可以是integer或者string value可以是任何值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$arr=array(&quot;foo&quot;=&gt;&quot;bar&quot;,12=&gt;true);   </div><div class="line">	print_r($arr);		//使用print_r()函数查看数组中的全部内容</div><div class="line">	echo $arr[&quot;foo&quot;];	//通过数组下标访问数组中的单个数据</div><div class="line">	echo $arr[12];		</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="对象（object）"><a href="#对象（object）" class="headerlink" title="对象（object）"></a>对象（object）</h3><p>一个对象类型的变量，是由一组属性值和一组方法构成的。要初始化一个对象，用new语句将对象实例到一个变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person&#123;</div><div class="line">	var $name;</div><div class="line">	</div><div class="line">	function say()&#123;</div><div class="line">		echo &quot;Doing foo&quot;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	$p=new Person;</div><div class="line">	</div><div class="line">	$p-&gt;name=&quot;Tom&quot;;</div><div class="line">	$p-&gt;say();</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="NULL类型"><a href="#NULL类型" class="headerlink" title="NULL类型"></a>NULL类型</h3><p>特殊的NULL值表示一个变量没有值，NULL类型唯一可能的值就是NULL。NULL不表示空格，也不表示零，也不是空字符串，而是表示一个变量的值为空。NULL不区分大小写，在下列情况下一个变量被认为是NULL：</p>
<ul>
<li>将变量直接赋值为NULL</li>
<li>声明的变量尚未被赋值</li>
<li>被unset()函数销毁的变量</li>
</ul>
<h3 id="伪类型介绍"><a href="#伪类型介绍" class="headerlink" title="伪类型介绍"></a>伪类型介绍</h3><ul>
<li>mixed:说明一个参数可以接受多种不同的类型。</li>
<li>number:说明一个参数可以是intger或者是float</li>
<li>callback:</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="常量的定义和使用"><a href="#常量的定义和使用" class="headerlink" title="常量的定义和使用"></a>常量的定义和使用</h3><p>在PHP中是通过使用defin()函数来定义常量的。大小写敏感.遵循PHP标识符的命名规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	define(&quot;name&quot;，value)</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h3><p>PHP预定于了一系列常量，可以在程序中直接使用来完成一些特殊的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"> echo &apos;PHP常用的预定义常量&apos;.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line"> </div><div class="line"> echo &apos;当前php的版本为(PHP_VERSION):&apos;.PHP_VERSION.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;当前所使用的操作系统类型(PHP_OS):&apos;.PHP_OS.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;web服务器与PHP之间的接口为(PHP_SAPI):&apos;.PHP_SAPI.&apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;最大的整型数(PHP_INT_MAX):&apos;.PHP_INT_MAX.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;php默认的包含路径(DEFAULT_INCLUDE_PATH):&apos;.DEFAULT_INCLUDE_PATH.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;pear的安装路径(PEAR_INSTALL_DIR):&apos;.PEAR_INSTALL_DIR.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;pear的扩展路径(PEAR_EXTENSION_DIR):&apos;.PEAR_EXTENSION_DIR.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;php的执行路径(PHP_BINDIR):&apos;.PHP_BINDIR.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;php扩展模块的路径为(PHP_LIBDIR):&apos;.PHP_LIBDIR.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;指向最近的错误处(E_ERROR):&apos;.E_ERROR.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;指向最近的警告处(E_WARNING):&apos;.E_WARNING.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;指向最近的注意处(E_NOTICE):&apos;.E_NOTICE.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;自然对数e值(M_E):&apos;.M_E.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;数学上的圆周率的值(M_PI):&apos;.M_PI.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line"> echo &apos;逻辑真值(TRUE):&apos;.TRUE.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;逻辑假值(FALSE):&apos;.FALSE.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;当前文件行数(__LINE__):&apos;.__LINE__.&apos;&lt;br&gt;&lt;br&gt;&apos;; //是两个下划线</div><div class="line">  </div><div class="line"> echo &apos;当前文件路径名(__FILE__):&apos;.__FILE__.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line"> </div><div class="line"> echo &apos;&lt;br&gt;&apos;.&apos;当前被调用的函数名(__FUNCTION__):&apos;.__FUNCTION__.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;类名(__CLASS__):&apos;.__CLASS__.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">  </div><div class="line"> echo &apos;类的方法名(__METHOD__):&apos;.__METHOD__.&apos;&lt;br&gt;&lt;br&gt;&apos;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="PHP中的运算符"><a href="#PHP中的运算符" class="headerlink" title="PHP中的运算符"></a>PHP中的运算符</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>算术运算符</li>
<li>字符串运算符</li>
<li>赋值运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>其他运算符</li>
</ul>
<h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><p>在PHP中字符串运算符只有一个，是英文的句号（“.”），也叫做连接运算符</p>
<h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><ul>
<li>三元运算符（?:）提供简单的逻辑判断</li>
<li>执行判断符（``）执行操作系统命令，并将其输出信息返回</li>
<li>错误控制运算符（@）当将其放置在一个PHP表达式之前，该表达式可能产生的任何警告信息都会被忽略。</li>
</ul>
<h1 id="PHP语言结构"><a href="#PHP语言结构" class="headerlink" title="PHP语言结构"></a>PHP语言结构</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>在程序中使用分支结构可以有以下几种形式：</p>
<ul>
<li>单一条件分支结构</li>
<li>双向条件分支结构</li>
<li>多向条件分支结构</li>
<li>巢状条件分支结构</li>
</ul>
<h3 id="单一条件分支结构（if）"><a href="#单一条件分支结构（if）" class="headerlink" title="单一条件分支结构（if）"></a>单一条件分支结构（if）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(表达式)</div><div class="line">	语句块;</div></pre></td></tr></table></figure>
<h3 id="双向条件分支结构（else子句）"><a href="#双向条件分支结构（else子句）" class="headerlink" title="双向条件分支结构（else子句）"></a>双向条件分支结构（else子句）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(表达式)</div><div class="line">	语句块1;</div><div class="line">else</div><div class="line">	语句块2;</div></pre></td></tr></table></figure>
<h3 id="多向条件分支结构（elseif子句）"><a href="#多向条件分支结构（elseif子句）" class="headerlink" title="多向条件分支结构（elseif子句）"></a>多向条件分支结构（elseif子句）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if(表达式1)</div><div class="line">	语句块1;</div><div class="line">elseif(表达式2)</div><div class="line">	语句块2;</div><div class="line">	</div><div class="line">......</div><div class="line"></div><div class="line">elseif(表达式n)</div><div class="line">	语句块n;</div><div class="line">else </div><div class="line">	语句块n+1</div></pre></td></tr></table></figure>
<h3 id="多向条件分支结构（switch语句）"><a href="#多向条件分支结构（switch语句）" class="headerlink" title="多向条件分支结构（switch语句）"></a>多向条件分支结构（switch语句）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch(表达式)</div><div class="line">&#123;</div><div class="line">	case 值1：</div><div class="line">		语句块1;</div><div class="line">		break;</div><div class="line">	case 值2;</div><div class="line">		语句块2;</div><div class="line">	</div><div class="line">	.....</div><div class="line">	</div><div class="line">	case 值n;</div><div class="line">		语句块n;</div><div class="line">		break;</div><div class="line">	default:</div><div class="line">		语句块n+1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="巢状条件分支结构"><a href="#巢状条件分支结构" class="headerlink" title="巢状条件分支结构"></a>巢状条件分支结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if(表达式1)&#123;</div><div class="line">	if(表达式2)&#123;</div><div class="line">	... ...</div><div class="line">	&#125;else&#123;</div><div class="line">	... ...</div><div class="line">	&#125;</div><div class="line">&#125;else&#123;</div><div class="line">	if(表达式2)&#123;</div><div class="line">	... ...</div><div class="line">	&#125;else&#123;</div><div class="line">	... ...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>PHP中提供三种循环</p>
<ul>
<li>while循环</li>
<li>do-while循环</li>
<li>for循环</li>
</ul>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while(表达式)</div><div class="line">	语句块;</div></pre></td></tr></table></figure>
<h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do&#123;</div><div class="line">	语句块;</div><div class="line">&#125;while(表达式);</div></pre></td></tr></table></figure>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(初始化:条件表达式; 增量)&#123;</div><div class="line">	语句块;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="PHP中的函数"><a href="#PHP中的函数" class="headerlink" title="PHP中的函数"></a>PHP中的函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function 函数名 ([参数1, 参数2,... 参数n])</div><div class="line">&#123;</div><div class="line">	函数体;</div><div class="line">	return 返回值;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h3><ul>
<li><p>按值传递参数<br>通过参数列表传递信息到函数</p>
</li>
<li><p>按引用传递参数<br>在参数的面前预先加上符号“&amp;”即可</p>
</li>
<li><p>函数的默认参数</p>
</li>
<li><p>可变长度参数列表<br>使用func_get_args()函数将所有传递给脚本函数的参数当做一个数组返回<br>也可以使用func_num_args()函数返回参数的总数，和使用func_get_arg()函数接收一个数字参数，返回指定的函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function more_args()&#123;</div><div class="line">		$args=func_get_args();</div><div class="line">	for($i=0;$i&lt;count($args);$i++)&#123;</div><div class="line">		echo &quot;第&quot;.$i.&quot;个参数是&quot;.$args[$i].&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	more_args(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,1,2,3);</div><div class="line">?&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;?php</div><div class="line">	function more_args()&#123;</div><div class="line">	for($i=0;$i&lt;func_num_args();$i++)&#123;</div><div class="line">		echo &quot;第&quot;.$i.&quot;个参数是&quot;.func_get_arg($i).&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	more_args(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,1,2,3);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h3><p>变量函数也称作可变函数。如果一个变量名后有圆括号，PHP将寻找与变量的值同名的函数，并且将尝试执行它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function one($a,$b)&#123;</div><div class="line">	return $a+$b;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	$result=&quot;one&quot;;</div><div class="line">	echo &quot;通算结果是：&quot;.$result(2,3);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h1 id="PHP中的数组与数据结构"><a href="#PHP中的数组与数据结构" class="headerlink" title="PHP中的数组与数据结构"></a>PHP中的数组与数据结构</h1><h2 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h2><h3 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h3><p>在PHP中，根据数组提供下标的不同方式，将数组分为索引数组和关联数组</p>
<ul>
<li>索引数组的索引值是整数</li>
<li>关联数组的索引值是字符串</li>
</ul>
<h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><h3 id="直接复制的方式声明数组"><a href="#直接复制的方式声明数组" class="headerlink" title="直接复制的方式声明数组"></a>直接复制的方式声明数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$数组变量名[索引值]=资料内容</div></pre></td></tr></table></figure>
<p>可以使用print_r()或者var_dump()函数打印数组中所有元素的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print_r($contact1);			//输出数组$contact1中所有元素的下标和值</div><div class="line">var_dump($contact1);		//输出数组$contact1中所有元素的下标和值，同时输出每个元素的类型</div></pre></td></tr></table></figure>
<p>在声明数组变量时，还可以在下标中使用数字和字符串混合。<br>在PHP中，索引数组的下标可以是非连续的值，只要在初始化时指定非连续的下标即可。如果指定的下标志已经声明过，则属于对变量重新赋值。如果没有指定索引值的元素与指定索引值的元素混在一起赋值时，没有指定索引值的元素的默认索引值，将紧跟指定索引值元素中的最高的索引值递增，</p>
<h3 id="使用array-语言结构新建数组"><a href="#使用array-语言结构新建数组" class="headerlink" title="使用array()语言结构新建数组"></a>使用array()语言结构新建数组</h3><p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$数组变量名=array(key1=&gt;value,key2=&gt;value, ... ... keyN=&gt;valueN);</div></pre></td></tr></table></figure></p>
<h3 id="多维数组的声明"><a href="#多维数组的声明" class="headerlink" title="多维数组的声明"></a>多维数组的声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">       //使用array()语句结构将联系人列表中所有数据声明为一个二维数组，默认下标是顺序数字索引</div><div class="line">$contact = array(                                                     //定义外层数组</div><div class="line">	   array(1, &apos;高某&apos;, &apos;A公司&apos;, &apos;北京市&apos;, &apos;(010)98765432&apos;, &apos;gm@linux.com&apos;),   //子数组1</div><div class="line">	   array(2, &apos;洛某&apos;, &apos;B公司&apos;, &apos;上海市&apos;, &apos;(021)12345678&apos;, &apos;lm@apache.com&apos;),  //子数组2</div><div class="line">	   array(3, &apos;峰某&apos;, &apos;C公司&apos;, &apos;天津市&apos;, &apos;(022)24680246&apos;, &apos;fm@mysql.com&apos;),   //子数组3</div><div class="line">	   array(4, &apos;书某&apos;, &apos;D公司&apos;, &apos;重庆市&apos;, &apos;(023)13579135&apos;, &apos;sm@phpcom&apos;)       //子数组4</div><div class="line">   );</div></pre></td></tr></table></figure>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="使用for语句循环遍历数组"><a href="#使用for语句循环遍历数组" class="headerlink" title="使用for语句循环遍历数组"></a>使用for语句循环遍历数组</h3><p>在PHP中，不仅可以指定非连续的数字索引值，而且还存在以字符串为下标的关联数组。所以在PHP中很少使用for语句循环遍历数组。</p>
<h3 id="使用foreach语句遍历数组"><a href="#使用foreach语句遍历数组" class="headerlink" title="使用foreach语句遍历数组"></a>使用foreach语句遍历数组</h3><ul>
<li>第一种语法格式：<br>每次循环中，当前元素的值被赋给变量$value($value可以是自定义的任意变量)，并且把数组内部的指针向后移动一步，因此下一次循环中将会得到该数组的下一个元素，只要数组的结尾停止循环，结束数组的遍历。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">foreach(array_expression as $value)&#123;</div><div class="line">	循环体</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&lt;?php</div><div class="line">        //使用array()结构声明一个无序的一维数组$contact</div><div class="line">	$contact = array( 1, 14=&gt;&quot;高某&quot;, &quot;A公司&quot;, &quot;北京市&quot;, 14=&gt;&quot;(010)98765432&quot;, &quot;gao@php.com&quot; );</div><div class="line">	$num=0;                                                       //声明一个变量$num初使值为0，做为循环的计数使用</div><div class="line">        //使用foreach语句遍历一维数组$contact，将数组中每个元素输出</div><div class="line">	foreach($contact as $value)&#123;</div><div class="line">		echo &quot;在数组\$contact中第 $num 元素是：$value &lt;br&gt;&quot;;  //每次循环输出一次当前元素</div><div class="line">		$num++;                                               //计数变量累加</div><div class="line">	&#125;</div><div class="line">?&gt;</div><div class="line"></div><div class="line">在数组$contact中第 0 元素是：1</div><div class="line">在数组$contact中第 1 元素是：(010)98765432</div><div class="line">在数组$contact中第 2 元素是：A公司</div><div class="line">在数组$contact中第 3 元素是：北京市</div><div class="line">在数组$contact中第 4 元素是：gao@php.com</div></pre></td></tr></table></figure>
<ul>
<li>第二种语法格式<br>当前元素的键名和值都会被赋给变量$key和$value<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">foreach(array_expression as $key=&gt;$value)&#123;</div><div class="line">	循环体</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;?php</div><div class="line">        //声明一个一维的关联数组$contact, 使用“=&gt;”运算符指定了每个元素的字符串下标</div><div class="line">	$contact = array(&quot;ID&quot; =&gt; 1,</div><div class="line">		&quot;姓名&quot; =&gt; &quot;高某&quot;,</div><div class="line">		&quot;公司&quot; =&gt; &quot;A公司&quot;,</div><div class="line">		&quot;地址&quot; =&gt; &quot;北京市&quot;,</div><div class="line">		&quot;电话&quot; =&gt; &quot;(010)98765432&quot;,</div><div class="line">		&quot;EMAIL&quot; =&gt; &quot;gao@php.com&quot; </div><div class="line">	);</div><div class="line">	//以HTML列表的方式输出数组中每个元素的信息</div><div class="line">	echo &apos;&lt;dl&gt;一个联系人信息：&apos;;</div><div class="line">	foreach($contact as $key =&gt; $value)&#123;       //使用foreach的第二种格式，可以获取数组元素的键/值</div><div class="line">		echo &quot;&lt;dd&gt; $key : $value &lt;/dd&gt;&quot;;   //输出每个元素的键/值对</div><div class="line">	&#125;</div><div class="line">	echo &apos;&lt;/dl&gt;&apos;;</div><div class="line">?&gt;</div><div class="line"></div><div class="line">一个联系人信息：</div><div class="line">    ID : 1 </div><div class="line">    姓名 : 高某 </div><div class="line">    公司 : A公司 </div><div class="line">    地址 : 北京市 </div><div class="line">    电话 : (010)98765432 </div><div class="line">    EMAIL : gao@php.com</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="联合使用list-、each-和while-循环遍历数组"><a href="#联合使用list-、each-和while-循环遍历数组" class="headerlink" title="联合使用list()、each()和while()循环遍历数组"></a>联合使用list()、each()和while()循环遍历数组</h3><ul>
<li><p>each()函数<br>each()函数需要传递一个数组作为参数，返回数组中当前元素的键/值对，并向后移动数组指针到下一个元素的位置。</p>
</li>
<li><p>list()函数<br>list()用一步操作给一组变量进行赋值，即把数组中的值赋给一些变量。list()仅能用与数字索引从0开始。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list(mixed varname,mixed ...)=array_expression     //list()语句的语法格式</div></pre></td></tr></table></figure>
<p>list()是通过“=”运算符以赋值的方式，将数组中每个元素的值，对应的赋给list()函数中的每个参数。list()函数又将它中的每个参数转换成直接可以在脚本中使用的比变量。</p>
<ul>
<li>each()和list()结合<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$contact=array(&quot;ID&quot;=&gt;1,&quot;名字&quot;=&gt;&quot;高某&quot;,&quot;公司&quot;=&gt;&quot;A&quot;);</div><div class="line">	list($key=&gt;$value)=each($contact);</div><div class="line">	echo &quot;$key=&gt;$value&quot;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用数组的内部指针控制函数遍历数组"><a href="#使用数组的内部指针控制函数遍历数组" class="headerlink" title="使用数组的内部指针控制函数遍历数组"></a>使用数组的内部指针控制函数遍历数组</h3><p>数组的内部指针是数组内部的组织机制，指向一个数组中的某个元素，默认是指向数组中第一个元素，通过移动或改变指针的位置，可以访问数组中的任意元素。<br>对于数组指针的控制PHP提供以下几个内建函数可以利用。</p>
<ul>
<li>current():是取得目前指针位置的内容资料</li>
<li>key():用来读取目前指针所指向资料的索引值</li>
<li>next():将数组中的内部指针移动到下一个单元</li>
<li>prev():将数组的内部指针倒回一位</li>
<li>end():将数组的内部指针指向最后一个元素</li>
<li>rest():将目前指针无条件移至第一个索引位置</li>
</ul>
<h2 id="预定义数组"><a href="#预定义数组" class="headerlink" title="预定义数组"></a>预定义数组</h2><table>
<thead>
<tr>
<th>预定义数组</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$_SERVER</td>
<td style="text-align:left">变量由Web服务器设定或者直接与当前脚本的执行环境相关联</td>
</tr>
<tr>
<td>$_ENV</td>
<td style="text-align:left">执行环境提交至脚本的变量</td>
</tr>
<tr>
<td>$_GET</td>
<td style="text-align:left">经由URL请求提交至脚本的变量</td>
</tr>
<tr>
<td>$_POST</td>
<td style="text-align:left">经由HTTP POST方法提交至脚本的变量</td>
</tr>
<tr>
<td>$_REQUEST</td>
<td style="text-align:left">经由GET,POST和COOKIE机制提交至脚本的变量，因此该数组并不值得信任</td>
</tr>
<tr>
<td>$_FILES</td>
<td style="text-align:left">经由HTTP POST文件上传而提交至脚本的变量</td>
</tr>
<tr>
<td>$_COOKIE</td>
<td style="text-align:left">经由HTTP Cookies方法提交至脚本的变量</td>
</tr>
<tr>
<td>$_SESSION</td>
<td style="text-align:left">当前注册给脚本会话的变量</td>
</tr>
<tr>
<td>$GLOBALS</td>
<td style="text-align:left">包含一个引用指向每个当前脚本的全局范围内有效的变量。该数组的键名为全局变量的名称</td>
</tr>
</tbody>
</table>
<h3 id="服务器变量：-SERVER"><a href="#服务器变量：-SERVER" class="headerlink" title="服务器变量：$_SERVER"></a>服务器变量：$_SERVER</h3><p>$_SERVER是一个包含诸如头信息，路径和脚本位置的数组。这是自动全局变量，在所有的脚本中都有效，在函数或对象的方法中不需要使用global关键字访问它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	foreach($_SERVER as $key=&gt;$value)&#123;</div><div class="line">		echo &apos;$_SERVER[&apos;.$key.&apos;]=&apos;.value.&apos;&lt;br&gt;&apos;;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="环境变量：-ENV"><a href="#环境变量：-ENV" class="headerlink" title="环境变量：$_ENV"></a>环境变量：$_ENV</h3><p>$_ENV数组中的内容是在PHP解析器运行是，从PHP所在服务器中的环境变量转变为PHP全局变量的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	foreach($_ENV as $key=&gt;$value)&#123;</div><div class="line">		echo &apos;$_ENV[&apos;.$key.&apos;]=&apos;.value.&apos;&lt;br&gt;&apos;;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>###　HTTP GET变量：$_GET<br>$_GET数组也是超全局变量数组，是通过HTTP GET方法传递的变量组成的数组。它属于外部变量，即在服务器页面中通过$_GET超全局数组获取URL或表单的GET方式传递过来的参数。</p>
<h3 id="HTTP-POST变量：-POST"><a href="#HTTP-POST变量：-POST" class="headerlink" title="HTTP POST变量：$_POST"></a>HTTP POST变量：$_POST</h3><p>$_POST数组也是超全局变量数组，通过HTTP POST方法传递的变量组成的数组，是自动全局变量，在所有的脚本中都有效，在函数或对象的方法也不需要使用global关键字访问它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;&lt;title&gt;添加联系人&lt;/title&gt;&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;form action=&quot;add.php&quot; method=&quot;post&quot;&gt; &lt;!--将表单以POST方法提交到add.php页面 --&gt;</div><div class="line">			编号：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br&gt;        &lt;!-- 表单域的名称为id --&gt;</div><div class="line">			姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;      &lt;!-- 表单域的名称为name --&gt;</div><div class="line">			公司：&lt;input type=&quot;text&quot; name=&quot;company&quot;&gt;&lt;br&gt;   &lt;!-- 表单域的名称为company --&gt;</div><div class="line">			地址：&lt;input type=&quot;text&quot; name=&quot;address&quot;&gt;&lt;br&gt;   &lt;!-- 表单域的名称为address --&gt;</div><div class="line">			电话：&lt;input type=&quot;text&quot; name=&quot;phone&quot;&gt;&lt;br&gt;     &lt;!-- 表单域的名称为phone --&gt;</div><div class="line">			EMAIL:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt;     &lt;!-- 表单域的名称为email --&gt;</div><div class="line">			&lt;input type=&quot;submit&quot; value=&quot;添加新联系人&quot;&gt;</div><div class="line">		&lt;/form&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">&lt;?php</div><div class="line">	echo &quot;用户添加的联系人信息如下：&lt;br&gt;&quot;;</div><div class="line">	foreach($_POST as $key =&gt; $value) &#123; 		  //使用foreach语句遍历超全局数组$_POST</div><div class="line">		echo $key.&apos; : &apos;.$value.&apos;&lt;br&gt;&apos;;     	  //输出$_POST数组中的键和值，键即是表单域的名称</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="request变量：-REQUEST"><a href="#request变量：-REQUEST" class="headerlink" title="request变量：$_REQUEST"></a>request变量：$_REQUEST</h3><p>此关联数组包含\$_GET，\$_POST和\$_COOKIE中的全部内容。不管是POST还是GET方法提交的所有数据都可以通过\$_REQUEST获得。但是\$_REQUEST的速度比较慢。</p>
<h3 id="HTTP文件上传变量：-FILES"><a href="#HTTP文件上传变量：-FILES" class="headerlink" title="HTTP文件上传变量：$_FILES"></a>HTTP文件上传变量：$_FILES</h3><p>使用表单的file输入域上传文件时，必须使用POST提交。</p>
<h3 id="HTTP-Cookies：-COOKIE"><a href="#HTTP-Cookies：-COOKIE" class="headerlink" title="HTTP Cookies：$_COOKIE"></a>HTTP Cookies：$_COOKIE</h3><p>$_COOKIE超全局数组是经由HTTP Cookies方法提交至脚本的变量。</p>
<h3 id="Session变量：-SESSION"><a href="#Session变量：-SESSION" class="headerlink" title="Session变量：$_SESSION"></a>Session变量：$_SESSION</h3><p>在PHP5中，会话控制是在服务器端使用session跟踪用户。</p>
<h3 id="Global变量：-GLOBALS"><a href="#Global变量：-GLOBALS" class="headerlink" title="Global变量：$_GLOBALS"></a>Global变量：$_GLOBALS</h3><p>GLOBALS是由所有已定义的全局变量组成的数组，变量名就是该数组的索引。</p>
<h2 id="数组的相关处理函数"><a href="#数组的相关处理函数" class="headerlink" title="数组的相关处理函数"></a>数组的相关处理函数</h2><h3 id="数组的键-值操作函数"><a href="#数组的键-值操作函数" class="headerlink" title="数组的键/值操作函数"></a>数组的键/值操作函数</h3><p>在PHP中，数组的每个元素都是由键/值对组成，通过元素的键来访问对应键的值。</p>
<h4 id="函数array-value"><a href="#函数array-value" class="headerlink" title="函数array_value()"></a>函数array_value()</h4><p>array_value()函数的作用是返回数组中所有元素的值。使用非常容易，只有一个必选参数，规定传入给定的数组，返回一个包含给定数组中所有值的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$contact = array(&quot;ID&quot; =&gt; 1,</div><div class="line">		&quot;姓名&quot; =&gt; &quot;高某&quot;,</div><div class="line">		&quot;公司&quot; =&gt; &quot;A公司&quot;,</div><div class="line">		&quot;地址&quot; =&gt; &quot;北京市&quot;,</div><div class="line">		&quot;电话&quot; =&gt; &quot;(010)98765432&quot; );</div><div class="line">	</div><div class="line">	print_r(array_values($contact));   // array_values()函数传入数组$contact重新索引返回一个新数组</div><div class="line">	print_r($contact);                 //原数组$contact内容元素不变</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-key"><a href="#函数array-key" class="headerlink" title="函数array_key()"></a>函数array_key()</h4><p>array_key()函数的作用是返回数组所有的键名。本函数中有一个必需参数和两个可选参数，其中函数的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_key(array input[,mixed search_value[,bool strict]])</div></pre></td></tr></table></figure></p>
<p>如果指定了可选参数search_value，则只返回指定该值的键名，否则input数组中的所有键名都会被返回，自PHP5起，可以用strict参数来进行全等比较。需要传入一个布尔型的值，FALSE为默认不依赖类型。如果传入TRUE值则根据类型返回带有指定值的键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">     $lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;,&quot;b&quot;=&gt;&quot;Apache&quot;,&quot;c&quot;=&gt;&quot;MySQL&quot;,&quot;d&quot;=&gt;&quot;PHP&quot;);  //只使第一个必需的参数</div><div class="line">	print_r(array_keys($lamp));            //输出：Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c )</div><div class="line">	print_r(array_keys($lamp,&quot;Apache&quot;));   //使用第二个可选参数输出：Array ( [0] =&gt; b)</div><div class="line"></div><div class="line">	$a=array(10,20,30,&quot;10&quot;);               //声明一个数组，其中元素的值有整数10和字符串”10”</div><div class="line">	print_r(array_keys($a,&quot;10&quot;,false));    //使用第三个参数 (false)输出：Array ( [0] =&gt; 0 [1] =&gt; 3 )</div><div class="line">	</div><div class="line">	$a=array(10,20,30,&quot;10&quot;);               //声明一个数组，其中元素的值有整数10和字符串”10”</div><div class="line">	print_r(array_keys($a,&quot;10&quot;,true));     //使用第三个参数 (true)输出：Array ( [0] =&gt; 3)	</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数in-array"><a href="#函数in-array" class="headerlink" title="函数in_array()"></a>函数in_array()</h4><p>in_array()函数的作用是检查数组中是否存在某个值，即在数组中搜索给定的值。本函数中有三个参数，前两个参数为必需的，最后一个参数为可选的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool in_array(mixed needle,array haystack[,bool strict])</div></pre></td></tr></table></figure></p>
<p>第一个参数needle为规定要在数组中搜索的值，第二个参数haystack是规定要被搜索的数组，如果给定的值needle存在与数组haystack中则返回TRUE，函数只有在元素存在于数组且数据类型与给定相同时才返回TRUE。如果没有在数组中找到参数，函数返回FALSE。要注意如果needle参数是字符串，且strict参数设置为TRUE，则搜索区分大小写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">        //in_array()函数的简单使用形式</div><div class="line">	$os = array(&quot;Mac&quot;, &quot;NT&quot;, &quot;Irix&quot;, &quot;Linux&quot;);</div><div class="line">		</div><div class="line">	if (in_array(&quot;Irix&quot;, $os)) &#123;       //这个条件成立，字符串Irix在数组$os中</div><div class="line">    		echo &quot;Got Irix&quot;;</div><div class="line">	&#125;</div><div class="line">	if (in_array(&quot;mac&quot;, $os)) &#123;        //这个条件失败，因为 in_array()是区分大小写的</div><div class="line">    		echo &quot;Got mac&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//in_array() 严格类型检查例子</div><div class="line">	$a = array(&apos;1.10&apos;, 12.4, 1.13);</div><div class="line"></div><div class="line">	if (in_array(&apos;12.4&apos;, $a, true)) &#123;  //第三个参数为true，所以字符串&apos;12.4&apos;和浮点数12.4类型不同</div><div class="line">		echo &quot;&apos;12.4&apos; found with strict check\n&quot;;</div><div class="line">	&#125;</div><div class="line">	if (in_array(1.13, $a, true)) &#123;   //这个条件成立，执行下面的语句</div><div class="line">   		 echo &quot;1.13 found with strict check\n&quot;;</div><div class="line">	&#125; </div><div class="line"></div><div class="line">	//in_array()中还可以用数组当作第一个参数作为查询条件</div><div class="line">	$a = array(array(&apos;p&apos;, &apos;h&apos;), array(&apos;p&apos;, &apos;r&apos;), &apos;o&apos;);</div><div class="line"></div><div class="line">	if (in_array(array(&apos;p&apos;, &apos;h&apos;), $a)) &#123;   //数组array(&apos;p&apos;, &apos;h&apos;)在数组$a中存在</div><div class="line">  		  echo &quot;&apos;ph&apos; was found\n&quot;;</div><div class="line">	&#125;</div><div class="line">	if (in_array(array(&apos;h&apos;, &apos;p&apos;), $a)) &#123;   //数组array(&apos;h&apos;, &apos;p&apos;)不存在数组$a中</div><div class="line">   		 echo &quot;&apos;hp&apos; was found\n&quot;;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>也可以使用array_search()函数进行检索。该函数与in_array()的参数相同，搜索给定的值存在则返回相应的键名，也支持对数据类型的严格判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;,&quot;b&quot;=&gt;&quot;Apache&quot;,&quot;c&quot;=&gt;&quot;MySQL&quot;,&quot;d&quot;=&gt;&quot;PHP&quot;);  </div><div class="line">	echo array_search(&quot;PHP&quot;,$lamp);  //输出：d  （在数组$lamp中，存在字符串&quot;php&quot;则输出下标d）</div><div class="line"></div><div class="line">	$a=array(&quot;a&quot;=&gt;&quot;8&quot;,&quot;b&quot;=&gt;8,&quot;c&quot;=&gt;&quot;8&quot;);</div><div class="line">	echo array_search(8,$a,true);   //输出：b （严格按类型检索，整型8对应的下标为b）</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>使用array_key_exists()函数还可以检查给定的键名或者索引是否存在于数组中。因为一个数组中键名必须是唯一的，所以不需要对其数据类型进行判断。也可以使用isset()函数完成对数组中的键名或者索引进行检查，但isset()对数组中为NULL的值不会返回TRUE，而array_key_exists()会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$search_array = array(&apos;first&apos; =&gt; 1, &apos;second&apos; =&gt; 4);     //声明一个关联数组，其中包含两个元素</div><div class="line">	</div><div class="line">	if (array_key_exists(&apos;first&apos;, $search_array)) &#123;         //检查下标为first对应的元素是否在数组中</div><div class="line">   		echo &quot;键名为&apos;first&apos;的元素在数组中&quot;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	$search_array = array(&apos;first&apos; =&gt; null, &apos;second&apos; =&gt; 4);  //声明一个关联数组，第一个元素的值为NULL</div><div class="line"></div><div class="line">	isset($search_array[&apos;first&apos;]);                          //使用isset()函数检索下标为first的元素，返回false  </div><div class="line">	array_key_exists(&apos;first&apos;, $search_array);               //使用array_key_exists()检索下标为first的元素，返回true</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-flip"><a href="#函数array-flip" class="headerlink" title="函数array_flip()"></a>函数array_flip()</h4><p>array_flip()的作用是交换数组中的键和值。返回一个反转后的数组，如果同一值出现了多次，则最后一个键名将作为它的值，覆盖前面出现的元素。如果原数组中的值的数据类型不是字符串或者整数，函数将报错。该函数只有一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_flip(array trans)</div></pre></td></tr></table></figure></p>
<p>参数是必需的，要求输入一个要处理的数组，返回该数组中每个元素的键和值交换后的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;OS&quot;=&gt;&quot;Linux&quot;,&quot;WebServer&quot;=&gt;&quot;Apache&quot;,&quot;Database&quot;=&gt;&quot;MySQL&quot;, &quot;Language&quot;=&gt;&quot;PHP&quot;); </div><div class="line"></div><div class="line">	//输出：Array ( [Linux] =&gt; OS [Apache] =&gt; WebServer [MySQL] =&gt; Database [PHP] =&gt; Language )</div><div class="line">	print_r(array_flip($lamp));              //使用array_flip()函数交换数组中的键和值</div><div class="line"></div><div class="line"> 	//在数组中如果元素的值相同，则使用array_flip()会发生冲突</div><div class="line">	$trans = array(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 1, &quot;c&quot; =&gt; 2);</div><div class="line">	print_r(array_flip($trans));              //现在 $trans 变成了： Array( [1] =&gt; b [2] =&gt; c)</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-reverse"><a href="#函数array-reverse" class="headerlink" title="函数array_reverse()"></a>函数array_reverse()</h4><p>array_reverse()作用是将原数组中的元素顺序翻转，创建新的数组并返回。该函数有两个参数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_reverse(array array[,bool preserve_keys])</div></pre></td></tr></table></figure></p>
<p>第一个参数是必需项，接受一个数组作为输入。第二个参数是可选项。如果指定为TURE，则元素的键名保持不变，否则键名将丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;OS&quot;=&gt;&quot;Linux&quot;,&quot;WebServer&quot;=&gt;&quot;Apache&quot;,&quot;Database&quot;=&gt;&quot;MySQL&quot;, &quot;Language&quot;=&gt;&quot;PHP&quot;);</div><div class="line">	print_r(array_reverse($lamp));   //使用array_reverse()函数将数组$lamp中元素的顺序翻转</div><div class="line">	//输出结果Array ([Language]=&gt;PHP [Database]=&gt;MySQL [WebServer]=&gt;Apache [OS]=&gt;Linux) </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="统计数组元素的个数和唯一性"><a href="#统计数组元素的个数和唯一性" class="headerlink" title="统计数组元素的个数和唯一性"></a>统计数组元素的个数和唯一性</h3><h4 id="函数count"><a href="#函数count" class="headerlink" title="函数count()"></a>函数count()</h4><p>函数count()的作用是计算数组中的元素数目或对象中的属性个数。对于数组，返回其元素的个数，对于其他值则返回1。如果参数是变量而变量没有定义或是变量包含一个空的数组，该函数会返回0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int count(mixed var[,int mode])</div></pre></td></tr></table></figure></p>
<p>其中第一个参数是必需的，传入要计数的数组或对象。第二个参数是可选的，规定函数的模式是否递归地计算多维数组中的数组的元素个数。可能的值是0和1，0是默认值，不检测多维数组，1则检测多维数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp = array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);</div><div class="line">	echo count($lamp); //输出数组的个数为：4</div><div class="line">    </div><div class="line">        //声明一个二维数组，统计数组中元素的个数</div><div class="line">	$web= array(&apos;lamp&apos;  =&gt; array(&apos;Linux&apos;, &apos;Apache&apos;, &apos;MySQL&apos;,&apos;PHP&apos;),   </div><div class="line">                 &apos;j2ee&apos;  =&gt; array(&apos;Unix&apos;, &apos;Tomcat&apos;,&apos;Oracle&apos;,&apos;JSP&apos;));</div><div class="line"></div><div class="line">	echo count($web, 1);   //第二个参数的模式为1则计算多维数组的个数，输出10</div><div class="line">	echo count($web);     //默认模式为0，不计算多维数组的个数，输出2</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数array-count-values"><a href="#函数array-count-values" class="headerlink" title="函数array_count_values()"></a>函数array_count_values()</h4><p>array_count_values()函数用于统计数组中所有值出现的次数。该函数只有一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_count_values(array input)</div></pre></td></tr></table></figure></p>
<p>参数规定输入一个数组，返回一个数组，其元素的键名是原数组的值，键值是该值在原数组中出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$array = array(1, &quot;php&quot;, 1, &quot;mysql&quot;, &quot;php&quot;);     //声明一个带有重复值的数组</div><div class="line">	$newArray=array_count_values ($array);           //统计数组$array中所有值出现的次数</div><div class="line">	print_r($newArray);                              //输出：Array([1] =&gt; 2 [php] =&gt; 2 [mysql] =&gt; 1)</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-unique"><a href="#函数array-unique" class="headerlink" title="函数array_unique()"></a>函数array_unique()</h4><p>array_unique()函数用于删除数组中重复的值，并返回没有重复值的新数组。该函数只有一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_unique(array array)</div></pre></td></tr></table></figure></p>
<p>参数需要接收一个数组，数组中几个元素的值相等时，只保留第一个元素，其他的元素被删除，并返回的新数组中键名不变。array_unique()先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的array中同一个值的出现的键名会被保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a=array(&quot;a&quot;=&gt;&quot;php&quot;,&quot;b&quot;=&gt;&quot;mysql&quot;,&quot;c&quot;=&gt;&quot;php&quot;);  //声明一个带有重复值的数组</div><div class="line">	print_r(array_unique($a));  		       //删除重复值后输出：Array ([a] =&gt; php [b] =&gt; mysql)</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="使用回调函数处理数组的函数"><a href="#使用回调函数处理数组的函数" class="headerlink" title="使用回调函数处理数组的函数"></a>使用回调函数处理数组的函数</h3><h4 id="函数array-filter"><a href="#函数array-filter" class="headerlink" title="函数array_filter()"></a>函数array_filter()</h4><p>array_filter()函数用回调函数过滤数组中的元素，返回按用户自定义函数过滤后的新数组。<br>该函数的第一个参数是必选项，要求输入一个被过滤的数组。第二个参数是可选项，将用户自定义的函数名以字符串形式传入。如果自定义过滤函数返回true,则被操作的数组的当前值就会被包含在返回的结果数值中，并将结果组成一个新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function myFun($var)&#123;      				 //自定义函数myFun，如果参数能被2整除则返回真</div><div class="line">		if($var % 2 == 0)</div><div class="line">			return true;</div><div class="line">	&#125;	</div><div class="line"></div><div class="line">	$array = array(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3, &quot;d&quot;=&gt;4, &quot;e&quot;=&gt;5);  //声明值为整数序列的数组</div><div class="line">        //使用函数array_filter()将自定义的函数名以字符串的形式传给第二个参数</div><div class="line">	print_r(array_filter($array, &quot;myFun&quot;)); //过滤后的结果输出Array ( [b] =&gt; 2 [d] =&gt; 4 ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-walk"><a href="#函数array-walk" class="headerlink" title="函数array_walk()"></a>函数array_walk()</h4><p>array_walk()函数对数组中的每个元素应用回调函数处理。如果成功则返回TRUE，否则返回FLASE。<br>该函数的第一个参数是必选项，要求输入一个指定的回调函数处理的数组。第二个参数也是必选项，传入用户定义的回调函数，用于操作传入第一个参数的数组。array_walk()函数依次将第一个参数的数组中的每一个值传递到这个自定义的函数中。自定义的这个回调函数中应该接收两个参数，一次传入进来元素的值作为第一个参数，键名作为第二个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function myFun1($value,$key) &#123;                   	//定义一个回调函数接收两个参数</div><div class="line">		echo &quot;The key $key has the value $value&lt;br&gt;&quot;;   //将参数连接在一超输出</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;,&quot;b&quot;=&gt;&quot;Apache&quot;,&quot;c&quot;=&gt;&quot;Mysql&quot;,&quot;d&quot;=&gt;&quot;PHP&quot;);  //定义一个数组$lamp</div><div class="line">	array_walk($lamp,&quot;myFun1&quot;);       				  //使用array_walk函数传入一个数组和一个回调函数</div><div class="line">	/*  执行后输出如下结果：</div><div class="line">	    The key a has the value Linux</div><div class="line">	    The key b has the value Apache</div><div class="line">	    The key c has the value MySQL</div><div class="line">	    The key d has the value PHP */</div><div class="line"></div><div class="line">	function myFun2($value,$key,$p)  &#123;        	  //自定义一个回调函数需要接受三个参数</div><div class="line">		echo &quot;$key $p $value &lt;br&gt;&quot;;               //将三个参数连接后输出</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	array_walk($lamp,&quot;myFun2&quot;,&quot;has the value&quot;);   	  //使用array_walk函数传入三个参数</div><div class="line">	/*执行后输出如下结果：	</div><div class="line">	  a has the value Linux </div><div class="line">	  b has the value Apache </div><div class="line">	  c has the value MySQL</div><div class="line">       d has the value PHP     */</div><div class="line"></div><div class="line">	function myFun3(&amp;$value,$key) &#123;      		//改变数组元素的值（请注意 &amp;$value传入引用）</div><div class="line">		$value=&quot;Web&quot;;                 		//将改变原数组中每个元素的值</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	array_walk($lamp,&quot;myFun3&quot;);   //使用array_walk函数传入两个参数，其中第一个参数为引用</div><div class="line">	print_r($lamp);               //输出：Array ( [a] =&gt; Web [b] =&gt; Web [c] =&gt; Web [d] =&gt; Web ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-map"><a href="#函数array-map" class="headerlink" title="函数array_map()"></a>函数array_map()</h4><p>array_map()函数可以处理多个数组，将回调函数作用到给定数组的元素上，返回用户自定义函数作用后的数组，array_map()是任意参数列表函数，回调函数接受的参数数目应该和传递给array_map()函数的数组数目一致。<br>该函数中的第一个参数是必选项，是用户自定义的回调函数的名称，或者是Null。第二个参数也是必选项，输入要处理的函数。也可以接着输入多个数组作为可选参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function myFun1($v) &#123;       //自定义一个函数作为回调函数，接收数组中每个元素做为参数</div><div class="line">		if ($v===&quot;MySQL&quot;) &#123;   //如果数组中元素的值恒等于MySQL条件成功</div><div class="line"> 			return &quot;Oracle&quot;;    //返回Oracle</div><div class="line">		&#125;</div><div class="line">		return $v;             //不等于MySQL的元素都返回传入的值，即原型返回</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$lamp=array(&quot;Linux&quot;,&quot;Apache&quot;,&quot;MySQL&quot;,&quot;PHP&quot;);   //声明一个有4个元素的数组$lamp</div><div class="line">	</div><div class="line">	print_r(array_map(&quot;myFun1&quot;,$lamp));   //使用array_map()函数传入一个函数名和一个数组参数</div><div class="line">	/*上面程序执行后输出Array ( [0] =&gt; Linux [1] =&gt; Apache [2] =&gt; Oracle [3] =&gt; PHP ) */</div><div class="line">	</div><div class="line">	//使用多个参数, 回调函数接受的参数数目应该和传递给array_map()函数的数组数目一致</div><div class="line">	function myFun2($v1,$v2) &#123;   		  //自定义一个函数需要两个参数，两个数组中的元素依次传入</div><div class="line">		if ($v1===$v2) &#123;         	  //如果两个数组中的元素值相同则条件成功</div><div class="line">			return &quot;same&quot;;       	  //返回same, 说明两个数组中对应的元素值相同</div><div class="line">		&#125;</div><div class="line">		return &quot;different&quot;;         	  //如果两个数组中对应的元素值不同，返回different</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	$a1=array(&quot;Linux&quot;,&quot;PHP&quot;,&quot;MySQL&quot;);  	  //声明数组$a1,有三个元素</div><div class="line">	$a2=array(&quot;Unix&quot;,&quot;PHP&quot;,&quot;Oracle&quot;);    	  //数组$a第二个元素值和$a中第二个元素的值相同</div><div class="line">	</div><div class="line">	print_r(array_map(&quot;myFun2&quot;,$a1,$a2)); 	  //使用array_map()函数传入多个数组</div><div class="line">	/*上面程序执行后输出：Array ( [0] =&gt; different [1] =&gt; same [2] =&gt; different ) */</div><div class="line">	</div><div class="line">	//当自定义函数名设置为 null 时的情况</div><div class="line">	$a1=array(&quot;Linux&quot;,&quot;Apache&quot;);         	 //声明一个数组$a1, 有两个元素</div><div class="line">	$a2=array(&quot;MySQL&quot;,&quot;PHP&quot;);         	 //声明另一个数组$a2,也有两个元素</div><div class="line"></div><div class="line">	print_r(array_map(null,$a1,$a2));     	 //通过第一个参数设置为NULL，构造一个数组的数组</div><div class="line">	/*上面程序执行后输出：Array ( </div><div class="line">		[0] =&gt; Array ( [0] =&gt; Linux [1] =&gt; MySQL ) </div><div class="line">		[1] =&gt; Array ( [0] =&gt; Apache [1] =&gt; PHP ) ) */ </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="数组的排序函数"><a href="#数组的排序函数" class="headerlink" title="数组的排序函数"></a>数组的排序函数</h3><table>
<thead>
<tr>
<th>排序函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort()</td>
<td style="text-align:left">按由小到大的升序对给定数组的值排序</td>
</tr>
<tr>
<td>rsort()</td>
<td style="text-align:left">对数组的元素按照键值进行由大到小的逆向排序</td>
</tr>
<tr>
<td>usort()</td>
<td style="text-align:left">使用用户自定义的回调函数对数组排序</td>
</tr>
<tr>
<td>asort()</td>
<td style="text-align:left">对数组进行由小到大排序并保持索引关系</td>
</tr>
<tr>
<td>uaort()</td>
<td style="text-align:left">使用用户自定义的比较回调函数对数组中的值进行排序并保持索引关联</td>
</tr>
<tr>
<td>ksort()</td>
<td style="text-align:left">按照键名对数组进行由小到大的排序，为数组值保留原来的键</td>
</tr>
<tr>
<td>krsort()</td>
<td style="text-align:left">将数组按照由大到小的键逆向排序，为数组值保留原来的键</td>
</tr>
<tr>
<td>ukrsort()</td>
<td style="text-align:left">使用用户自定义的比较回调函数对数组中的键名进行排序</td>
</tr>
<tr>
<td>natsort()</td>
<td style="text-align:left">用自然顺序算法对给定数组中的元素排序</td>
</tr>
<tr>
<td>natcasesort()</td>
<td style="text-align:left">用不区分大小写的自然顺序算法对给定数组中的元素排序</td>
</tr>
<tr>
<td>array_multisort()</td>
<td style="text-align:left">对多个数组或多维数组进行排序</td>
</tr>
</tbody>
</table>
<h4 id="简单的数组排序函数"><a href="#简单的数组排序函数" class="headerlink" title="简单的数组排序函数"></a>简单的数组排序函数</h4><p>这两个函数既可以按数字大小排列也可以按字母顺序排列，并具有相同的参数列表。其函数的原型分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bool sort(array $array[,int sort_flags])</div><div class="line">bool rsort(array $array[,int sort_flags])</div></pre></td></tr></table></figure></p>
<p>第一个参数是必需的，指定需要排序的数组。后一个参数是可选的，给出了排序的方式，可以用以下值改变排序的行为：</p>
<ul>
<li>SORT_REGULAR-是默认值，将自动识别数组元素的类型进行排序</li>
<li>SORT_NUMERIC-用于数字元素的排序</li>
<li>SORT_STRING-用于字符串元素的排序</li>
<li>SORT_LOCALE_STRING-根据当前的locale设置来把元素当做字符串比较</li>
</ul>
<p>sort()函数对数组中的元素值按照由小到大顺序进行排序，rsort()函数则按照由大到小的顺序对元素的值进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$data = array(5,8,1,7,2);  //声明一个数组$data, 存放5个整数元素</div><div class="line"></div><div class="line">	sort($data);               //使用sort()函数将数组$data中的元素值按照由小到大顺序进行排序</div><div class="line">	print_r($data);            //输出：Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 5 [3] =&gt; 7 [4] =&gt; 8 )</div><div class="line"></div><div class="line">	rsort($data);              //使用rsort()函数将数组$data按照由大到小的顺序对元素的值进行排序</div><div class="line">	print_r($data);            //输出：Array ( [0] =&gt; 8 [1] =&gt; 7 [2] =&gt; 5 [3] =&gt; 2 [4] =&gt; 1 )</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="根据键名对数组排序"><a href="#根据键名对数组排序" class="headerlink" title="根据键名对数组排序"></a>根据键名对数组排序</h4><p>根据键名对数组重新排序，ksort()和krsort()函数可以实现。ksort()函数按照键名对数组进行由小到大的排序，krsort()函数和ksort()相反，排序后为数组值保留原来的键。使用的格式与sort()和rsort()相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$data = array(5=&gt;&quot;five&quot;,8=&gt;&quot;eight&quot;,1=&gt;&quot;one&quot;,7=&gt;&quot;seven&quot;,2=&gt;&quot;two&quot;);  //声明一个键值混乱的数组</div><div class="line">	</div><div class="line">	ksort($data);      //使用ksort()函数按照键名对数组$data进行由小到大的排序</div><div class="line">	print_r($data);    //输出：Array ( [1] =&gt; one [2] =&gt; two [5] =&gt; five [7] =&gt; seven [8] =&gt; eight )</div><div class="line"></div><div class="line">	krsort($data);     //使用krsort()函数按照键名对数组$data进行由大到小的排序</div><div class="line">	print_r($data);    //输出：Array ( [8] =&gt; eight [7] =&gt; seven [5] =&gt; five [2] =&gt; two [1] =&gt; one )</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="根据元素的值对数组排序"><a href="#根据元素的值对数组排序" class="headerlink" title="根据元素的值对数组排序"></a>根据元素的值对数组排序</h4><p>使用数组中元素的值进行排序来取代键值排序。asort()和arsort()函数将保留原有键名和值的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$data = array(&quot;l&quot;=&gt;&quot;Linux&quot;, &quot;a&quot;=&gt;&quot;Apache&quot;,&quot;m&quot;=&gt;&quot;MySQL&quot;,&quot;p&quot;=&gt;&quot;PHP&quot;);</div><div class="line">	</div><div class="line">	asort($data);     //使用asort()函数将数组$data按元素的值升序排序，并保留原有的键名和值</div><div class="line">	print_r($data);   //输出：Array ( [a] =&gt; Apache [l] =&gt; Linux [m] =&gt; MySQL [p] =&gt; PHP )</div><div class="line"></div><div class="line">	arsort($data);    //使用arsort()函数将数组$data按元素的值降序排序，并保留原有的键名和值</div><div class="line">	print_r($data);   //输出：Array ( [p] =&gt; PHP [m] =&gt; MySQL [l] =&gt; Linux [a] =&gt; Apache )</div><div class="line">	</div><div class="line">	rsort($data);     //使用asort()函数将数组$data按元素的值降序排序，但原始键名被忽略</div><div class="line">	print_r($data);   //输出：Array ( [0] =&gt; PHP [1] =&gt; MySQL [2] =&gt; Linux [3] =&gt; Apache ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="根据“自然排序”法对数组排序"><a href="#根据“自然排序”法对数组排序" class="headerlink" title="根据“自然排序”法对数组排序"></a>根据“自然排序”法对数组排序</h4><p>“自然排序”法，即数字从1到9的排序方法，字母从a到z的排序方法，短者优先。使用natsort()进行“自然排序”法的数组排序，该函数的排序结果是忽略键名的。函数netcasesort()是用“自然排序”算法对数组尽心不区分大小写的排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$data = array(&quot;file1.txt&quot;, &quot;file11.txt&quot;, &quot;File2.txt&quot;, &quot;FILE12.txt&quot;, &quot;file.txt&quot;);</div><div class="line">	</div><div class="line">	natsort($data);      //普通的“自然排序”</div><div class="line">	print_r($data);      //输出排序后的结果，数组中包括大小写，输出不是正确的排序结果</div><div class="line"></div><div class="line">	natcasesort($data);  //忽略大小写的“自然排序”</div><div class="line">	print_r($data);      //输出“自然排序”后的结果，正常结果</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="根据用户自定的规则对数组排序"><a href="#根据用户自定的规则对数组排序" class="headerlink" title="根据用户自定的规则对数组排序"></a>根据用户自定的规则对数组排序</h4><p>usort()、uasort()和uksort()等函数提供了可以通过创建你自己的比较函数作为回调函数的数组排序函数。它们的使用格式一样，并具有相同的参数列表，区别在于对键还是值进行排序。<br>这三个函数将用户自定义的比较函数对一个数组中的值进行排序。如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用这几个函数。在自定义的回调函数中，需要两个参数，分别依次传入数组中连续的两个元素。比较函数比较在第一个参数被认为小于、等于或大于第二个参数时分别返回一个小于，等于或大于零的整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">	$lamp = array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);   //声明一个数组，其中元素值的长度不相同</div><div class="line"></div><div class="line">	usort($lamp, &quot;sortByLen&quot;);          		    //使用usort()函数传入用户自定义的回调函数进行数组排序</div><div class="line">	print_r($lamp);   	             // 排序后输出：Array ( [0] =&gt; PHP [1] =&gt; MySQL [2] =&gt; Linux [3] =&gt; Apache )</div><div class="line">	</div><div class="line">	function sortByLen($one, $two) &#123;     //自定义的函数做为回调用函数提供给usort()函数使用</div><div class="line">		if (strlen($one) == strlen($two))  //如果两个参数长度相等返回0，在数组中位置不变</div><div class="line">			return 0;</div><div class="line">		else       		     //第一个参数大于第二个参数返回大于0的数，否则返回小于0的数</div><div class="line">			return (strlen($one) &gt; strlen($two)) ? 1 : -1;  </div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="多维数组的排序"><a href="#多维数组的排序" class="headerlink" title="多维数组的排序"></a>多维数组的排序</h4><p>php允许在多维数组上执行一些比较复杂的排序。可以使用array_multisort()函数对多个数组或多维数组进行排序，或者根据某一维或多维对多维数组进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool array_multisort(array ar1[,mixed arg[,mixed ...[,array ...]]])</div></pre></td></tr></table></figure></p>
<p>该函数如果成功则返回TRUE，失败则返回FLASE。第一个参数是要排序的主要数组。数组中的值比较为相同的话，就按照下一个输入数组中相应值的大小来排序，以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">	$data = array(                   	 //声明一个$data数组，模拟了一个行和列数组</div><div class="line">	  		array(&quot;id&quot; =&gt; 1, &quot;soft&quot; =&gt; &quot;Linux&quot;, &quot;rating&quot; =&gt; 3),</div><div class="line">			array(&quot;id&quot; =&gt; 2, &quot;soft&quot; =&gt; &quot;Apache&quot;, &quot;rating&quot; =&gt; 1),</div><div class="line">			array(&quot;id&quot; =&gt; 3, &quot;soft&quot; =&gt; &quot;MySQL&quot;, &quot;rating&quot; =&gt; 4),</div><div class="line">			array(&quot;id&quot; =&gt; 4, &quot;soft&quot; =&gt; &quot;PHP&quot;, &quot;rating&quot; =&gt; 2),</div><div class="line">		); </div><div class="line">	//使用foreach遍历创建两个数组作为array_multisort的参数</div><div class="line">	foreach ($data as $key =&gt; $value) &#123;</div><div class="line">		$soft[$key] = $value[&quot;soft&quot;];     //将$data中的每个数组元素中键值为soft的值形成数组$soft</div><div class="line">		$rating[$key] = $value[&quot;rating&quot;];  //将每个数组元素中键值为rating的值形成数组$rating</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	array_multisort($rating, $soft, $data);   //使用array_multisort()函数传入三个数组进行排序</div><div class="line">	print_r($data);                      	  //输出排序后的二维数组</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="拆分、合并、分解和接合数组"><a href="#拆分、合并、分解和接合数组" class="headerlink" title="拆分、合并、分解和接合数组"></a>拆分、合并、分解和接合数组</h3><h4 id="函数array-slice"><a href="#函数array-slice" class="headerlink" title="函数array_slice()"></a>函数array_slice()</h4><p>array_slice()函数的作用是在数组中根据条件取出一段值并返回。如果数组有字符串键，所返回的数组将保留键名。该函数可以设置四个参数。第一个参数array是必选项，调用时输入要处理的数组。第二个参数offset也是必须的参数，需要传入一个数组，规定取出元素的开始位置。如果是正数，则从前往后开始取，如果是负值，从后向前取offset绝对值数目的元素。<br>第三个参数是可选的，需要传入一个数值，规定被返回数组的长度，如果是负数则从后往前，选取该值绝对值数目的元素。如果未设置该值，则返回所有元素。第四个参数也是可选的，需要一个布尔类型的值，如果为TRUE值则所返回的数组将保留键名。设置为FLASE值，也是默认值将重新设置索引键值。注意的是，如果数组有字符串键，所返回的数组将保留键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);     //声明一个索引数组$lamp包含4个元素</div><div class="line">	//使用array_slice()从第二个开始取(0是第一个，1为第二个)，取两个元素从数组$lamp中返回</div><div class="line">	print_r(array_slice($lamp,1,2));                    //输出：Array ( [0] =&gt; Apache [1] =&gt; MySQL )</div><div class="line">	//第二个参数使用负数参数为-2，从后面第二个开始取，返回一个元素</div><div class="line">	print_r(array_slice($lamp,-2,1));                   //输出： Array ( [0] =&gt; MySQL ) </div><div class="line">	//最后一个参数设置为 true，保留原有的键值返回</div><div class="line">	print_r(array_slice($lamp,1,2,true));               //输出：Array ( [1] =&gt; Apache [2] =&gt; MySQL ) </div><div class="line"></div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;,&quot;b&quot;=&gt;&quot;Apache&quot;,&quot;c&quot;=&gt;&quot;MySQL&quot;,&quot;d&quot;=&gt;&quot;PHP&quot;);     //声明一个关联数组</div><div class="line">   	//如果数组有字符串键，默认所返回的数组将保留键名</div><div class="line">	print_r(array_slice($lamp,1,2));                    //输出：Array ( [b] =&gt; Apache [c] =&gt; MySQL ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-splice"><a href="#函数array-splice" class="headerlink" title="函数array_splice()"></a>函数array_splice()</h4><p>array_splice()和array_slice()函数类似，选择数组中的一系列元素，但不返回，而是删除他们并用其他值代理。如果提供了第四个参数，则之前选中的那些元素将被第四个参数指定的数组取代，最后生成的数组将会返回。<br>第一个参数array为必选项，规定要处理的数组。第二个参数offset也是必选项，调用时传入数值。如果offset为正数，则输入数组中该值指定的偏移量开始移除，如果offset为负，则从输入数组末尾倒数该值指定的偏移量开始移除。第三个参数length是可选的，也需要一个数值，如果省略该参数，则移除数组中从offset到结尾的所有部分。如果指定了length并且为正值，则移除这么多元素。如果指定了length且为负值，则移除从offset到数组末尾倒数length为止中间所有的元素。第四个参数array也是可选的，被移除的元素由此数组中的元素替代。如果没有移除任何值，则此数组中的元素将插入到指定位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$input = array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);</div><div class="line">	array_splice($input, 2);      	 //原数组中的第二个元素后到数组结尾都被删除</div><div class="line">	print_r($input);                 //输出：Array ( [0] =&gt; Linux [1] =&gt; Apache )</div><div class="line"></div><div class="line">	$input = array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);</div><div class="line">	array_splice($input, 1, -1);     //从第二个开始移除直到数组末尾倒数1个为止中间所有的元素</div><div class="line">	print_r($input);                 //输出：Array ( [0] =&gt; Linux [1] =&gt; PHP )</div><div class="line"></div><div class="line">	$input = array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);</div><div class="line">	array_splice($input, 1, count($input), &quot;web&quot;);      //从第二个元素到数组结尾都被第4个参数替代</div><div class="line">	print_r($input);                                    //输出：Array ( [0] =&gt; Linux [1] =&gt; web )</div><div class="line"></div><div class="line">	$input = array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);</div><div class="line">	array_splice($input, -1, 1, array(&quot;web&quot;, &quot;www&quot;));  //最后一个元素被第4个参数数组替代</div><div class="line">	print_r($input); //输出：Array ( [0] =&gt; Linux [1] =&gt; Apache [2] =&gt; MySQL [3] =&gt; web [4] =&gt; www )</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数array-combine"><a href="#函数array-combine" class="headerlink" title="函数array_combine()"></a>函数array_combine()</h4><p>array_combine()函数的作用是通过合并两个数组来创建一个新数组。其中的一个数组是键名，另一个数组的值为键值。如果其中一个数组为空，或者两个数组的元素个数不同，则该函数返回false。<br>该函数有两个参数且都是必选项，两个参数必须有相同数目的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a1=array(&quot;OS&quot;,&quot;WebServer&quot;,&quot;DataBase&quot;,&quot;Language&quot;);    //声明第一个数组作为参数1</div><div class="line">	$a2=array(&quot;Linux&quot;,&quot;Apache&quot;,&quot;MySQL&quot;,&quot;PHP&quot;);            //声明第二个数组作为参数2</div><div class="line">	print_r(array_combine($a1,$a2));                      //使用arrray_combine()将两个数组合并</div><div class="line">//输出：Array ( [OS] =&gt; Linux [WebServer] =&gt; Apache [DataBase] =&gt; MySQL [Language] =&gt; PHP )</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数array-merge"><a href="#函数array-merge" class="headerlink" title="函数array_merge()"></a>函数array_merge()</h4><p>array_merge()函数的作用是把一个或多个数组合并为一个数组，如果键名有重复，该键的键值为最后一个键名的值（后面的覆盖前面的）。如果数组是数字索引的，则键名会以连续方式重新索引。注意如果仅仅向array_merge()函数输入了一个数组，且键名是整数，则该函数将返回带有整数键名的新数组，其键名以0开始进行重新索引。<br>该函数第一个参数是必选项，需要传入一个数组。可以有多个可选参数。但必须都是数组类型的数据。返回将多个数组合并后的新数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a1=array(&quot;a&quot;=&gt;&quot;Linux&quot;,&quot;b&quot;=&gt;&quot;Apache&quot;);</div><div class="line">	$a2=array(&quot;c&quot;=&gt;&quot;MySQL&quot;,&quot;b&quot;=&gt;&quot;PHP&quot;);</div><div class="line">	print_r(array_merge($a1,$a2)); 	//输出： Array ( [a] =&gt; Linux [b] =&gt; PHP [c] =&gt; MySQL ) </div><div class="line">	</div><div class="line">	//仅使用一个数组参数则键名以0开始进行重新索引</div><div class="line">	$a=array(3=&gt;&quot;PHP&quot;,4=&gt;&quot;MySQL&quot;);</div><div class="line">	print_r(array_merge($a));	 //输出：Array ( [0] =&gt; PHP [1] =&gt; MySQL ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数array-intersect"><a href="#函数array-intersect" class="headerlink" title="函数array_intersect()"></a>函数array_intersect()</h4><p>array_intersect()函数的作用是返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的元素值。返回的数组中，键名保持不变。<br>第一个参数是必选项，传入与其他数组进行比较的数组。第二个参数也是必选项，传入与第一个数组进行比较的数组。可以有多个可选参数作为以后的参数，与第一个数组进行比较的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a1=array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);  	  //声明第一个数组，作为比较的第一个参数</div><div class="line">	$a2=array(&quot;Linux&quot;, &quot;Tomcat&quot;, &quot;MySQL&quot;, &quot;JSP&quot;);     //声明第二个数组，作为比较的第二个参数</div><div class="line">	print_r(array_intersect($a1,$a2));                //输出Array ( [0] =&gt; Linux [2] =&gt; MySQL ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="函数array-diff"><a href="#函数array-diff" class="headerlink" title="函数array_diff()"></a>函数array_diff()</h4><p>array_diff()函数的作用是返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的元素值。在返回到数组中，键名保持不变。<br>第一个参数是必选项，传入与其他数组进行比较的数组。第二个参数也是必选项，传入与第一个数组进行比较的数组。第三个参数以后都是可选项，可用一个或任意多个数组与第一个数组进行比较，本函数仅有值用于比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a1=array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);    //声明第一个数组，作为比较的第一个参数</div><div class="line">	$a2=array(&quot;Linux&quot;, &quot;Tomcat&quot;, &quot;MySQL&quot;, &quot;JSP&quot;);    //声明第二个数组，作为比较的第二个参数</div><div class="line">	print_r(array_diff($a1,$a2));                    //输出:Array ( [1] =&gt; Apache [3] =&gt; PHP ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="数组与数据结构"><a href="#数组与数据结构" class="headerlink" title="数组与数据结构"></a>数组与数据结构</h3><h4 id="使用数组实现堆栈"><a href="#使用数组实现堆栈" class="headerlink" title="使用数组实现堆栈"></a>使用数组实现堆栈</h4><p>堆栈是数据结构的一种实现形式，是使用非常广泛的存储数据的一种容器。在堆栈这种容器中，最后压入的数据（进栈），将会被最先弹出（出栈）。即在数据存储事采用“先进后出”的数据结构。在PHP中，将数组当做一个栈，使用array_push()和array_pop()两个系统函数即可完成数据的进栈和出栈操作。</p>
<p>array_push()函数向第一个参数的数组尾部添加一个或者多个元素(入栈),然后返回新数组的长度。该函数等于多次调用$array[]=$value。<br>该函数的第一个参数是必选的，作为栈容器的第一个数组。第二个参数也是必选的，在第一个参数中的数组尾部添加的一个数据。还可以有多个可选参数，都可以添加到第一个参数的数组中的尾部，即入栈。但要注意计时数组中有字符串键名，添加的元素也始终是数字键，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;Web&quot;);             	//声明一个数当作为栈，数为数组array_push()函数第一个参数</div><div class="line">	echo array_push($lamp,&quot;Linux&quot;);   	//将字符串”Linux”压入数组$lamp中，返回数组中元素个数2</div><div class="line">	print_r($lamp);                		//输出数组中（栈）成员：Array ( [0] =&gt; Web [1] =&gt; Linux )</div><div class="line"></div><div class="line">     	//又连续压入三个数据到数组$lamp的尾部</div><div class="line">	echo array_push($lamp,&quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);    //输出栈中元素的长度为5</div><div class="line">	print_r($lamp);    //输出： Array ( [0] =&gt; Web [1] =&gt; Linux [2] =&gt; Apache [3] =&gt; MySQL [4] =&gt; PHP )</div><div class="line"></div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;,&quot;b&quot;=&gt;&quot;Apache&quot;);    	    //带有字符串键的数组</div><div class="line">	echo array_push($lamp,&quot;MySQL&quot;,&quot;PHP&quot;);     	     //压入两个元素到数组的尾部, 输出栈长度为4</div><div class="line">	print_r($lamp);    // Array ( [a] =&gt; Linux [b] =&gt; Apache [0] =&gt; MySQL [1] =&gt; PHP )   //也是数字键</div><div class="line">   </div><div class="line">    	$lamp[&quot;web&quot;]=&quot;www&quot;;   //使用array_push()函数和使用这种直接赋值初使化数组的方式是一样的</div><div class="line">	print_r($lamp);       //Array ( [a] =&gt; Linux [b] =&gt; Apache [0] =&gt; MySQL [1] =&gt; PHP [web] =&gt; www )</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>array_pop()函数删除数组中的最后一个元素，即将数组最后一个单元弹出（出栈），并将数组的长度减1，如果数组为空（或者不是数组）将返回NULL。<br>该函数只有一个参数，即作为栈的数组。返回弹出的数组中最后一个元素的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;Linux&quot;,&quot;Apache&quot;,&quot;MySQL&quot;, &quot;PHP&quot;); //声明一个数组作为栈</div><div class="line"></div><div class="line">	echo array_pop($lamp);  //弹出数组中最后的元素并返回被删除的值，输出PHP</div><div class="line">	print_r($lamp);         //被弹出后的结果:Array ( [0] =&gt; Linux [1] =&gt; Apache [2] =&gt; MySQL ) </div><div class="line"></div><div class="line">	echo array_pop($lamp);  //再弹出数组中最后的元素并返回被删除的值，输出MySQL</div><div class="line">	print_r($lamp);         //被弹出后的结果:Array ( [0] =&gt; Linux [1] =&gt; Apache ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="使用数组实现队列"><a href="#使用数组实现队列" class="headerlink" title="使用数组实现队列"></a>使用数组实现队列</h4><p>PHP中的数组处理函数还可以将数组实现队列的操作。堆栈是“后劲先出”，而一个队列则允许在一段插入数据，在另一端删除数据，也就是实现最先进入队列的数据最先退出队列，即队列是“先进先出”的原则。<br>函数array_shift()可以实现删除数组中的第一个元素，并返回被删除元素的值。<br>该函数只有一个必选参数，其参数为实现队列的数组。将数组中的第一个单元一处并作为结构返回，并将数组的长度减1，还将所有其他的元素向前移动一位。所有的数字键名将改为0开始计数，字符串键名将保持不变。如果数组为空（或不是数组），则返回NULL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?</div><div class="line">	//带有字符串键值的关联数组</div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;, &quot;b&quot;=&gt;&quot;Apache&quot;, &quot;c&quot;=&gt;&quot;MySQL&quot;, &quot;d&quot;=&gt;&quot;PHP&quot;);</div><div class="line">	echo array_shift($lamp);  //删除数组第一个元素并返回，输出Linux</div><div class="line">	print_r ($lamp);          //字符串键值保持不变：Array ( [b] =&gt; Apache [c] =&gt; MySQL [d] =&gt; PHP )</div><div class="line"></div><div class="line">	//带有数字键的索引数组</div><div class="line">	$lamp=array(&quot;Linux&quot;, &quot;Apache&quot;, &quot;MySQL&quot;, &quot;PHP&quot;);</div><div class="line">	echo array_shift($lamp);   //删除数组第一个元素并返回，输出Linux</div><div class="line">	print_r ($lamp);           //数字下标重新索引Array ( [0] =&gt; Apache [1] =&gt; MySQL [2] =&gt; PHP ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>在PHP中还可以使用array_unshift()函数在队列数组的开头插入一个或者多个元素，该函数执行成功将返回插入元素个数，使用格式和函数array_push()是一样的。</p>
<h3 id="其他有用的数组处理函数"><a href="#其他有用的数组处理函数" class="headerlink" title="其他有用的数组处理函数"></a>其他有用的数组处理函数</h3><h4 id="函数array-rand"><a href="#函数array-rand" class="headerlink" title="函数array_rand()"></a>函数array_rand()</h4><p>array_rand()函数从数组中随机选出一个或多个元素，并返回。该函数有两个参数，第一个参数为必选项，它接受一个数组作为输入数组，从这个数组中随机选出一个或多个元素。第二个参数是一个可选的参数，指明了你想取出多少个元素，如果没有指定，默认从数组中取出一个元素。如果只取出一个，array_rand()函数返回一个随机元素的键名，否则就返回一个包含随机键名的数组。这样就可以随机从数组中取出键名和值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;, &quot;b&quot;=&gt;&quot;Apache&quot;, &quot;c&quot;=&gt;&quot;MySQL&quot;, &quot;d&quot;=&gt;&quot;PHP&quot;);</div><div class="line">	echo array_rand($lamp,1);           	     //随机从数组$lamp中取1个元素的键值，例如b</div><div class="line">	echo $lamp[array_rand($lamp)].&quot;&lt;br&gt;&quot;; 	     //通过随机的一个元素的键值获取数组中一个元素的值</div><div class="line">	$key=array_rand($lamp,2);           	     //随机从数组$lamp中取2个元素的键值赋给数组$key</div><div class="line">	echo $lamp[$key[0]].&quot;&lt;br&gt;&quot;;         	     //通过数组$key中第一个值获取数组$lamp中一个元素的值</div><div class="line">	echo $lamp[$key[1]].&quot;&lt;br&gt;&quot;;          	     //通过数组$key中第二个值获取数组$lamp中另个元素的值</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数shuffle"><a href="#函数shuffle" class="headerlink" title="函数shuffle()"></a>函数shuffle()</h4><p>shuffle()函数把数组中的元素按随机顺序重新排列，即将数组中的顺序打乱。若成功则返回TRUE，否则返回FALSE。只需要一个数组作为参数，每执行一次则返回不同顺序的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp=array(&quot;a&quot;=&gt;&quot;Linux&quot;, &quot;b&quot;=&gt;&quot;Apache&quot;, &quot;c&quot;=&gt;&quot;MySQL&quot;, &quot;d&quot;=&gt;&quot;PHP&quot;);</div><div class="line">	shuffle($lamp);     //将传入的数组$lamp按随机顺序重新排列</div><div class="line">	print_r($lamp);     //每执行一次shuffle()函数则返回不同顺序的数组</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数array-sum"><a href="#函数array-sum" class="headerlink" title="函数array_sum()"></a>函数array_sum()</h4><p>array_sum()函数返回数组中所有值的总和。只需要换入一个数组作为必选参数即可。如果所有值都是整数，则返回一个整数值，如果其中有一个或多个值是浮点数，则返回浮点数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$a=array(0=&gt;&quot;5&quot;,1=&gt;&quot;15&quot;,2=&gt;&quot;25&quot;);</div><div class="line">	echo array_sum($a);               //使用array_sum()函数返回数组中元素的总各，输出：45</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数range"><a href="#函数range" class="headerlink" title="函数range()"></a>函数range()</h4><p>range()函数创建并返回一个包含指定范围的元素的数组。该函数需要三个参数，第一个参数first为必选项，规定数组元素的最小值。第二个参数second也是必选项，规定数组中元素的最大值。第三个参数step是可选的，规定元素之间的步进制，默认为1。该函数创建一个数组，包含从first到second（包含）之间的整数或字符。如果second比first小，则返回反序的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$number = range(0,5);  	   //使用range()函数声明元素值为0-5的数组</div><div class="line">	print_r ($number);         //获得的数组输出Array ( [0] =&gt; 0 [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 ) </div><div class="line"></div><div class="line">	$number = range(0,50,10);  //使用range()函数声明元素值为0-50的数组，每个元素之间的步长为10</div><div class="line">	print_r ($number);         //输出Array ( [0] =&gt; 0 [1] =&gt; 10 [2] =&gt; 20 [3] =&gt; 30 [4] =&gt; 40 [5] =&gt; 50 ) </div><div class="line"></div><div class="line">	$letter = range(&quot;a&quot;,&quot;d&quot;);  //还可以使用range()函数声明元素连续的字母数组，声明字母a-d的数组</div><div class="line">	print_r ($letter);         //获得的数组输出Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d ) </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="PHP面向对象的程序设计"><a href="#PHP面向对象的程序设计" class="headerlink" title="PHP面向对象的程序设计"></a>PHP面向对象的程序设计</h1><h2 id="如何抽象一个类"><a href="#如何抽象一个类" class="headerlink" title="如何抽象一个类"></a>如何抽象一个类</h2><h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>使用一个关键词class后面加上一个自定义的类别名称，以及加上一对花括号就可以了。有时也需要在class关键字的前面加一些修饰类的关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[一些修饰类的关键字]class 类名｛				//使用class关键字加空格再加上类名，后面加上一对花括号</div><div class="line">		类中成员;				//类中的成员可以成员属性和成员方法</div><div class="line">｝							//使用花括号结束类的声明</div></pre></td></tr></table></figure>
<p>类名和变量名还有函数名命名规则相似，都需要遵守PHP中自定义名称的命名规则，如果由多个单词组成，习惯上每个单词的首字母要大写。另外类名的定义也要具有一定的意义，不要随便由几个字母组成。</p>
<h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><p>在类中直接声明变量就称为成员属性，可以在类中声明多个变量，即对象中有多个成员属性，每个变量都存储对象不同的属性信息。成员属性可以使用PHP中的标量类型和复合类型，所以也可以是其他类实例化的对象，但在类中使用资源和空类型没有意义。另外，虽然在声明成员属性时可以给变量赋予初值，但是在声明类时没有必要的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">	var $name;			//第一个成员属性，用于存储人的名字</div><div class="line">	var $age;			//第二个成员属性，用于存储人的年龄</div><div class="line">	var $sex;			//第三个成员属性，用于存储人的性别</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在成员属性前可以加public,private,static等关键字来修饰，一旦成员属性有其他的关键字修饰就需要去掉”var”。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>在对象中需要声明一些可以操作本对象成员属性的一些方法，来完成对象的一些行为。在类中直接声明的函数就称为成员方法，可以在类中声明多个函数，即对象中就有多个成员方法。成员方法的声明和函数的声明完全一样，只不过可以加上一些关键字的修饰来控制成员方法的一些权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Phone &#123;                      //声明电话类</div><div class="line">        	//声明4个与电话有关的成员属性</div><div class="line">		var $Manufacturers;        //第一个成员属性，用于存储电话的厂商</div><div class="line">		var $color;                //第二个成员属性，用来设置电话的外关颜色</div><div class="line">		var $Battery_capacity;     //第三个成员属性，用来定义电话的电池容量</div><div class="line">		var $screen_size;          //第四个成员属性，用来定义电话的屏幕尺寸</div><div class="line"></div><div class="line">		function call()&#123;          //第一个成员方法用来声明电话具有接打电话的功能</div><div class="line">		    	//方法体，可以是打电话的具体内容</div><div class="line">               		echo &quot;正在打电话&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function message()&#123;       //第二个成员方法用来声明电话具有发信息的功能</div><div class="line">		        //方法体，可以是发送的具体信息</div><div class="line">               		echo &quot;正在发信息&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function playMusic() &#123;    //第三个成员方法用来声明电话具有播放音乐的功能</div><div class="line">		    	//方法体，可以是播放的具体音乐</div><div class="line">             		echo &quot;正在播放音乐&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function photo() &#123;         //第四个成员方法用来声明电话具有拍照的功能</div><div class="line">		     	//方法体，可以是拍照的整个过程</div><div class="line">               		echo &quot;正在拍照&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="通过类实例化对象"><a href="#通过类实例化对象" class="headerlink" title="通过类实例化对象"></a>通过类实例化对象</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>将类实例化成对象使用new关键字并在后面加上一个和类名同名的方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$变量名=new 类名称([参数数列表])；   //对象实例化格式</div></pre></td></tr></table></figure></p>
<p>其中，“$变量名”是通过类所创建的一个对象的引用名称，将来通过这个引用来访问对象中的成员。new表明要创建一个新的对象，类名表示新对象的类型，而参数指定了类的构造方法用于初始化对象值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Phone &#123;             //声明一个电话类Phone</div><div class="line">		//类中成员同上（略）</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class Person &#123;            //声明一个人类Person</div><div class="line">		//类中成员同上（略）</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//通过Person类实例化三个对象$person1、$person2、$person3</div><div class="line">	$person1=new Person();    //创建第一个Person类对象,引用名为$person1</div><div class="line">	$person2=new Person();    //创建第二个Person类对象,引用名为$person2</div><div class="line">	$person3=new Person();    //创建第三个Person类对象,引用名为$person3</div><div class="line"></div><div class="line">	//通过Phone类实例化三个对象$phone1、$phone2、$phone3</div><div class="line">	$phone1=new Phone();    //创建第一个Phone类对象,引用名为$phone1</div><div class="line">	$phone2=new Phone();    //创建第二个Phone类对象,引用名为$phone2</div><div class="line">	$phone3=new Phone();    //创建第三个Phone类对象,引用名为$phone3</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="对象类型在内存中的分配"><a href="#对象类型在内存中的分配" class="headerlink" title="对象类型在内存中的分配"></a>对象类型在内存中的分配</h3><p>对象类型和整型、字符串等类型一样，也是PHP中的一种数据类型。逻辑上内存大体上被分为四段，分别为栈空间段、堆空间段、初始化数据段和代码段，程序中不同类型数据的声明将会被存放在不同的内存段里面。</p>
<h4 id="栈空间段"><a href="#栈空间段" class="headerlink" title="栈空间段"></a>栈空间段</h4><p>栈的特点是空间小但被CPU访问的速度快，是用户存放程序中临时创建的变量。由于栈的后进先出特点，所以栈特别方便用来保存和恢复调用现场。</p>
<h4 id="堆空间段"><a href="#堆空间段" class="headerlink" title="堆空间段"></a>堆空间段</h4><p>堆是用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或所建。用于存储数据长度可变或占用内存比较大的数据。</p>
<h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>数据段用来存放可执行文件中已初始化全局变量，就是存放程序静态分配的变量。</p>
<h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>代码段是用来存放可执行文件的操作指令，也就是说它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准读取操作，不允许写入操作。</p>
<h3 id="对象中成员的访问"><a href="#对象中成员的访问" class="headerlink" title="对象中成员的访问"></a>对象中成员的访问</h3><p>对象中包含成员属性和成员方法，访问对象中的成员则包括成员属性的访问和成员方法的访问。而对成员属性的访问则又包括赋值操作和获取成员属性值的操作。访问对象中的成员和访问数组中的元素类似，只能通过对象的引用来访问对象中的每个成员。但还要使用一个特殊的运算符号“-&gt;”来完成对象成员的访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$引用名=new 类名称([参数数列表]);	//对象实例化格式</div><div class="line">$引用名-&gt;成员属性=值;				//对象成员属性赋值的操作</div><div class="line">echo $引用名-&gt;成员属性;				//获取成员属性的值</div><div class="line">$引用名-&gt;成员方法;				//访问对象中的成员方法</div></pre></td></tr></table></figure></p>
<p>只要是对象中的成员都要使用“对象引用名-&gt;属性”或“对象引用名-&gt;方法”形式访问。如果对象中的成员不是静态的，这是唯一的访问形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person           //声明一个人类Person，其中包含三个成员属性和两个成员方法</div><div class="line">	&#123;</div><div class="line">		//下面是声明人的三个成员属性</div><div class="line">		var $name;       //第一个成员属性$name定义人的名子</div><div class="line">		var $sex;        //第二个成员性性$sex定义人的性别</div><div class="line">		var $age;        //第三个成员性成定义人的年龄</div><div class="line"></div><div class="line">		//下面是声明人的两个成员方法</div><div class="line">		function say()    //这个人可以说话的方法</div><div class="line">		&#123;</div><div class="line">			echo &quot;这个人在说话&lt;br&gt;&quot;;   //在方法体中可以有更多内容</div><div class="line">		&#125;		</div><div class="line"></div><div class="line">		function run()     //这个人可以走路的方法</div><div class="line">		&#123;</div><div class="line">			echo &quot;这个人在走路&lt;br&gt;&quot;;   //在方法体中可以有更多内容</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//下面三行通过new关键字实例化person类的三个实例对象</div><div class="line">	$person1=new Person();  //通过类Person创建第一个实例对象$person1</div><div class="line">	$person2=new Person();  //通过类person创建第二个实例对象$person2</div><div class="line">	$person3=new Person();  //通过类person创建第三个实例对象$person3</div><div class="line"></div><div class="line">	//下面三行是给$person1对象中属性初使化赋值</div><div class="line">	$person1-&gt;name=&quot;张三&quot;;     //将对象person1中的$name属性赋值为张三 </div><div class="line">	$person1-&gt;sex=&quot;男&quot;;        //将对象person1中的$sex属性赋值为男</div><div class="line">	$person1-&gt;age=20;          //将对象person1中的$age属性赋值为20</div><div class="line"></div><div class="line">	//下面三行是给$person2对象中属性初使化赋值</div><div class="line">	$person2-&gt;name=&quot;李四&quot;;     //将对象person2中的$name属性赋值为李四</div><div class="line">	$person2-&gt;sex=&quot;女&quot;;        //将对象person2中的$sex属性赋值为女</div><div class="line">	$person2-&gt;age=30;          //将对象person2中的$age属性赋值为30</div><div class="line"></div><div class="line">	//下面三行是给$person3对象中属性初使化赋值</div><div class="line">	$person3-&gt;name=&quot;王五&quot;;     //将对象person3中的$name属性赋值为王五</div><div class="line">	$person3-&gt;sex=&quot;男&quot;;        //将对象person3中的$sex属性赋值为男</div><div class="line">	$person3-&gt;age=40;          //将对象person3中的$age属性赋值为40</div><div class="line">	</div><div class="line">	//下面三行是访问$person1对象中的成员属性</div><div class="line">	echo &quot;person1对象的名子是：&quot;.$person1-&gt;name.&quot;&lt;br&gt;&quot;;  //输出对象$person1中的成员属性$name的值</div><div class="line">	echo &quot;person1对象的性别是：&quot;.$person1-&gt;sex.&quot;&lt;br&gt;&quot;;    //输出对象$person1中的成员属性$sex的值</div><div class="line">	echo &quot;person1对象的年龄是：&quot;.$person1-&gt;age.&quot;&lt;br&gt;&quot;;    //输出对象$person1中的成员属性$age的值</div><div class="line"></div><div class="line">	//下面两行访问$person1对象中的方法</div><div class="line">	$person1-&gt;say();          //访问第一个对象$person1中的成员方法say(),让第一个人说话</div><div class="line">	$person1-&gt;run();          //访问第一个对象$person1中的成员方法run(),让第一个人走路</div><div class="line"></div><div class="line">	//下面三行是访问$person2对象中的成员属性</div><div class="line">	echo &quot;person2对象的名子是：&quot;.$person2-&gt;name.&quot;&lt;br&gt;&quot;;  //输出对象$person2中的成员属性$name的值</div><div class="line">	echo &quot;person2对象的性别是：&quot;.$person2-&gt;sex.&quot;&lt;br&gt;&quot;;    //输出对象$person2中的成员属性$sex的值</div><div class="line">	echo &quot;person2对象的年龄是：&quot;.$person2-&gt;age.&quot;&lt;br&gt;&quot;;    //输出对象$person2中的成员属性$age的值</div><div class="line"></div><div class="line">	//下面两行访问$person2对象中的方法</div><div class="line">	$person2-&gt;say();          //访问第二个对象$person2中的成员方法say(),让第二个人说话</div><div class="line">	$person2-&gt;run();          //访问第二个对象$person2中的成员方法run(),让第二个人走路</div><div class="line"></div><div class="line">	//下面三行是访问$person3对象中的成员属性</div><div class="line">	echo &quot;person3对象的名子是：&quot;.$person3-&gt;name.&quot;&lt;br&gt;&quot;;  //输出对象$person3中的成员属性$name的值</div><div class="line">	echo &quot;person3对象的性别是：&quot;.$person3-&gt;sex.&quot;&lt;br&gt;&quot;;    //输出对象$person3中的成员属性$sex的值</div><div class="line">	echo &quot;person3对象的年龄是：&quot;.$person3-&gt;age.&quot;&lt;br&gt;&quot;;    //输出对象$person3中的成员属性$age的值</div><div class="line"></div><div class="line">	//下面两行访问$person3对象中的方法</div><div class="line">	$person3-&gt;say();          //访问第三个对象$person3中的成员方法say(),让第三个人说话</div><div class="line">	$person3-&gt;run();          //访问第三个对象$person3中的成员方法run(),让第三个人走路</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="构造方法与析构方法"><a href="#构造方法与析构方法" class="headerlink" title="构造方法与析构方法"></a>构造方法与析构方法</h3><p>构造方法是对象创建完成后第一个被对象自动调用的方法，而析构方法是对象在销毁之前最后一个被对象自动调用的方法。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>当创建一个对象时，构造方法就会被自动调用一次，即每次使用关键字new来实例化对象时都会自动调用构造方法，不能主动通过对象的引用调用构造方法。所以通常使用构造方法执行一些有用的初始化任务。<br>在类中声明构造方法和声明其他的成员方法相似，但是构造方法的方法名称必须是以两个下划线开始的“__construct()”，这是PHP5中的变化，在PHP5之前的版本中，构造方法是方法名称必须与类名相同，这种方式在PHP5中仍然可以用。但在PHP5中很少声明和类名同名的构造方法了，这样做的好处是可以使构造函数独立于类名，当类名发生变化时不需要更改相应的构造函数名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function __construct([参数列表])｛		//构造方法名称是以两个下划线开始的__construct()</div><div class="line">	//方法体，通常用来对成员属性进行初始化赋值</div><div class="line">｝</div></pre></td></tr></table></figure>
<p>在PHP中，同一个类中只能声明一个构造方法。原因是构造方法名称是固定的，在PHP中不能声明同名的两个函数，所以也就没有构造方法重载。但可以在声明构造方法时使用默认参数，实现其他面向对象的编程语言中构造方法重载的功能。这样在创建对象时，如果在构造方法中没有传入参数则使用默认参数为成员属性进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;         //声明一个人类Person，其中声明一个构造方法</div><div class="line">		//下面是声明人的成员属性，都是没有初值的，在创建对象时，使用构造方法赋初值</div><div class="line">		var $name;       //第一个成员属性$name定义人的名子</div><div class="line">		var $sex;        //第二个成员属性$sex定义人的性别</div><div class="line">		var $age;        //第三个成员属性$age定义人的年龄</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值，参数中都使用了默认参数</div><div class="line">		function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;</div><div class="line">			$this-&gt;name = $name;  //在创建对象时，使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;     //在创建对象时，使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;     //在创建对象时，使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//下面是声明人的成员方法</div><div class="line">		function say()&#123; //在类中声明说话的方法，使用$this访问自已对象内部的成员属性</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot;， 性别：&quot;.$this-&gt;sex.&quot;， 我的年龄是：&quot;.$this-&gt;age.&quot;。&lt;br&gt;&quot;;</div><div class="line">		&#125;		</div><div class="line"></div><div class="line">		function run()&#123; //在类中声明另一个方法 </div><div class="line">			echo $this-&gt;name.&quot;在走路&lt;br&gt;&quot;;    //使用$this访问本对象中的$name属性</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//下面三行中实例化person类的三个实例对象，并使用构造方法分别为新创建的对象成员属性赋予初值</div><div class="line">	$person1=new Person(&quot;张三&quot;, &quot;男&quot;, 20); //创建对象$person1时会自动执行构造方法，将全部参数传给它</div><div class="line">	$person2=new Person(&quot;李四&quot;, &quot;女&quot;);    //创建对象$person2时会自动执行构造方法，传入前两个参数</div><div class="line">	$person3=new Person(&quot;王五&quot;);         //创建对象$person3时会自动执行构造方法，只传入一个参数</div><div class="line"></div><div class="line">	$person1-&gt;say();     //使用$person1访问它中的say()方法</div><div class="line">	$person2-&gt;say();     //使用$person2访问它中的say()方法</div><div class="line">	$person3-&gt;say();     //使用$person3访问它中的say()方法</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h4><p>PHP将在对象被销毁前自动调用析构方法。析构方法是PHP中新添加的内容，在PHP4中并没有提供。析构方法允许在销毁一个对象之前执行一些特定操作。<br>当堆内存段中的对象失去访问它的引用时，它就不能被访问了，也就称为垃圾对象了。通常对象的引用被赋予其他的值或者是在页面运行结束时，对象都会失去引用。<br>析构方法的声明格式与构造方法相似，在类中声明的析构方法名称也是固定的，也是以两个下划线开头的方法名“__destruct()”，而且析构函数不能带有任何参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function __destruct()		//析构方法名称是以两个下划线开始的__destruct()</div><div class="line">	//方法体，通常用来完成一些在对象销毁前的清理任务</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;             //声明一个人类Person，其中包含三个成员属性和两个成员方法</div><div class="line">		//下面是声明人的成员属性</div><div class="line">		var $name;          //第一个成员属性$name定义人的名子</div><div class="line">		var $sex;            //第二个成员属性$sex定义人的性别</div><div class="line">		var $age;            //第三个成员属性$age定义人的年龄</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值</div><div class="line">		function __construct($name, $sex, $age) &#123;</div><div class="line">			$this-&gt;name = $name;   //在创建对象时，使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;      //在创建对象时，使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;      //在创建对象时，使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//下面是声明人的成员方法</div><div class="line">		function say()&#123;             //在类中声明说话的方法，使用$this访问自已对象内部的成员属性</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot;， 性别：&quot;.$this-&gt;sex.&quot;， 我的年龄是：&quot;.$this-&gt;age.&quot;。&lt;br&gt;&quot;;</div><div class="line">		&#125;		</div><div class="line"></div><div class="line">		function run() &#123;            //在类中声明另一个方法 </div><div class="line">			echo $this-&gt;name.&quot;在走路&lt;br&gt;&quot;;    //使用$this访问本对象中的$name属性</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		function __destruct() &#123;</div><div class="line">			echo &quot;再见&quot;.$this-&gt;name.&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//下面三行通过new关键字实例化person类的三个实例对象</div><div class="line">	$person1=new Person(&quot;张三&quot;, &quot;男&quot;, 20);     //创建对象$person1 </div><div class="line">	$person1=null;              //将第一个对象的引用$person1赋值为其它的值，第一个对象将失去引用</div><div class="line">	$person2=new Person(&quot;李四&quot;, &quot;女&quot;, 30);     //创建对象$person2 </div><div class="line">	$person3=new Person(&quot;王五&quot;, &quot;男&quot;, 40);      //创建对象$person3 </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>封装性就是把对象的成员属性和成员方法结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义：</p>
<ul>
<li>把对象的全部成员属性和全部成员方法结合在一起，形参一个不可分隔的独立单位（即对象）。</li>
<li>信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界，只保留有限的对外接口使之与外部发生联系。</li>
</ul>
<h3 id="设置私有成员"><a href="#设置私有成员" class="headerlink" title="设置私有成员"></a>设置私有成员</h3><p>只要在声明成员属性或成员方法时，使用private关键字修饰就实现了对成员的封装。封装后的成员在对象的外部不能被访问，但在对象内部的成员方法中可以访问到自己对象内部被封装的成员属性和被封装的成员方法。达到了对对象成员保护的目的，只能是对象自己使用，其他人不可以访问自己的私有成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?</div><div class="line">	class Person  &#123;            //声明一个人类Person，其中包含的三个成员属性被封装起来</div><div class="line">		//下面是声明人的成员属性，全都使用了private关键字封装</div><div class="line">		private $name;       //第一个成员属性$name定义人的名子，此属性被封装</div><div class="line">		private $sex;         //第二个成员属性$sex定义人的性别，此属性被封装</div><div class="line">		private $age;         //第三个成员属性$age定义人的年龄，此属性被封装</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值</div><div class="line">	     	function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;</div><div class="line">			$this-&gt;name = $name;    //使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;       //使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;       //使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function run()&#123;              //在类中声明一个走路方法，调用两个内部的私有方法完成</div><div class="line">			echo $this-&gt;name.&quot;在走路时&quot;.$this-&gt;leftLeg().&quot;再&quot;.$this-&gt;rightLeg().&quot;&lt;br&gt;&quot;;	</div><div class="line">		&#125;</div><div class="line">         </div><div class="line">		private function leftLeg() &#123;    //声明一个迈左腿的方法，被封装所以只能在内部使用</div><div class="line">			return &quot;迈左腿&quot;;</div><div class="line">		&#125;</div><div class="line">         </div><div class="line">		private function rightLeg() &#123;   //声明一个迈右腿的方法，被封装所以只能在内部使用</div><div class="line">			return &quot;迈右腿&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	$person1=new Person();         //创建对象$person1 </div><div class="line">	$person1-&gt;run();               //run()的方法没有被封装，所以可以在对象外部使用</div><div class="line">	$person1-&gt;name=&quot;李四&quot;;        //name属性被封装，不能在对象外部给私有属性赋值</div><div class="line">	echo $person1-&gt;age;            //age属性被封装，不能在对象的外部获取私有属性的值</div><div class="line">	$person1-&gt;leftLeg();            //leftLeg()方法被封装，不能在对象外面调用对象中私有的方法</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="私有成员的访问"><a href="#私有成员的访问" class="headerlink" title="私有成员的访问"></a>私有成员的访问</h3><p>对象中的成员属性一旦被private关键字封装成私有以后，就只能在对象内部的成员方法中使用。不能被对象外部直接赋值，也不能在对象外部直接获取私有属性的值。如果不让用户在对象外部设置私有属性的值，但可以获取私有属性的值。或者允许用户对私有属性赋值，但需要限制一些赋值的条件。解决方法就是在对象的内部声明一些操作私有属性的方法，再把这个方法通过public关键字设置为共有的访问权限。如果成员方法没有加任何访问控制修饰，默认就是public的，在任何地方都可以访问。这样，在对象外部就可以通过公有的方法作为访问接口，间接地访问对象内部私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;?</div><div class="line">	class Person  &#123;            //声明一个人类Person，其中包含的三个成员属性被封装起来</div><div class="line">		//下面是声明人的成员属性，全都使用了private关键字封装</div><div class="line">		private $name;       //第一个成员属性$name定义人的名子，此属性被封装</div><div class="line">		private $sex;         //第二个成员属性$sex定义人的性别，此属性被封装</div><div class="line">		private $age;         //第三个成员属性$age定义人的年龄，此属性被封装</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员私有属性赋予初值</div><div class="line">	    	function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;</div><div class="line">			$this-&gt;name = $name;    //使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;       //使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;       //使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		public  function getName() &#123;   //通过这个公有方法可以在对象外部获取私有属性$name的值</div><div class="line">			return $this-&gt;name;      //返回对象的私有属性的值</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		public function setSex($sex) &#123;  //通过这个公有方法在对象外部为私有属性$sex设置值，但限制条件</div><div class="line">			if($sex==&quot;男&quot; || $sex==&quot;女&quot;)   //如果传入合法的值才为私有的属性赋值</div><div class="line">				$this-&gt;sex=$sex;        //条成立则将参数传入的值赋给私有属性</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public function setAge($age) &#123; //通过这个公有方法在对象外部为私有属性$age设置值，但限制条件</div><div class="line">			if($age &gt; 150 || $age &lt;0)      //如果设置不合理的年龄则函数不往下执行</div><div class="line">				return;                //返回空值，退出函数</div><div class="line">			$this-&gt;age=$age;            //执行此语句则重新为私有属性赋值</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public function getAge()&#123;    //通过这个公有方法可以在对象外部获取私有属性$name的值</div><div class="line">			if($this-&gt;age &gt; 30)           //如果年龄的成员属性大于30则返回虚假的年龄</div><div class="line">				return $this-&gt;age-10;     //返回当前的年龄减去10岁</div><div class="line">			else                       //如果年龄在30岁以下则返回真实年龄</div><div class="line">				return $this-&gt;age;       //返回当前的私有年龄属</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//下面是声明人的成员公有方法，说出自己所有的私有属性</div><div class="line">		function say()&#123;   //在类中声明说话的方法，使用$this访问自已对象内部的成员属性</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot;， 性别：&quot;.$this-&gt;sex.&quot;， 我的年龄是：&quot;.$this-&gt;age.&quot;。&lt;br&gt;&quot;;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	$person1=new Person(&quot;王五&quot;, &quot;男&quot;, 40);  //创建对象$person1</div><div class="line">	echo $person1-&gt;getName().&quot;&lt;br&gt;&quot;;      //访问对象中的公有方法，获取对象中私有属性$name输出</div><div class="line">	$person1-&gt;setSex(&quot;女&quot;);               //通过公有的方法为私有属性$sex设置合法的值</div><div class="line">	$person1-&gt;setAge(200);               //通过公有的方法为私有属性$age设置非法的值，赋值失败</div><div class="line">	echo $person1-&gt;getAge().&quot;&lt;br&gt;&quot;;       //访问对象中的公有方法，获取对象中私有属性$age输出</div><div class="line">	$person1-&gt;say();                    //访问对象中的公有方法，获取对象中所有的私有属性并输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="set-、get-、isset-和unset-四种方法"><a href="#set-、get-、isset-和unset-四种方法" class="headerlink" title="set()、get()、isset()和unset()四种方法"></a><strong>set()、</strong>get()、<strong>isset()和</strong>unset()四种方法</h3><p>在PHP5.1.0以后的版本中，预定义了两个方法“get()”和“set()”，用来完成对所有私有属性都能获取和赋值的操作，以及用来检查私有属性是否存在的方法“isset”和用来删除对象中私有属性的方法“unset()”.(以两个下划线开始)</p>
<h4 id="魔术方法-set"><a href="#魔术方法-set" class="headerlink" title="魔术方法__set()"></a>魔术方法__set()</h4><p>类中声明格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void __set(string name,mixed value)     //是以两个下划线开始的方法名，方法体的内容需要自定义</div></pre></td></tr></table></figure></p>
<p>该方法的作用是在程序运行过程中为私有的成员属性设置值，它不需要有任何返回值。但它需要两个参数，第一个参数需要传入在为私有属性设置值时的属性名，第二个参数则需要传入为属性设置的值。而且这个方法不需要我们主动调用，可以在方法前面也加上private关键字修饰，防止用户直接去调用它。这个方法是在用户值为私用属性设置值时自动调用的。如果不在类中添加这个方法而直接为私有属性赋值，则会出现“不能访问某个私有属性”的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person  &#123;            //声明一个人类Person，其中包含的三个成员属性被封装起来</div><div class="line">		//下面是声明人的成员属性，全都使用了private关键字封装</div><div class="line">		private $name;       //第一个成员属性$name定义人的名子，此属性被封装</div><div class="line">		private $sex;         //第二个成员属性$sex定义人的性别，此属性被封装</div><div class="line">		private $age;         //第三个成员属性$age定义人的年龄，此属性被封装</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值</div><div class="line">	    	function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;</div><div class="line">			$this-&gt;name = $name;    //使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;       //使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;       //使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line">		//声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值</div><div class="line">		private function __set($propertyName, $propertyValue) &#123; </div><div class="line">			if($propertyName==&quot;sex&quot;)&#123;        //如果第一个参数是属性名sex则条件成立</div><div class="line">				if(!($propertyValue == &quot;男&quot; || $propertyValue == &quot;女&quot;))  //第二个参数只能是男或女</div><div class="line">					return;                //如果是非法参数返回空，则结束方法执行</div><div class="line">			&#125;	</div><div class="line"></div><div class="line">			if($propertyName==&quot;age&quot;)&#123;        //如果第一个参数是属性名age则条件成立</div><div class="line">				if($propertyValue &gt; 150 || $propertyValue &lt;0)  //第二个参数只能在0到150之间的整数</div><div class="line">					return;                //如果是非法参数返回空，则结束方法执行</div><div class="line">			&#125;</div><div class="line">              //根据参数决定为那个属性被赋值，传入不同的成员属性名，赋上传入的相应的值</div><div class="line">			$this-&gt;$propertyName = $propertyValue; </div><div class="line">		&#125; </div><div class="line">		</div><div class="line">		//下面是声明人类的成员方法,设置为公有的可以在任何地方访问</div><div class="line">		public function say()&#123; //在类中声明说话的方法，将所有的私有属性说出</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot;， 性别：&quot;.$this-&gt;sex.&quot;， 我的年龄是：&quot;.$this-&gt;age.&quot;。&lt;br&gt;&quot;;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$person1=new Person(&quot;张三&quot;, &quot;男&quot;, 20); </div><div class="line">	//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数</div><div class="line">	$person1-&gt;name=&quot;李四&quot;;     //赋值成功</div><div class="line">	//自动调用了__set()函数，将属性名sex传给第一个参数，将属性值”女”传给第二个参数</div><div class="line">	$person1-&gt;sex=&quot;女&quot;;         //赋值成功</div><div class="line">   	//自动调用了__set()函数，将属性名age传给第一个参数，将属性值80传给第二个参数</div><div class="line">	$person1-&gt;age=80;          //赋值成功</div><div class="line">	</div><div class="line">	$person1-&gt;sex=&quot;保密&quot;;       //“保密”是一个非法值，这条语句给私有属性sex赋值失败</div><div class="line">	$person1-&gt;age=800;         //800是一个非法值，这条语句私有属生age赋值失败</div><div class="line"></div><div class="line">	$person1-&gt;say();	           //调用$person1对象中的say()方法，查看一下所有被重新设置的新值</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="魔法方法-get"><a href="#魔法方法-get" class="headerlink" title="魔法方法__get()"></a>魔法方法__get()</h4><p>在类中声明的格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mixed __get(string name)</div></pre></td></tr></table></figure></p>
<p>该方法的作用是在程序运行过程中，通过它可以在对象的外部获取私有成员后苏醒的值。它有一个必选的参数，需要传入在获取私有属性值时的属性名，并返回一个值，是在这个方法处理后的允许对象外部使用的值。而且这个方法也不需要我们主动调用，也可以在方法前面加上private关键字修饰，防止用户直接去调用它。如果不在类中添加这个方法而直接获取私有属性的值，也会出现”不能访问某个私有属性”的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person  &#123;            //声明一个人类Person，其中包含的三个成员属性被封装起来</div><div class="line">		//下面是声明人的成员属性，全都使用了private关键字封装</div><div class="line">		private $name;       //第一个成员属性$name定义人的名子，此属性被封装</div><div class="line">		private $sex;         //第二个成员属性$sex定义人的性别，此属性被封装</div><div class="line">		private $age;         //第三个成员属性$age定义人的年龄，此属性被封装</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值</div><div class="line">	    	function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;     //使用了默认参数</div><div class="line">			$this-&gt;name = $name;    //使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;       //使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;       //使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line">		//在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理</div><div class="line">		private function __get($propertyName)  &#123;    //在方法前使用private修饰，防止对象外部调用 </div><div class="line">			 if($propertyName==&quot;sex&quot;) &#123;          //如果参数传入的是”sex”则条件成立</div><div class="line">				return &quot;保密&quot;;                  //不让别人获取到性别，以“保密”替代</div><div class="line">			 &#125; else  if($propertyName==&quot;age&quot;) &#123;    //如果参数传入的是“age”则条件成立</div><div class="line">				if($this-&gt;age &gt; 30)               //如果对象中的年龄大于30时条件成立</div><div class="line">					return $this-&gt;age-10;	       //返回对象中虚假的年龄，比真实年龄小10岁</div><div class="line">				else                           //如果对象中的年龄不大于30时则执行下面代码</div><div class="line">					return $this-&gt;$propertyName;  //让访问都可以获取到对象中真实的年龄</div><div class="line">			 &#125; else &#123;                            //如果参数传入的是其它属性名则条件成立</div><div class="line">			 	return $this-&gt;$propertyName;      //对其它属性都没有限制，可以直接返回属性的值</div><div class="line">			 &#125; </div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$person1=new Person(&quot;张三&quot;, &quot;男&quot;, 40);   //通过Person类实例化的对象，并通过构造方法为属性赋初值</div><div class="line">	</div><div class="line">	echo &quot;姓名：&quot;.$person1-&gt;name.&quot;&lt;br&gt;&quot;;   //直接访问私有属性name，自动调用了__get()方法可以间接获取</div><div class="line">	echo &quot;性别：&quot;.$person1-&gt;sex.&quot;&lt;br&gt;&quot;;    //自动调用了__get()方法，但在方法中没有返回真实属性值</div><div class="line">	echo &quot;年龄：&quot;.$person1-&gt;age.&quot;&lt;br&gt;&quot;;    //自动调用了__get()方法，根据对象本身的情况会返回不同的值</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="魔法方法isset-和unset"><a href="#魔法方法isset-和unset" class="headerlink" title="魔法方法isset()和unset()"></a>魔法方法<strong>isset()和</strong>unset()</h4><p>isset()函数是用来测定变量是否存在的函数。传入一个变量作为参数，如果传入的变量存在则传回true,否则传回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool __isset(string name)    //传入对象中的成员属性名作为参数，返回测定后的结果</div></pre></td></tr></table></figure>
<p>unset()的作用是删除指定的变量，参数为要删除的变量名称。也可以使用这个函数在对象外部删除对象中的成员属性，但这个对象中的成员属性必须是公有的才可以直接删除。如果对象中的成员属性被封装，就需要在类中添加“unset()”方法，才可以在对象的外部使用“unset()”方法帮助我们间接地将私有的成员属性删除。也可以在“unset()”方法中限制一些条件，删除一些重要的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void __unset(string name)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">?php</div><div class="line">	class Person  &#123;           	 //声明一个人类Person，其中包含的三个成员属性被封装起来</div><div class="line">		//下面是声明人的成员属性，全都使用了private关键字封装</div><div class="line">		private $name;      	 //第一个成员属性$name定义人的名子，此属性被封装</div><div class="line">		private $sex;        	 //第二个成员属性$sex定义人的性别，此属性被封装</div><div class="line">		private $age;         	//第三个成员属性$age定义人的年龄，此属性被封装</div><div class="line"></div><div class="line">		//声明一个构造方法，将来创建对象时，为对象的成员属性赋予初值</div><div class="line">	    	function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;</div><div class="line">			$this-&gt;name = $name;  	  	//使用传入的参数$name为成员属性$this-&gt;name赋初值</div><div class="line">			$this-&gt;sex = $sex;      	 //使用传入的参数$sex为成员属性$this-&gt;sex赋初值</div><div class="line">			$this-&gt;age = $age;      	 //使用传入的参数$age为成员属性$this-&gt;age赋初值</div><div class="line">		&#125;</div><div class="line">	     	//当在对象外面使用isset()测定私用成员属性时，自动调用，并在内部测定扣传给外部的isset()结果</div><div class="line">		private function __isset($propertyName) &#123;   //需要一个参数，是测定的私有属性的名称</div><div class="line">			if($propertyName==&quot;name&quot;)         	//如果参数中传入的属性名等于”name’时条件成立</div><div class="line">				return false;                  //返回假，不充许在对象外部测定这个属性</div><div class="line">			return isset($this-&gt;$propertyName);   //其它的属性都可以被测定，并返回测定的结果</div><div class="line">   		&#125;</div><div class="line">         	//当在对象外面使用unset()方法删除私用属性时，自动被调用，并在内部把私用的成员属性删除</div><div class="line">   		private function __unset($propertyName) &#123;   //需要一个参数，是要删除的私有属性名称</div><div class="line">			if($propertyName==&quot;name&quot;)          //如果参数中传入的属性名等于”name”时条件成立</div><div class="line">				return;                       //退出方法，不充许删除对象中的name属性</div><div class="line">			unset($this-&gt;$propertyName);         //在对象的内部删除在对象外指定的私有属性</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public function say()  //在类中声明说话的方法，将所有的私有属性说出</div><div class="line">		&#123;</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot;， 性别：&quot;.$this-&gt;sex.&quot;， 我的年龄是：&quot;.$this-&gt;age.&quot;。&lt;br&gt;&quot;;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$person1=new Person(&quot;张三&quot;, &quot;男&quot;, 40);   //创建一个对象$person1，将成员属性分别赋上初值</div><div class="line">	</div><div class="line">	var_dump(isset($person1-&gt;name));        //输出bool(false)，不充许测定对象是否存在name属性</div><div class="line">	var_dump(isset($person1-&gt;sex));          //输出bool(true)，使用isset()测定对象中存在sex私有属性</div><div class="line">	var_dump(isset($person1-&gt;age));          //输出bool(true)，使用isset()测定对象中存在age私有属性</div><div class="line">	var_dump(isset($person1-&gt;id));           //输出bool(false)，使用isset()测定对象中不存在id属性</div><div class="line">	</div><div class="line">	unset($person1-&gt;name);                //删除对象中的私有属性name，但在__unset()中不充许删除</div><div class="line">	unset($person1-&gt;sex);                  //删除对象中的私有属性sex，删除成功</div><div class="line">	unset($person1-&gt;age);                  //删除对象中的私有属性age，删除成功</div><div class="line">	</div><div class="line">	$person1-&gt;say();  //对象中的sex和age属性被删除，输出：我的名子叫：张三， 性别：， 我的年龄是：。</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><h3 id="类继承的应用"><a href="#类继承的应用" class="headerlink" title="类继承的应用"></a>类继承的应用</h3><p>使用“extends”关键字实现多个类的单继承关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;           //声明一个人类，定义人所具有的一些其本的属性和功能成员，做为父类 </div><div class="line">		var $name;         //声明一个存储人的名子的成员</div><div class="line">		var $sex;           //声明一个存储人的性别的成员</div><div class="line">		var $age;           //声明一个存储人的年龄的成员</div><div class="line">		</div><div class="line">	    	function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=1) &#123;    //构造方法用来创建对象并初使化成员属性</div><div class="line">			$this-&gt;name = $name;           //为成员属性name在创建对象时赋初值</div><div class="line">			$this-&gt;sex = $sex;              //为成员属性sex在创建对象时赋初值</div><div class="line">			$this-&gt;age = $age;              //为成员属性age在创建对象时赋初值</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function say()&#123;           //在人类在声明一个通用的说话方法，介绍一下自己</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot;， 性别：&quot;.$this-&gt;sex.&quot;， 我的年龄是：&quot;.$this-&gt;age.&quot;。&lt;br&gt;&quot;;</div><div class="line">		&#125;	</div><div class="line">		</div><div class="line">		function run() &#123;          //在人类是声明一个人的通用的走路方法</div><div class="line">			echo $this-&gt;name.&quot;正在走路。&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class Student extends Person &#123;   //声明一个学生类，使用extends关键字扩展（继承）Person类</div><div class="line">		var $school;             //在学生类中声明一个所在学校school的成员属性</div><div class="line">		</div><div class="line">		function study() &#123;        //在学生类中声明一个学生可以学习的方法</div><div class="line">			echo $this-&gt;name.&quot;正在&quot;.$this-&gt;school.&quot;学习&lt;br&gt;&quot;;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class Teacher extends Student &#123;  //再声明一个教师类，使用extends关键字扩展（继承）Student类</div><div class="line">		var $wage;              //在教师类中声明一个教师工资wage的成员属性</div><div class="line">		</div><div class="line">		function teaching() &#123;      //在教师类中声明一个教师可以教学的方法</div><div class="line">			echo $this-&gt;name.&quot;正在&quot;.$this-&gt;school.&quot;教学,每月工资为&quot;.$this-&gt;wage.&quot;。&lt;br&gt;&quot;;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	$teacher1=new Teacher(&quot;张三&quot;, &quot;男&quot;, 40);   //使用继承过来的构造方法创建一个教师对象</div><div class="line">	</div><div class="line">	$teacher1-&gt;school=&quot;edu&quot;;        //将一个教师对象中的所在学校的成员属性school赋值</div><div class="line">	$teacher1-&gt;wage=3000;         //将一个教师对象中的成员属性工资赋值</div><div class="line"></div><div class="line">	$teacher1-&gt;say();              //调用教师对象中的说话方法</div><div class="line">	$teacher1-&gt;study();            //调用教师对象中的学习方法</div><div class="line">	$teacher1-&gt;teaching();          //调用教师对象中的教学方法</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="访问类型控制"><a href="#访问类型控制" class="headerlink" title="访问类型控制"></a>访问类型控制</h3><p>PHP5支持如下三种访问修饰符，包括public、private和protected三种</p>
<h4 id="公有的访问修饰符public"><a href="#公有的访问修饰符public" class="headerlink" title="公有的访问修饰符public"></a>公有的访问修饰符public</h4><p>类中的成员将没有访问限制，所有的外部成员都可以访问这个类中的成员，在PHP 5之前的所有版本中，PHP中类的成员都是public的，而且在PHP5中如果类的成员没有指定成员访问修饰符，将被视为public。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $property			//声明成员属性时，没有使用访问控制的修饰符，默认就是public的成员</div><div class="line">public $property			//使用public修饰符，控制此成员属性为公有的</div><div class="line">function fun()&#123;...&#125;			//声明成员方法时，没有使用访问控制的修饰符，默认就是public的成员</div><div class="line">public function fun()&#123;...&#125;			//使用public修饰符，控制此成员方法为公有的</div></pre></td></tr></table></figure></p>
<h4 id="私有的访问修饰符private"><a href="#私有的访问修饰符private" class="headerlink" title="私有的访问修饰符private"></a>私有的访问修饰符private</h4><p>当类中的成员被定义为private，对于同一类里的所有成员都没有访问限制，但对于该类的外部代码是不允许改变甚至操作的，对于该类的子类，也不能访问private修饰的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class MyClass &#123;                     //声明一个类作为父类使用，将它的成员都声明为私有的</div><div class="line">		private $var1=100;              //声明一个私有的成员属性并给初值为100</div><div class="line"></div><div class="line">		private function printHello() &#123;    //声明一个成员方法使用private关键字设置为私有的</div><div class="line">			echo &quot;hello&lt;br&gt;&quot;;         //在方法中只有一条输出语句作为测试使用</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class MyClass2 extends MyClass &#123;     //声明一个MyClass类的子类试图访问父类中的私有成员</div><div class="line">		function useProperty()          //在类中声明一个公有方法，访问父类中的私有成员</div><div class="line">		&#123;</div><div class="line">			echo &quot;输出从父类继承过来的成员属性值&quot;.$this-&gt;var1.&quot;&lt;br&gt;&quot;;    //访问父类中的私有属性</div><div class="line">			$this-&gt;printHello();                                         //访问父类中的私有方法</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$subObj=new MyClass2();          //初例化出子类对象</div><div class="line">	$subObj-&gt;useProperty();            //调用子类对象中的方法实现对父类私有成员的访问</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="保护的访问修饰符protected"><a href="#保护的访问修饰符protected" class="headerlink" title="保护的访问修饰符protected"></a>保护的访问修饰符protected</h4><p>被修饰为protected的成员，对于该类的子类以及子类都有访问权限，可以进行属性、方法的读及写操作。但不能被该类的外部代码访问，以及该子类的外部代码也不具有访问其属性和方法的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class MyClass &#123;                      //声明一个类作为父类使用，将它的成员都声明为保护的</div><div class="line">		protected $var1=100;             //声明一个保护的成员属性并给初值为100</div><div class="line"></div><div class="line">		protected function printHello() &#123;    //声明一个成员方法使用protected关键字设置为保护的</div><div class="line">			echo &quot;hello&lt;br&gt;&quot;;           //在方法中只有一条输出语句作为测试使用</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class MyClass2 extends MyClass &#123;     //声明一个MyClass类的子类试图访问父类中的保护成员</div><div class="line">		function useProperty()          //在类中声明一个公有方法，访问父类中的保护成员</div><div class="line">		&#123;</div><div class="line">			echo &quot;输出从父类继承过来的成员属性值&quot;.$this-&gt;var1.&quot;&lt;br&gt;&quot;;   //访问父类中受保护的属性</div><div class="line">			$this-&gt;printHello();                                        //访问父类中受保护的方法</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$subObj=new MyClass2();          //初例化出子类对象</div><div class="line">	$subObj-&gt;useProperty();            //调用子类对象中的方法实现对父类保护的成员访问</div><div class="line">     	echo $subObj-&gt;var1;               //试图访问类中受保护的成员，结果出错</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="常见的关键字和魔术方法"><a href="#常见的关键字和魔术方法" class="headerlink" title="常见的关键字和魔术方法"></a>常见的关键字和魔术方法</h2><h3 id="final关键字的应用"><a href="#final关键字的应用" class="headerlink" title="final关键字的应用"></a>final关键字的应用</h3><p>在PHP5中新增加了final关键字，它可以夹在类或类中方法前。但不能使用final标识成员属性，虽然final有常量的意思，但是PHP中定义常量是使用define()函数来完成。<br>final关键字的作用</p>
<ul>
<li>使用final标识的类，不能被继承</li>
<li>在类中使用final标识的成员方法，在子类中不能被覆盖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    class MyClass &#123;                //声明一个类MyClass作为父类，在类中只声明一个成员方法</div><div class="line">		final function fun() &#123;       //声明一个成员方法并使用final标识，则不能在子类中覆盖</div><div class="line">			//方法体中的内容略</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	class MyClass2 extends MyClass &#123; //声明继承MyClass类的子类，在类中声明一个方法去覆盖父类中的方法</div><div class="line">		function fun() &#123;           //在子类中试图去覆盖父类中已被final标识的方法，结果出错</div><div class="line">			//方法体中的内容略</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="static和const关键字的使用"><a href="#static和const关键字的使用" class="headerlink" title="static和const关键字的使用"></a>static和const关键字的使用</h3><h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>使用static关键字可以将类中的成员标识为静态的，即可以用来标识成员属性也可以标识成员方法。</p>
<p>类的静态属性非常类似于函数的全局变量。类中的静态成员是不需要对象而使用类名来直接访问的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">类名::静态成员属性名;			//在类的外部和成员方法中都可以使用这种方法访问静态成员属性</div><div class="line">类名::静态成员方法名();			//在类的外部的成员方法中都可以使用这个方法访问静态成员方法</div></pre></td></tr></table></figure></p>
<p>在类中声明的成员方法中，也可以使用关键字“self”来访问其他静态成员。因为静态成员是属于类的，而不属于任何对象，所以不能用$this来引用，可以使用self关键词。</p>
<p>如果在类的外部访问类中的静态成员，可以使用对象引用和使用类名访问，但通常选择使用类名来访问。如果在类内部的成员方法中访问其他的静态成员，通常使用self的形式去访问，最好不要直接用类名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class MyClass &#123;                 //声明一个MyClass类，用来演示如何使用静态成员</div><div class="line">		static $count;               //在类中声明一个静态成员属性count，用来统计对象被创建的次数</div><div class="line"></div><div class="line">		function __construct() &#123;      //每次创建一个对象就会自动调用一次这个构造方法</div><div class="line">			self::$count++;	       //使用self访问静态成员count，使其自增1</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		static function getCount() &#123;   //声明一个静态方法，在类外面直接使用类名就可以调用</div><div class="line">			return self::$count;     //在方法中使用self访问静态成员并返回</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	MyClass::$count=0;            //在类外面使用类名访问类中的静态成员，为其初使化赋值0</div><div class="line"></div><div class="line">	$myc1=new MyClass();         //通过MyClass类创建第一个对象，在构造方法中将count累加1</div><div class="line">	$myc2=new MyClass();         //通过MyClass类创建第二个对象，在构造方法中又为count累加1</div><div class="line">	$myc3=new MyClass();         //通过MyClass类创建第三个对象，在构造方法中再次为count累加1</div><div class="line">     </div><div class="line">	echo MyClass::getCount();      //在类外面使用类名访问类中的静态成员方法，获取静态属性的值 3</div><div class="line">     	echo $myc3-&gt;getCount();       //通过对象也可以访问类中的静态成员方法，获取静态属性的值 3</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p>使用const关键字将类中的成员属性定义为常量，其访问的方式和静态成员一样，都是通过类名或者在成员方法中使用self关键字访问，也不能用对象来访问。标识为常量的属性是只读的，不能重新赋值，如果在程序中试图改变它的值，则会出现错误。所以在声明常量时一定要给初值，因为没有其他方式后期为常量赋值。注意，使用const是声明的常量名称前不要使用“$”符号，而且常量名称通常都是大写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class MyClass &#123;   //声明一个MyClass类，在类中声明一个常量，和一个成员方法</div><div class="line">		 const CONSTANT = &apos;CONSTANT value&apos;;     //使用const声明一个常量，并直接赋上初使值</div><div class="line"></div><div class="line">   		 function showConstant() &#123;                 //声明一个成员方法并在其内部访问本类中的常量</div><div class="line">       			 echo  self::CONSTANT.&quot;&lt;br&gt;&quot;;   //使用self访问常量，注意常量前不要加“$”</div><div class="line">   		 &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	echo MyClass::CONSTANT . &quot;&lt;br&gt;&quot;;             //在类外部使用类名称访问常量，也不要加”$”</div><div class="line">	$class = new MyClass();                        //通过类MyClass创建一个对象引用$class</div><div class="line">	$class-&gt;showConstant();                        //调用对象中的方法</div><div class="line">	// echo $class::CONSTANT;                     //通过对象名称访问常量是不允许的</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h3><p>在PHP中使用“clone”关键词克隆对象，克隆出一个完全一样的对象，克隆以后，原来和副本两个对象完全独立互不干扰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;    //声明类Person，并在其中声明了三个成员属性，一个构造方法以及一个成员方法</div><div class="line">		private $name;     //第一个私有成员属性$name用于存储人的名子</div><div class="line">		private $sex;       //第二个私有成员属性$sex用于存储人的性别</div><div class="line">		private $age;       //第三个私有成员属性$age用于存储人的age</div><div class="line"></div><div class="line">		function __construct($name=&quot;&quot;, $sex=&quot;&quot;, $age=1) &#123;  //构造方法在对象诞生时为成员属性赋初值</div><div class="line">			$this-&gt;name=$name;</div><div class="line">			$this-&gt;sex=$sex;</div><div class="line">			$this-&gt;age=$age;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function say()  &#123;       //一个成员方法用于打印出自己对象中全部的成员属性值</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$p1=new Person(&quot;张三&quot;, &quot;男&quot;, 20);   //创建一个对象并通过构造方法为对象中所有成员属性赋初值</div><div class="line">	$p2=clone $p1;                   //使用clone关键字克隆（复制）对象，创建一个对象的副本</div><div class="line">    	 // $p3=$p1                       //这不是复制对象，而是为对象多复制出一个访问该对象的引用</div><div class="line">	$p1-&gt;say();                      //调用原对象中的说话方法，打印原对象中的全部属性值</div><div class="line">	$p2-&gt;say();                      //调用副本对象中的说话方法，打印出克隆对象的全部属性值</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>如果需要为克隆后的副本对象在克隆是重新为成员属性赋初值，则可以在类中声明一个魔术方法clone()。该方法是在对象克隆时自动调用的，所以就可以通过此方法为克隆后的副本重新初始化。__clone()方法不需要任何参数，该方法中自动包含$this和$that两个对象的引用，$this是副本对象的引用，而$that则是原本对象的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;    //声明类Person，并在其中声明了三个成员属性，一个构造方法以及一个成员方法</div><div class="line">		private $name;     //第一个私有成员属性$name用于存储人的名子</div><div class="line">		private $sex;       //第二个私有成员属性$sex用于存储人的性别</div><div class="line">		private $age;       //第三个私有成员属性$age用于存储人的age</div><div class="line"></div><div class="line">		function __construct($name=&quot;&quot;, $sex=&quot;&quot;, $age=1) &#123;  //构造方法在对象诞生时为成员属性赋初值</div><div class="line">			$this-&gt;name=$name;</div><div class="line">			$this-&gt;sex=$sex;</div><div class="line">			$this-&gt;age=$age;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function __clone() &#123;     //声明此方法则在对象克隆时自动调用，用来为新对象重新赋值</div><div class="line">			$this-&gt;name=&quot;我是&quot;.$that-&gt;name.&quot;的副本&quot;;  //为副本对象中的name属性重新赋值</div><div class="line">			$this-&gt;age=10;                          //为副本对象中的age属性重新赋值</div><div class="line">		&#125;		</div><div class="line"></div><div class="line">		function say()  &#123;       //一个成员方法用于打印出自己对象中全部的成员属性值</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$p1=new Person(&quot;张三&quot;, &quot;男&quot;, 20);   //创建一个对象并通过构造方法为对象中所有成员属性赋初值</div><div class="line">	$p2=clone $p1;                   //使用clone克隆（复制）对象，并自动调用类中的__clone()方法 </div><div class="line">    	$p1-&gt;say();                      //调用原对象中的说话方法，打印原对象中的全部属性值</div><div class="line">	$p2-&gt;say();                      //调用副本对象中的说话方法，打印出克隆对象的全部属性值</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="类中通用的方法-toString"><a href="#类中通用的方法-toString" class="headerlink" title="类中通用的方法__toString()"></a>类中通用的方法__toString()</h3><p>魔法方法__toString()是快速获取对象的字符串表示的最便捷的方式，是在直接输出对象引用时自动调用的方法。通常在此方法中返回的字符串是使用对象中多个属性值连接而成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class TestClass &#123;                 //声明一个测试类，在类中声明一个成员属性和一个__toString()方法</div><div class="line">   		private $foo;                //在类中声明的一个成员方法</div><div class="line"></div><div class="line">    		function __construct($foo) &#123;  //通过构造方法传值为成员属性赋初值</div><div class="line">        		$this-&gt;foo = $foo;      //为成员属性赋值</div><div class="line">   		&#125;</div><div class="line">  </div><div class="line">		public function __toString() &#123;  //在类中定义一个__toString方法 </div><div class="line">        		return $this-&gt;foo;       //返回一个成员属性$foo的值</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$obj = new TestClass(&apos;Hello&apos;);     //创建一个对象并赋值给对象引用$obj</div><div class="line">	echo $obj;                     //直接输出对象引用则自动调用了对象中的__toString()方法输出Hello</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="通过-call-方法处理错误调用"><a href="#通过-call-方法处理错误调用" class="headerlink" title="通过__call()方法处理错误调用"></a>通过__call()方法处理错误调用</h3><p>在调用对象中不存在的方法时就会出现系统出错，然后程序退出不能继续执行。如果在类中添加一个魔术方法call()，则调用对象中不存在的方法时就会自动调用该方法，并且程序可以继续向下执行。可以通过在call()方法中的设置，提示用户调用的方法及需要的参数列表内容不存在。<strong>call()方法需要两个参数，第一个参数是调用不存在的方法时，接受这个不存在的方法的方法名，并将这个不存在的方法中，使用的参数列表形成数组传给</strong>call()方法中的第二个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class TestClass &#123;                 //声明一个测试类，在类中声明printHello()和__call()方法</div><div class="line">		function printHello() &#123;        //声明一个方法，可以让对象成功能调用</div><div class="line">			echo &quot;Hello&lt;br&gt;&quot;;       //执行时输出一条语句</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function __call($functionName, $args) &#123;     //声明此方法用来处理调用对象中不存在的方法</div><div class="line">			echo &quot;你所调用的函数：&quot;.$functionName.&quot;(参数：&quot;;  //输出调用不存在的方法名</div><div class="line">			print_r($args);                                  //输出调用不存在的方法时的参数列表</div><div class="line">			echo &quot;)不存在！&lt;br&gt;\n&quot;;                         //输出符加的一些提示信息</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$obj=new TestClass();              //通过类TestClass实例化一个对象</div><div class="line">	$obj-&gt;myFun(&quot;one&quot;, 2, &quot;three&quot;);      //调用对象中不存在的方法，则自动调用了对象中的__call()方法</div><div class="line">	$obj-&gt;otherFun(8,9);               //调用对象中不存在的方法，则自动调用了对象中的__call()方法</div><div class="line">	$obj-&gt;printHello();                 //调用对象中存在的方法，可以成功调用</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="对象串行化"><a href="#对象串行化" class="headerlink" title="对象串行化"></a>对象串行化</h3><p>对象通过写出描述自己状态的数值来记录自己，这个过程叫对象的串行化。串行化就是把整个对象转化为二进制字符串，有两种情况我们必须把对象串行化。</p>
<ul>
<li>对象需要在网络中传输时，将对象串行化化成二进制串后在网络中传输。</li>
<li>对象需要持久保存时，将对象串行化后写入文件或是数据库中。<br>使用serialize()函数来串行化一个对象，把对象转化为二进制的字符串。serialize()函数需要一个参数就是对象的引用名，返回值为一个对象被串行化后的字符串。serialize()返回的字符串含义模糊，一般我们不会解析这个串来得到对象的信息。<br>另一个是反串行化后转化的二进制字符串再转化为对象，我们使用unserialize()函数来反串行化一个对象。这个函数的参数即为serialize()函数的返回值，返回值当然是重新组织好的对象。</li>
</ul>
<p>class_Person.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;        //声明一个Person类，包含三个成员属性和一个成员方法</div><div class="line">		private $name;   //人的名子</div><div class="line">		private $sex;     //人的性别</div><div class="line">		private $age;     //人的年龄</div><div class="line">	</div><div class="line">		function __construct($name=&quot;&quot;, $sex=&quot;&quot;, $age=&quot;&quot;) &#123;   //构造方法为成员属性赋初值</div><div class="line">			$this-&gt;name=$name;</div><div class="line">			$this-&gt;sex=$sex;</div><div class="line">			$this-&gt;age=$age;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function say()  &#123;       //这个人可以说话的方法, 说出自己的成员属性</div><div class="line">			echo &quot;我的名字叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>serialize.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	require &quot;class_Person.php&quot;;                	//在本文件中包含Person类所在的脚本文件</div><div class="line">	$person=new Person(&quot;张三&quot;, &quot;男&quot;, 20);      	//能过Person类创建一个对象，对象的引用名为$person</div><div class="line">	$person_string=serialize($person);         	 //通过serialize函数将对象串行化，返一个字符串</div><div class="line">	file_put_contents(&quot;file.txt&quot;, $person_string);	 //将对象串行化后返回的字符串保存到file.txt文件中</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>unserialize.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	require &quot;class_Person.php&quot;;	               //在本文件中包含Person类所在的脚本文件</div><div class="line">	$person_string=file_get_contents(&quot;file.txt&quot;);  //将file.txt文件中的字符串读出来并赋给变量$person_string</div><div class="line">	$person=unserialize($person_string); 	       //进行反串行化操作，形成对象$person。</div><div class="line">	$person-&gt;say();                         	//调用对象中的say()方法，用来测试反串行化对象是否成功</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>在PHP5中还有两个魔术方法sleep()和wakeup()可以使用。在调用serialize()函数将对象串行化时，会自动调用对象中的sleep()方法，用来将对象中的部分成员串行化。在调用unserialize()函数反串行化对象时，则会自动调用对象中的__wakeup()方法，用来在二进制串重新组成一个对象时，为新对象中的成员属性重新初始化。<br>sleep()函数不需要接受任何参数，但需要返回一个数组，在数组中包含需要串行化的属性。未被包含在数组中的属性将在串行化被忽略。如果没有在类中声明sleep()方法，对象中的所有属性都将被串行化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class Person &#123;        //声明一个Person类，包含三个成员属性和一个成员方法</div><div class="line">		private $name;   //人的名子</div><div class="line">		private $sex;     //人的性别</div><div class="line">		private $age;     //人的年龄</div><div class="line">	</div><div class="line">		function __construct($name=&quot;&quot;, $sex=&quot;&quot;, $age=&quot;&quot;) &#123;   //构造方法为成员属性赋初值</div><div class="line">			$this-&gt;name=$name;</div><div class="line">			$this-&gt;sex=$sex;</div><div class="line">			$this-&gt;age=$age;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function say()  &#123;              //这个人可以说话的方法, 说出自己的成员属性</div><div class="line">			echo &quot;我的名子叫：&quot;.$this-&gt;name.&quot; 性别：&quot;.$this-&gt;sex.&quot; 我的年龄是：&quot;.$this-&gt;age.&quot;&lt;br&gt;&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function __sleep() &#123;            //在类中添加此方法，在串行化时自动调用并返回数组</div><div class="line">			$arr=array(&quot;name&quot;, &quot;age&quot;);  //数组中的成员$name和$age将被串行化，成员$sex则被忽略</div><div class="line">			return($arr);              //返回一个数组</div><div class="line">		&#125; </div><div class="line">		</div><div class="line">		function __wakeup() &#123;          //在反串行化对象时自动调用该方法，没有参数也没有返回值</div><div class="line">			 $this-&gt;age = 40;         //在重新组织对象时，为新对象中的$age属性重新赋值</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$person1=new Person(&quot;张三&quot;, &quot;男&quot;, 20);        //通过Person类实例化对象，对象引用名为$person1</div><div class="line">	//把一个对象串行化，返一个字符串，调用了__sleep()方法,忽略没在数组中的属性$sex</div><div class="line">	$person_string=serialize($person1); </div><div class="line">	echo $person_string.&quot;&lt;br&gt;&quot;;                  //输出对象串行化的字符串</div><div class="line"> </div><div class="line">   	 //反串行化对象，并自动调用了__wakup()方法重新为新对象中的$age属性赋值</div><div class="line">	$person2=unserialize($person_string);          //反串行化对象形成对象$p2重新赋值$age为40</div><div class="line">	$person2-&gt;say();                           //调用新对象中say()方法输出的成员中已没有$sex属性了</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><h3 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h3><p>抽象方法就是没有方法体的方法，所谓的没有方法体是指在方法声明时没有花括号以及其中的内容，而是在声明方法时直接在方法后加上分号结束。另外在声明抽象方法时，还要使用关键字abstract来修饰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abstract function fun1()		//不能有花括号，就更不能有方法体中的内容了</div><div class="line">abstract function fun2()		//直接在方法名的括号后面加上分号结束，还要使用abstract修饰</div></pre></td></tr></table></figure></p>
<p>抽象类使用abstract关键字来修饰。在抽象类中可以有不是抽象的成员方法和成员属性，但访问权限不能使用private关键字修饰为私有的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	abstract class Person &#123;             //声明一个抽象类，要使用abstract关键字标识</div><div class="line">		protected $name;             //声明一个存储人的名子的成员</div><div class="line">		protected $country;           //声明一个存储人的国家的成员</div><div class="line">			</div><div class="line">	    	function __construct($name=&quot;&quot;, $country=&quot;china&quot;) &#123;  //构造方法用来创建对象并初使化成员属性</div><div class="line">			$this-&gt;name = $name;                      //为成员属性name在创建对象时赋初值</div><div class="line">			$this-&gt;country = $country;                  //为成员属性country在创建对象时赋初值</div><div class="line">		&#125;</div><div class="line"> </div><div class="line">		abstract function say();   //在抽象类中声明一个没有方法体的抽象方法，使用abstract关键字标识</div><div class="line">	</div><div class="line">		abstract function eat();   //在抽象类中声明另一个没有方法体的抽象方法，使用abstract关键字标识</div><div class="line">		</div><div class="line">		function run()&#123;         //在抽象类中可以声明正常的非抽象的方法</div><div class="line">			echo &quot;使用两条腿走路&lt;br&gt;&quot;;                //有方法体，输出一条语句</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>在抽象类中没有被实现的抽象方法，所以抽象类是不能被实例化的，即创建不了对象，也就是不能直接使用它。使用抽象类就包含了继承关系，它是为它的子类定义公共接口，将它的曹交给子类去遵守。当子类继承抽象类以后，就必须把抽象类中的抽象方法按照子类自己的需要去实现。子类必须把父类中的抽象方法全部都实现，否则子类中还存在抽象方法，所以还是抽象类，也不能实例化对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	class ChineseMan extends Person &#123;     //声明一个类去继承抽象类Person</div><div class="line">		function say() &#123;                //将父类中的抽象方法覆盖，按自已的需求去实现</div><div class="line">			echo $this-&gt;name.&quot;是&quot;.$this-&gt;country.&quot;人，讲汉语&lt;br&gt;&quot;;      //实现的内容</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function eat() &#123;                 //将父类中的抽象方法覆盖，按自已的需求去实现</div><div class="line">			echo $this-&gt;name.&quot;使用筷子吃饭&lt;br&gt;&quot;;                    //实现的内容</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class Americans extends Person &#123;      //声明另一个类去继承抽象类Person</div><div class="line">		function say() &#123;                //将父类中的抽象方法覆盖，按自已的需求去实现</div><div class="line">			echo $this-&gt;name.&quot;是&quot;.$this-&gt;country.&quot;人，讲英语&lt;br&gt;&quot;;     //实现的内容</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		function eat() &#123;                //将父类中的抽象方法覆盖，按自已的需求去实现</div><div class="line">			echo $this-&gt;name.&quot;使用刀子和叉子吃饭&lt;br&gt;&quot;;              //实现的内容</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$chineseMan = new ChineseMan(&quot;高洛峰&quot;, &quot;中国&quot;);      //将第一个Person的子类实例化对象</div><div class="line">	$americans =new Americans(&quot;alex&quot;, &quot;美国&quot;);             //将第二个Person的子类实例化对象</div><div class="line"></div><div class="line">	$chineseMan-&gt;say();              //通过第一个对象调用子类中已经实例父类中抽象方法的say()方法</div><div class="line">	$chineseMan-&gt;eat();               //通过第一个对象调用子类中已经实例父类中抽象方法的eat()方法</div><div class="line"></div><div class="line">	$americans-&gt;say();               //通过第二个对象调用子类中已经实例父类中抽象方法的say()方法</div><div class="line">	$americans-&gt;eat();                //通过第二个对象调用子类中已经实例父类中抽象方法的eat()方法</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="接口技术"><a href="#接口技术" class="headerlink" title="接口技术"></a>接口技术</h3><p>接口是一种特殊的抽象类，而抽象类又是一种特殊的类，所以接口也是一种特殊的类。接口中声明的方法必须都是抽象方法，另外不能在接口中声明变量，只能使用const关键字声明为常量的成员属性，而且接口中所有成员都必须有public的访问权限。<br>类的声明是使用“class”关键字标识的，而接口的声明则使用“interface”关键字表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface 接口名称｛			//使用interface关键字声明接口</div><div class="line">	//常量成员				//接口中的成员属性只能是常量，不能是变量</div><div class="line">	//抽象方法				//接口中的所有方法必须是抽象方法，不能有非抽象的方法存在</div><div class="line">｝						//接口中的成员也需要用花括号包含起来</div></pre></td></tr></table></figure></p>
<p>如果需要使用接口中的成员，则需要通过子类去实现接口中的全部抽象方法，然后创建子类的对象去调用在子类中实现后的方法。但通过类去继承接口时需要使用implements关键字来实现，而并不是是哟个extends关键字完成。如果需要使用抽象类去实现接口中的部分方法，也需要使用implements关键字实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	interface One &#123;                              //声明一个接口使用interface关键字，One为接口名称</div><div class="line">		const CONSTANT = &apos;CONSTANT value&apos;;    //在接口中声明一个常量成员属性，和在类中声明一样</div><div class="line">		function fun1();                         //在接口中声明一个抽象方法“fun1()”</div><div class="line">		function fun2();                         //在接口中声明另一个抽象方法“fun2()”</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	abstract class Three implements One &#123;          //声明一个抽象类去实现接口One中的第二个方法</div><div class="line">		function fun2() &#123;                       //只实现接口中的一个抽象方法</div><div class="line">			//具体的实现内容由子类自决定</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	class Four implements One &#123;                 //声明一个类实现接口One中的全部抽象方法</div><div class="line">		function fun1() &#123;                      //实现接口中第一个方法</div><div class="line">			//具体的实现内容由子类自决定</div><div class="line">		&#125;	</div><div class="line"></div><div class="line">		function fun2() &#123;                     //实现接口中的第二个方法</div><div class="line">			//具体的实现内容由子类自决定</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>PHP是单继承的，一个类只能有一个父类，但是一个类可以实现多个接口。将要实现的多个接口之间使用逗号分隔开，而且在子类中要将所有接口中的抽象方法全部实现才可以创建对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class 类名 implements 接口一，接口二...接口n&#123;  //一个类实现多个接口</div><div class="line">			//实现所有接口中的抽象类</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现多个接口是使用“implements”关键字，同时还可以使用“extends”关键字继承一个类。即在继承一个类的同时实现多个接口，但一定要先使用extends继承一类再去使用imlements实现多个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class  类名 extends 父类名 implements 接口一，接口二...接口n&#123;  //继承一个类的同时实现多个接口</div><div class="line">		//实现所有接口中的抽象类</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="字符串处理与正则表达式"><a href="#字符串处理与正则表达式" class="headerlink" title="字符串处理与正则表达式"></a>字符串处理与正则表达式</h1><h2 id="字符串的处理介绍"><a href="#字符串的处理介绍" class="headerlink" title="字符串的处理介绍"></a>字符串的处理介绍</h2><h3 id="字符串的处理方式"><a href="#字符串的处理方式" class="headerlink" title="字符串的处理方式"></a>字符串的处理方式</h3><p>在PHP中，提供了大量的字符串操作函数，功能强大，使用也比较简单。但对一些比较复杂的字符串操作，则需要借助PHP所支持的正则表达式来实现。如果字符串处理函数和正则表达式都可以实现字符串操作，建议使用字符串处理函数来完成，因为字符串的处理函数要比正则表达式处理字符串的效率高。</p>
<h3 id="字符串类型的特点"><a href="#字符串类型的特点" class="headerlink" title="字符串类型的特点"></a>字符串类型的特点</h3><p>因为PHP是弱类型语言，所以其他类型的数据一般都可以直接应用于字符串操作函数里，而自动转化为字符串进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	echo substr(&quot;1234567&quot;,2,4);				//将字符串用于字符串函数substr()处理，输出子字符串345</div><div class="line">	echo substr(123456,2,4);				//将整型用于字符串substr()处理，输出同样是字符串345</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>还可以将字符串视为数组，当做字符集合看待<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str=&quot;lamp&quot;;				//声明一个字符串$str，值为lamp</div><div class="line">	echo $str.&quot;&lt;br&gt;&quot;;			//将字符串看作是一个连续的实体，一起输出lamp</div><div class="line">	//以下将字符串看作字符集合，按数组方式一个一个输出</div><div class="line">	echo $str[0];			//输出字符串$str中第一个字符l</div><div class="line">	echo $str[1];			//输出字符串$str中第一个字符a</div><div class="line">	echo $str[2];			//输出字符串$str中第一个字符m</div><div class="line">	echo $str[3];			//输出字符串$str中第一个字符p</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>但将字符串看做字符集合时，PHP脚本引擎无法区分是字符还是数组，会带来二义性。所以中括号的语法已不再使用，替代它的是使用花括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str=&quot;lamp&quot;;		//声明一个字符串$str，值为lamp</div><div class="line">	echo $str&#123;0&#125;;		//输出字符串$str中第一个字符l</div><div class="line">	echo $str&#123;1&#125;;		//输出字符串$str中第一个字符a</div><div class="line">	echo $str&#123;2&#125;;		//输出字符串$str中第一个字符m</div><div class="line">	echo $str&#123;3&#125;;		//输出字符串$str中第一个字符p</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="常用的字符串输出函数"><a href="#常用的字符串输出函数" class="headerlink" title="常用的字符串输出函数"></a>常用的字符串输出函数</h2><table>
<thead>
<tr>
<th>函数名</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>echo()</td>
<td style="text-align:left">输出字符串</td>
</tr>
<tr>
<td>print()</td>
<td style="text-align:left">输出一个或多个字符串</td>
</tr>
<tr>
<td>die()</td>
<td style="text-align:left">输出一条消息，并退出当前脚本</td>
</tr>
<tr>
<td>printf()</td>
<td style="text-align:left">输出格式化字符串</td>
</tr>
<tr>
<td>sprintf()</td>
<td style="text-align:left">把格式化的字符串写入一个变量中</td>
</tr>
</tbody>
</table>
<h3 id="函数echo"><a href="#函数echo" class="headerlink" title="函数echo()"></a>函数echo()</h3><p>该函数用于输出一个或多个字符串，是在PHP中使用最多的函数，因为使用它的效率要比其他字符串输出函数高。echo()实际上不是一个函数，因此您不需对其使用括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str = &quot;What&apos;s LAMP?&quot;;             //定义一个字符串$str</div><div class="line">	echo $str;                         //可以直接输出字符串变量</div><div class="line">	echo &quot;&lt;br&gt;&quot;;                      //也可以直接输出字符串</div><div class="line">	echo $str.&quot;&lt;br&gt;Linux+Apache+MySQL+PHP&lt;br&gt;&quot;;  //还可以使用点运算符号连接多个字符串输出</div><div class="line"></div><div class="line">	echo &quot;This                    </div><div class="line">	      text </div><div class="line">	      spans </div><div class="line">	      multiple </div><div class="line">	      lines.&lt;br&gt;&quot;;                //可以将一行文本换成多行输出</div><div class="line"></div><div class="line">	echo &apos;This &apos;,&apos;string &apos;,&apos;was &apos;,&apos;made &apos;,&apos;with multiple parameters&lt;br&gt;&apos;;  //可以输出用逗号隔开的多个参数</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="函数print"><a href="#函数print" class="headerlink" title="函数print()"></a>函数print()</h3><p>该函数的功能和echo()的一样，它有返回值，若成功则返回1，失败则返回0。它的执行效率没有echo()函数高。</p>
<h3 id="函数die"><a href="#函数die" class="headerlink" title="函数die()"></a>函数die()</h3><p>该函数是exit()函数的别名。如果参数是一个字符串，则该函数会在退出前输出它。如果参数是一个整数，这个值会被用做退出状态。退出状态的值在0至254之间。退出状态255有PHP保留，不会被使用。状态0用于成功地终止程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$url = &quot;http://www.lampbrother.net&quot;;               //定义一个网络文件的位置</div><div class="line">	fopen($url,&quot;r&quot;)	or die(&quot;Unable to connect to $url&quot;);  //如果打开失败则输出一条消息并退出程序</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="函数printf"><a href="#函数printf" class="headerlink" title="函数printf()"></a>函数printf()</h3><p>该函数用于输出格式化的字符串，和C语言的同名函数用法一样。第一个参数为必选项，是规定的字符串以及如何格式化其中的变量。还可以有多个可选参数，是规定插到第一个参数的格式化字符串中对应%符号处的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf(format,arg1,arg2,...,argn)</div></pre></td></tr></table></figure></p>
<p>第一个参数中使用的转换格式，是以百分比符号（“%”）开始到转换字符结束。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>%%</td>
<td style="text-align:left">返回百分比符号</td>
</tr>
<tr>
<td>%b</td>
<td style="text-align:left">二进制数</td>
</tr>
<tr>
<td>%c</td>
<td style="text-align:left">按照ASCII值的字符</td>
</tr>
<tr>
<td>%d</td>
<td style="text-align:left">带符号十进制数</td>
</tr>
<tr>
<td>%e</td>
<td style="text-align:left">科学计数法</td>
</tr>
<tr>
<td>%u</td>
<td style="text-align:left">无符号十进制数</td>
</tr>
<tr>
<td>%f</td>
<td style="text-align:left">浮点数（local setting aware）</td>
</tr>
<tr>
<td>%F</td>
<td style="text-align:left">浮点数（not local setting aware）</td>
</tr>
<tr>
<td>%o</td>
<td style="text-align:left">八进制数</td>
</tr>
<tr>
<td>%s</td>
<td style="text-align:left">字符串</td>
</tr>
<tr>
<td>%x</td>
<td style="text-align:left">十六进制数（小写字母）</td>
</tr>
<tr>
<td>%X</td>
<td style="text-align:left">十六进制数（大写字母）</td>
</tr>
</tbody>
</table>
<p>arg1,arg2,argn等参数将插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个%符号中，插入arg1，在第二个%符号处，插入arg2，依次类推。如果%符号多于arg参数，则必须使用占位符。占位符被插入%符号之后，由数组和“\$”组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str = &quot;LAMP&quot;;             //声明一个字符串数据</div><div class="line">	$number = 789;             //声明一个整型数据</div><div class="line">     </div><div class="line">	//将字符串$str在第一个参数中的%处输出，按%s的字符串输出，整型$number按%u输出</div><div class="line">	printf(&quot;%s book. page number %u &lt;br&gt;&quot;,$str,$number);       </div><div class="line">	printf(&quot;%0.3f &lt;br&gt;&quot;,$number);  //将整型$number按浮点数输出，并在小数点后保留3位</div><div class="line"></div><div class="line">	$format = &quot;The %2\$s book contains %1\$d pages.</div><div class="line">           That&apos;s a nice %2\$s full of %1\$d pages. &lt;br&gt;&quot;;   //定义一个格式并在其中使用占位符</div><div class="line">	printf($format, $number, $str);  //按格式的占位符号输出多次变量，%2$s位置处是第三个参数</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="函数sprintf"><a href="#函数sprintf" class="headerlink" title="函数sprintf()"></a>函数sprintf()</h3><p>该函数的用法和printf()的格式相似，但它并不是输出字符串，而是把格式化的字符串以返回值的形式写入到一个变量中。这样就可以将格式化后的字符串在需要时使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$num= 12345;              	 //声明一个整数12345</div><div class="line">	$txt = sprintf(&quot;%0.2f&quot;,$num);    //转换为保留两位小数的浮点数，并赋值给变量$text</div><div class="line">	echo $txt;                  	 //在需要的地方就可以使用格式化后的文本$txt</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="常用的字符串格式化函数"><a href="#常用的字符串格式化函数" class="headerlink" title="常用的字符串格式化函数"></a>常用的字符串格式化函数</h2><table>
<thead>
<tr>
<th>格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ltrim()</td>
<td style="text-align:left">从字符串左侧删除空格或者其他预定义字符</td>
</tr>
<tr>
<td>rtrim()</td>
<td style="text-align:left">从字符串的末端开始删除空白字符或其他预定义字符</td>
</tr>
<tr>
<td>trim()</td>
<td style="text-align:left">从字符串的两端删除空白字符和其他预定义字符</td>
</tr>
<tr>
<td>str_pad()</td>
<td style="text-align:left">把字符串填充为新的长度</td>
</tr>
<tr>
<td>strtolower()</td>
<td style="text-align:left">把字符串转换为小写</td>
</tr>
<tr>
<td>strtoupper()</td>
<td style="text-align:left">把字符串转化为大写</td>
</tr>
<tr>
<td>ucfirst()</td>
<td style="text-align:left">把字符串中的首字符转换为大写</td>
</tr>
<tr>
<td>ucwords()</td>
<td style="text-align:left">把字符串中每个单词的首字符转换为大写</td>
</tr>
<tr>
<td>nl2br()</td>
<td style="text-align:left">在字符串中的每行之间插入HTML换行符</td>
</tr>
<tr>
<td>htmlentities()</td>
<td style="text-align:left">把字符转化为HTML实体</td>
</tr>
<tr>
<td>htmlspecialchears()</td>
<td style="text-align:left">把一些预定义的字符转换为HTML实体</td>
</tr>
<tr>
<td>Stripslashes()</td>
<td style="text-align:left">删除由addcslashes()函数添加的反斜杠</td>
</tr>
<tr>
<td>strip_tags()</td>
<td style="text-align:left">剥去HTML、XML以及PHP的标签</td>
</tr>
<tr>
<td>number_format()</td>
<td style="text-align:left">通过千位分组来格式化数字</td>
</tr>
<tr>
<td>strrev()</td>
<td style="text-align:left">反转字符串</td>
</tr>
<tr>
<td>md5()</td>
<td style="text-align:left">将一个字符串进行MD5计算</td>
</tr>
</tbody>
</table>
<h3 id="取出空格和字符串填补函数"><a href="#取出空格和字符串填补函数" class="headerlink" title="取出空格和字符串填补函数"></a>取出空格和字符串填补函数</h3><p>在PHP中可以通过ltrim()、rtrim()和trim()函数利用处理字符串中多余的空格，或者一些其他没有意义的符号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string ltrim(string str[,string charlist])		//从字符串左侧删除空格或者其他预定义字符</div><div class="line">string rtrim(string str[,string charlist])		//从字符串右侧删除空白字符或其他预定义字符</div><div class="line">string trim(string str[,string charlist])		//从字符串的两端删除空白字符和其他预定义字符</div></pre></td></tr></table></figure></p>
<p>这三个函数分别用于从字符串的左、右和两端删除空白字符或其他预定义字符。处理后的结果都会以新字符串的形式返回，不会在原字符串上修改。其中第一个参数str是待处理的字符串，为必选项。第二个参数charlist是过滤字符串，用于指定希望去除的特殊符号，该参数为可选。如果不指定过滤字符串，默认情况下会去掉下列字符：</p>
<ul>
<li>“ ”：ASCII为32的字符（0x20），即空格</li>
<li>“\0”：ASCII为0的字符（0x00），即NULL</li>
<li>“\t”：ASCII为9的字符（0x99），即制表符</li>
<li>“\n”：ASCII为10的字符（0x0A），即新行</li>
<li>“\r”：ASCII为13的字符（0x0D），即回车</li>
</ul>
<p>此外还可以使用“..”符号指定需要取出的一个范围，例如“0..9”或“a..z”表示去掉ASCII码值中的数字和小写字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str=&quot;   lamp  &quot;;  //声明一个字符串，其中左侧有3个空格，右侧2个空格，总长度为9个字符</div><div class="line">	echo strlen($str);            //输出字符串的总长度 9</div><div class="line">	echo strlen(ltrim($str));       //去掉左侧空格后的长度输出为 6</div><div class="line">	echo strlen(rtrim($str));       //去掉右侧空格后的长度输出为 7</div><div class="line">	echo strlen(trim($str));        //去掉两侧空格后的长度输出为 4</div><div class="line"></div><div class="line">	$str=&quot;123 This is a test ...&quot;;    //声明一个测试字符串，左侧为数字开头，右侧为省略号“…”</div><div class="line">	echo ltrim($str, &quot;0..9&quot;);       //过滤掉字符串左侧的数字，输出：This is a test ...</div><div class="line">	echo rtrim($str, &quot;.&quot;);         //过滤掉字符串右侧的所有“.”，输出：123 This is a test</div><div class="line">	echo trim($str, &quot;0..9 A..Z .&quot;);  //过滤掉字符串两端的数字和大写字母还有“.”，输出：his is a test</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>不仅可以按需求过滤字符串中的内容，还可以使用str_pad()函数按需求对字符串进行填补。可以用于对一些敏感信息的保护。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string str_pad(string input,int pad_length[,string pad_string[,int pad_type]])</div></pre></td></tr></table></figure></p>
<p>该函数有四个参数，第一个参数是必选项，指明要处理的字符串。第二个参数也是必选项，给丁处理后字符串的长度，如果该值小于原始字符串的长度，则不进行任何操作。第三个参数指定填补时所用的字符串，它为可选参数。如果没有指定则默认使用空格填补。最后一个参数指定填补的方向，它有三个可选值：STR_PAD_BOTH、STR_PAD_LEFT和STR_PAD_RIGHT，分别代表在字符串两端、左和右进行填补。也是一个可选参数，如果没有指定则默认值是STR_PAD_RIGHT。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str= &quot;LAMP&quot;;                           </div><div class="line">	echo str_pad($str, 10);        //指定长度为10，默认使用空格在右边填补&quot;LAMP      &quot;</div><div class="line">	echo str_pad($str, 10, &quot;-=&quot;, STR_PAD_LEFT);  //指定长度为10，指定在左边填补&quot; -=-=-=LAMP&quot;</div><div class="line">	echo str_pad($str, 10, &quot;_&quot;, STR_PAD_BOTH);  //指定长度为10，指定两端填补 &quot; ___LAMP___&quot;</div><div class="line">	echo str_pad($str, 6 , &quot;___&quot;);                //指定长度为6， 默认在右边填补&quot; LAMP__&quot;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><p>在PHP中提供了四个字符串大小写的转换函数，它们都只有一个可选参数，即传入要进行转换的字符串。利用直接使用这些函数完成大小写转换的操作。函数strtoupper()用于将给定的字符串全部转换为大写字母；函数strtolower()用于将给定的字符串全部转换为小写字母；函数ucfirst()用于将给定的字符串中首字母转换为大写，其余字符不变；函数ucwords()用于将给定的字符串中全部以空格分隔的单词首字母转换为大写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$lamp= &quot;lamp is composed of Linux、Apache、MySQL and PHP&quot;;</div><div class="line">	echo strtolower($lamp);  //输出lamp is composed of linux、apache、mysql and php </div><div class="line">	echo strtoupper($lamp);  //输出LAMP IS COMPOSED OF LINUX、APACHE、MYSQL AND PHP </div><div class="line">	echo ucfirst($lamp);     //输出Lamp is composed of Linux、Apache、MySQL and PHP</div><div class="line">	echo ucwords($lamp);   //输出Lamp Is Composed Of Linux、Apache、MySQL And PHP </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="和HTML标签相关的字符串格式化"><a href="#和HTML标签相关的字符串格式化" class="headerlink" title="和HTML标签相关的字符串格式化"></a>和HTML标签相关的字符串格式化</h3><h4 id="函数nl2br"><a href="#函数nl2br" class="headerlink" title="函数nl2br()"></a>函数nl2br()</h4><p>nl2br()函数是在字符串中的每个新行“\n”之前插入HTML换行符“<br>”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	echo nl2br(&quot;One line.\nAnother line.&quot;);        //在“\n”前加上“&lt;br /&gt;”标记</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="函数htmlspecialchars"><a href="#函数htmlspecialchars" class="headerlink" title="函数htmlspecialchars()"></a>函数htmlspecialchars()</h3><p>htmlspecialchars()函数可以将一些预定义的字符转换为HTML实体。此函数用在预防使用者提供的文字中包含了HTML的标记。<br>以下是该函数可以转化的字符</p>
<ul>
<li>“&amp;”（和号）转换为“&amp;”。</li>
<li>“””（双引号）转换为“&quot;”。</li>
<li>“‘“(单引号)转换为“&#039;”。</li>
<li>“&lt;”（小于）转换为“&lt;”。</li>
<li>“&gt;”（小于）转换为“&gt;”。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string htmlspecialchars(string string[,int quote_style[,string charset]])</div></pre></td></tr></table></figure>
<p>该函数中第一个参数是带有HTML标记待处理的字符串，为必选参数。第二个参数为可选参数，用来决定引号的转换方式。默认值为ENT_COMPAT将只转换双引号，而保留单引号；NET_QUOTES将同时转换这两种引号；而RNT_NOQUOTES将不对引号进行转换。第三个参数也是可选的值，用于指定所处理字符串的字符集，默认的字符集是“ISO8859-1”.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;?php</div><div class="line">			$str = &quot;&lt;B&gt;WebServer:&lt;/B&gt; &amp; &apos;Linux&apos; &amp; &apos;Apache&apos;&quot;; //常有HTML标记和单引号的字符串</div><div class="line">			echo htmlspecialchars($str, ENT_COMPAT);      //转换HTML标记和转换双引号</div><div class="line">			echo &quot;&lt;br&gt;\n&quot;;</div><div class="line">			echo htmlspecialchars($str, ENT_QUOTES);      //转换HTML标记和转换两种引号</div><div class="line">			echo &quot;&lt;br&gt;\n&quot;;</div><div class="line">			echo htmlspecialchars($str, ENT_NOQUOTES);   //转换HTML标记和不对引号转换</div><div class="line">		?&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>在PHP中还提供了htmllentities()函数，可以将所有的非ASCII码字符转换为对应的实体代码。该函数与htmlspecialchars()函数的使用语法格式一致，但该函数可以转义更多的HTML字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$str = &quot;一个 &apos;quote&apos; 是 &lt;b&gt;bold&lt;/b&gt;&quot;;</div><div class="line"></div><div class="line">	// 输出: &amp;Ograve;&amp;raquo;&amp;cedil;&amp;ouml; &apos;quote&apos; &amp;Ecirc;&amp;Ccedil; &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;</div><div class="line">	echo htmlentities($str);</div><div class="line"></div><div class="line">	// 输出: 一个 &amp;#039;quote&amp;#039; 是 &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;</div><div class="line">	echo htmlentities($str, ENT_QUOTES,gb2312);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="其他字符串格式化函数"><a href="#其他字符串格式化函数" class="headerlink" title="其他字符串格式化函数"></a>其他字符串格式化函数</h3><h4 id="函数strrev"><a href="#函数strrev" class="headerlink" title="函数strrev()"></a>函数strrev()</h4><p>该函数的作用是将输入的字符反转，只提供一个要处理的字符串作为参数，返回反转后的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	echo strrev(&quot;you are sb&quot;);		//反转输出：bs era uoy </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数number-format"><a href="#函数number-format" class="headerlink" title="函数number_format()"></a>函数number_format()</h4><p>number_format()函数通过千位分组来格式化数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string number_format(float number[,int decimals[,string dec_point,string thousands_sep]])</div></pre></td></tr></table></figure></p>
<p>该函数返回格式化后的数组，该函数支持一个、两个或四个参数（不是三个）。第一个参数为必选项，提供要被格式化的数字。如果未设置其他参数，则数字会被格式化为不带小数点且以逗号（，）作为分隔符的数字。第二个参数是可选项，规定使用多少个小数位。如果设置了该参数，则使用点号（.）作为小数点来格式化数字。第三个参数也是可选的参数，规定用什么字符串作为小数点。第四个参数也为可选参数，规定用做千位分隔符的字符串。如果设置了该参数，那么所有其他参数都是必需的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$number=123456789;                   //声明一个数字</div><div class="line">	echo number_format($number);           //输出123,456,789千位分隔的字符串</div><div class="line">	echo number_format($number, 2);         //输出123,456,789.00小数点后保留两数小数 </div><div class="line">	echo number_format($number, 2, &quot;,&quot;, &quot;.&quot;);   //输出123.456.789,00 千位使用(,)分隔并保留两位小数</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数md5"><a href="#函数md5" class="headerlink" title="函数md5()"></a>函数md5()</h4><p>md5()函数的作用就是讲一个字符串进行MD5算法加密，默认返回一个32位的十六进制字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string md5(string str[,bool raw_output])		//进行MD5算法加密演算</div></pre></td></tr></table></figure></p>
<p>其中第一个参数标识待处理的字符串，是必选项。第二个参数需要一个布尔型数值，是可选项。默认为FALSE，返回一个32位十六进制字符串。如果设置为TURE，将返回一个16位的二进制数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$password= &quot;lampbrother&quot;;          //定义一个字符串作为密码，加密后保存到数据库中</div><div class="line">	echo md5($password).&quot;&lt;br&gt;&quot;;       //输出MD5加密后的值：5f1ba7d4b4bf96fb8e7ae52fc6297aee</div><div class="line"></div><div class="line">	if (md5($password) == &apos;5f1ba7d4b4bf96fb8e7ae52fc6297aee&apos;) &#123;  //将输入的密码和数据库保存的匹配</div><div class="line">  		echo &quot;密码一致，登录成功&quot;;                         //如果相同则会输出这条信息</div><div class="line">  	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>在PHP中提供了一个对文件进行MD5加密的函数md5_file()，使用的方式和md5()函数相似。</p>
<h2 id="字符串比较函数"><a href="#字符串比较函数" class="headerlink" title="字符串比较函数"></a>字符串比较函数</h2><h3 id="按字节顺序进行字符串比较"><a href="#按字节顺序进行字符串比较" class="headerlink" title="按字节顺序进行字符串比较"></a>按字节顺序进行字符串比较</h3><p>按字节顺序进行字符串的比较可以使用strcmp()和strcasecmp()两个函数，其中函数strcasecmp()可以忽略字符串中字母的大小写进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int strcmp(string str1,string str2)			//区分字符串中字母大小写地比较</div><div class="line">int strcasecmp(string str1,string str2)			//忽略字符串字母大小写地比较</div></pre></td></tr></table></figure></p>
<p>这两个函数的用法相似，都需要传入进行比较的两个字符串参数。可以对输入的str1和str2两字符串，按照字节的ASCII值从两个字符串的首字节开始比较，如果相等则进入下一个字节的比较，直至结束比较。返回以下三个值之一：</p>
<ul>
<li>如果str1等于str2则返回0</li>
<li>如果str1大于str2则返回1</li>
<li>如果str1小于str2则返回-1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$userName=&quot;Admin&quot;;                     //声明一个字符串作为用户名</div><div class="line">	$password=&quot;lampBrother&quot;;                 //声明一个字符串作为密码</div><div class="line"></div><div class="line">	if(strcasecmp($userName, &quot;admin&quot;)==0) &#123;    //不区分大小写的比较，如果两个字符串相等返回0</div><div class="line">		echo &quot;用户名存在&quot;;</div><div class="line">	&#125;</div><div class="line">     	//将两个比较的字符串使用相应的函数转成全大写或全小写后，也可以实现不区分大小写的比较</div><div class="line">     	if(strcasecmp(strtolower($userName), strtolower(&quot;admin&quot;))==0) &#123;   </div><div class="line">		echo &quot;用户名存在&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	switch(strcmp($password, &quot;lampbrother&quot;))              //区分字符串中字母的大小写比较</div><div class="line">	&#123;</div><div class="line">		case 0:                                      //两个字符串相等则返回0</div><div class="line">			echo &quot;两个字符串相等&lt;br&gt;&quot;;</div><div class="line">			break;</div><div class="line">		case 1:                                      //第一个字符串大时则返回1</div><div class="line">			echo &quot;第一个字符串大于第二个字符串&lt;br&gt;&quot;;</div><div class="line">			break;</div><div class="line">		case -1:                                      //第一个字符串小时则返回-1</div><div class="line">			echo &quot;第一个字符串小于第二个字符串&lt;br&gt;&quot;;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="按自然排序进行字符串比较"><a href="#按自然排序进行字符串比较" class="headerlink" title="按自然排序进行字符串比较"></a>按自然排序进行字符串比较</h3><p>strnatcmp()函数按自然排序法比较两个字符串，该函数对大小写敏感，其使用格式与strcmp()函数相似。<br>在PHP中也提供了忽略大小写版本的函数strnatcasecmp()，用法和strnatcmp()函数相同。</p>
<h2 id="正则表达式在字符串处理中的应用"><a href="#正则表达式在字符串处理中的应用" class="headerlink" title="正则表达式在字符串处理中的应用"></a>正则表达式在字符串处理中的应用</h2><h2 id="与Perl兼容的正则表达式函数"><a href="#与Perl兼容的正则表达式函数" class="headerlink" title="与Perl兼容的正则表达式函数"></a>与Perl兼容的正则表达式函数</h2><h1 id="PHP常用功能模块"><a href="#PHP常用功能模块" class="headerlink" title="PHP常用功能模块"></a>PHP常用功能模块</h1><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h3 id="UNIX时间戳"><a href="#UNIX时间戳" class="headerlink" title="UNIX时间戳"></a>UNIX时间戳</h3><p>UNIX时间戳是保存日期和时间的一种紧凑简洁的方法，是大多数UNIX系统中保存当前日期和事件的一种方法，也是在大多数计算机语言标识日期和时间的一种标准格式。以32位的整数标识格林威治标准时间，例如整数11230499325表示当前事件的时间戳。UNIX时间戳是从1970年1月1日零点开始起到当前事件所经过的秒数。1970年1月1日零点作为所有日期计算的基础，这个日期通常称为UNIX纪元。</p>
<h4 id="将日期和时间转变成UNIX时间戳"><a href="#将日期和时间转变成UNIX时间戳" class="headerlink" title="将日期和时间转变成UNIX时间戳"></a>将日期和时间转变成UNIX时间戳</h4><p>在PHP中，如果需要将日期和事件转变成UNIX时间戳，可以调用mktime()函数。该函数的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int mktime([int hour[,int minute[,int second[,int month[,int day[,int year]]]]]])</div></pre></td></tr></table></figure></p>
<p>该函数中所有参数都是可选的，如果参数为空，默认将当前时间转变成UNIX时间戳。这样，和直接调用time()函数获取当前的UNIX时间戳功能相同。参数也可以从右向左省略，任何省略的参数会被设置成本地日期和事件的当前值。如果只想转变日期，对具体的时间不在乎，可以将前三个转变事件的参数都设置为0.mktime()函数对于日期运算和验证非常有用，它可以自动校正越界的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	echo date(&quot;M-d-Y&quot;, mktime(0, 0, 0, 12, 36, 2007)).&quot;\n&quot;;  //日期超过31天，计算后输出Jan-05-2008</div><div class="line">	echo date(&quot;M-d-Y&quot;, mktime(0, 0, 0, 14, 1, 2008)).&quot;\n&quot;;   //月份超过12月，计算后输出Feb-01-2009</div><div class="line">	echo date(&quot;M-d-Y&quot;, mktime(0, 0, 0, 1, 1, 2009)).&quot;\n&quot;;    //没有问题的转变，输出结果 Jan-01-2009</div><div class="line">	echo date(&quot;M-d-Y&quot;, mktime(0, 0, 0, 1, 1, 99)).&quot;\n&quot;;      //会将99年转变为1999年， Jan-01-1999</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"> 	$year = 1981;                                 //从表单中接收用户提交的出生日期中的年份</div><div class="line"> 	$month = 11;                                 //从表单中接收用户提交的出生日期中的月份</div><div class="line"> 	$day = 05;                                   //从表单中接收用户提交的出生日期中的天</div><div class="line">	$birthday = mktime (0, 0, 0, $month, $day, $year);   //将出生日期转变为UNIX时间戳</div><div class="line">	$nowdate = time();                            //调用time()函数获取当前时间的UNIX时间戳</div><div class="line">	$ageunix = $nowdate - $birthday;                //两个时间戳相减获取用户年龄的UNIX时间戳</div><div class="line">	$age = floor($ageunix / (60*60*24*365));         //将UNIX时间戳除以一年的秒数获取用户年龄</div><div class="line">	echo &quot;年龄：$age&quot;;                           //输出用户的年龄，根据计算得到结果27</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>在以上脚本中，调用mktime()函数将从用户出生日期转变为UNIX时间戳，再调用time()函数获取当前事件的UNIX时间戳。因为这个日期的格式都是使用整数表示的，所以可以将它们相减。又将计算后获取的UNIX时间戳除以一年的秒数，将UNIX时间戳转变为以年度量的单位。</p>
<h3 id="在PHP中获取日期和时间"><a href="#在PHP中获取日期和时间" class="headerlink" title="在PHP中获取日期和时间"></a>在PHP中获取日期和时间</h3><p>PHP中提供了多种获取事件和日期的函数，除了通过time()函数获取当前的UNIX时间戳外，调用getdate()函数确定当前时间，通过gettimeofday()函数获取某一天中的具体时间。此外，在PHP中还可以通过date_sunrise()和date_sunset()两个函数，获取某地点某天的日出时间和日落时间。</p>
<h3 id="日期和时间格式化输出"><a href="#日期和时间格式化输出" class="headerlink" title="日期和时间格式化输出"></a>日期和时间格式化输出</h3><p>在PHP中可以调用date()函数格式化一个本地事件和日期，该函数的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string date(string format[,int timestamp])   		//格式化一个本地时间和日期</div></pre></td></tr></table></figure></p>
<p>该函数有两个参数，第一个参数是必需的，规定时间戳的转换格式。第二个参数是可选的，需要提供一个UNIX时间戳，如果没有指定这个时间戳，默认值为time()将返回当前的日期和时间。该函数返回一个格式化后表示适当日期的字符串。date()函数的常见调用方式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo date(&quot;Y-m-d H:i:s&quot;);			//输出当前的时间格式：xxxx-xx-xx xx:xx:xx</div></pre></td></tr></table></figure></p>
<h1 id="文件系统处理"><a href="#文件系统处理" class="headerlink" title="文件系统处理"></a>文件系统处理</h1><h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>PHP是以UNIX的文件系统为模型的，因此在Windows系统中我们只能获得“file”、“dir”或者“unknown”三种文件类型。而在UNIX系统中，我们可以获得“block”、“char”、“dir”、“fifo”、“file”、“link”和“unknown”七种类型。</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>block</td>
<td style="text-align:left">块设备文件，如某个磁盘分区、软驱、光驱CD-ROM等</td>
</tr>
<tr>
<td>char</td>
<td style="text-align:left">字符设备是指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等</td>
</tr>
<tr>
<td>dir</td>
<td style="text-align:left">目录类型，目录也是文件的一种</td>
</tr>
<tr>
<td>fifo</td>
<td style="text-align:left">命名管道，常用与将信息从一个进程传递到另一个进程</td>
</tr>
<tr>
<td>file</td>
<td style="text-align:left">普通文件类型，如文本文件或可执行文件等</td>
</tr>
<tr>
<td>link</td>
<td style="text-align:left">符号链接，是指向文件指针的指针，类似Windows中的快捷键</td>
</tr>
<tr>
<td>unkonwn</td>
<td style="text-align:left">未知类型</td>
</tr>
</tbody>
</table>
<p>在PHP中可以使用filetype()函数获取文件的上述类型，该函数接受一个文件名作为参数，如果文件不存在将返回FALSE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	//获取Linux系统下文件类型</div><div class="line">	echo filetype(&apos;/etc/passwd&apos;);      //输出file，/etc/passwd为普通文件</div><div class="line">	echo filetype(&apos;/etc/grub.conf&apos;);    //输出link，/etc/grub.conf为链接文件，链接到/boot/grub/grub.conf</div><div class="line">	echo filetype(&apos;/etc/&apos;);            //输出dir，/etc/为一个目录，即文件夹</div><div class="line">	echo filetype(&apos;/dev/sda1&apos;);        //输出block，/dev/sda1为块设备，它是一个分区</div><div class="line">	echo filetype(&apos;/dev/tty01&apos;);       //输出char，为字符设备，它是一个字符终端</div><div class="line"></div><div class="line">	//获取Windows系统下文件类型</div><div class="line">	echo filetype(&quot;C:\\WINDOWS\\php.ini&quot;);     //输出file，C:\WINDOWS\php.ini为一个普通文件</div><div class="line">	echo filetype(&quot;C:\\WINDOWS&quot;);            //输出dir，C:\WINDOWS为一个文件夹（目录）</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>对于一个已知的文件，还可以使用is_file()函数判断给定的文件名是否为一个正常的文件。和它类似的，使用is_dir()函数判断给定的文件名是否是一个目录，使用is_link()函数判断给定的文件名是否为一个符号链接。</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>PHP中提供用来获取文件的一些常见属性的内置函数。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th style="text-align:left">作用</th>
<th>参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_exists()</td>
<td style="text-align:left">检查文件或目录是否存在</td>
<td>文件名</td>
<td style="text-align:left">文件存在返回TRUE，不存在则返回FALSE</td>
</tr>
<tr>
<td>filesize()</td>
<td style="text-align:left">取得文件大小</td>
<td>文件名</td>
<td style="text-align:left">返回文件大小的字节数，出错返回FALSE</td>
</tr>
<tr>
<td>is_readable()</td>
<td style="text-align:left">判断给定文件名是否可读</td>
<td>文件名</td>
<td style="text-align:left">如果文件存在且可读则返回TRUE</td>
</tr>
<tr>
<td>is_writable()</td>
<td style="text-align:left">判断给定文件名是否可写</td>
<td>文件名</td>
<td style="text-align:left">如果文件存在且可写则返回TRUE</td>
</tr>
<tr>
<td>is_executable()</td>
<td style="text-align:left">判断给定文件名是否可执行</td>
<td>文件名</td>
<td style="text-align:left">如果文件存在且可执行则返回TRUE</td>
</tr>
<tr>
<td>filectime()</td>
<td style="text-align:left">获取文件的创建时间</td>
<td>文件名</td>
<td style="text-align:left">返回UNIX时间戳格式</td>
</tr>
<tr>
<td>filemtime()</td>
<td style="text-align:left">获取文件的修改时间</td>
<td>文件名</td>
<td style="text-align:left">返回UNIX时间戳格式</td>
</tr>
<tr>
<td>fileatime()</td>
<td style="text-align:left">获取文件的访问时间</td>
<td>文件名</td>
<td style="text-align:left">返回UNIX时间戳格式</td>
</tr>
<tr>
<td>stat()</td>
<td style="text-align:left">获取文件大部分属性值</td>
<td>文件名</td>
<td style="text-align:left">返回关于给定文件有用信息的数组</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function getFilePro($fileName) &#123;     //声明一个函数，通过传入一个文件名称获取文件大部分属性</div><div class="line">		if(!file_exists($fileName)) &#123;     //如果提供的文件或目录不存在，则直接退出函数</div><div class="line">			echo &quot;目标文件不存在！！&lt;br&gt;&quot;;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		if(is_file($fileName))          //判断是否是一个普通文件，如果是则条件成立</div><div class="line">			echo $fileName.&quot;是一个文件&lt;br&gt;&quot;;</div><div class="line">		if(is_dir($fileName))          //判断是否是一个目录，如果是则条件成立，输出下面语句</div><div class="line">			echo $fileName.&quot;是一个目录&lt;br&gt;&quot;;</div><div class="line"></div><div class="line">		echo &quot;文件型态：&quot;.getFileType($fileName).&quot;&lt;br&gt;&quot;;       //用定义的函数输出文件型态</div><div class="line">		echo &quot;文件大小：&quot;.getFileSize(filesize($fileName)).&quot;&lt;br&gt;&quot;; //获取文件大小，并自定义转换单位</div><div class="line">		</div><div class="line">		if(is_readable($fileName))     //判断提供的文件是否可以读取内容</div><div class="line">			echo &quot;文件可读&lt;br&gt;&quot;;</div><div class="line">	  	if(is_writable($fileName))     //判断提供的文件是否可以改写</div><div class="line">			echo &quot;文件可写&lt;br&gt;&quot;;</div><div class="line">		if(is_executable($fileName))   //判断提供的文件是否有执行的权限</div><div class="line">			echo &quot;文件可执行&lt;br&gt;&quot;;</div><div class="line"></div><div class="line">	  	echo &quot;文件建立时间: &quot;.date(&quot;Y 年 m 月 j 日&quot;,filectime($fileName)).&quot;&lt;br&gt;&quot;;</div><div class="line">		echo &quot;文件最后更动时间: &quot;.date(&quot;Y 年 m 月 j 日&quot;,filemtime($fileName)).&quot;&lt;br&gt;&quot;;</div><div class="line">		echo &quot;文件最后打开时间: &quot;.date(&quot;Y 年 m 月 j 日&quot;,fileatime($fileName)).&quot;&lt;br&gt;&quot;;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function getFileType($fileName) &#123;    //声明一个函数用来返回文件的类型</div><div class="line">		switch(filetype($fileName))&#123;    //通过filetype()函数返回的文件类型做为选择的条件</div><div class="line">			case &apos;file&apos;:</div><div class="line">				$type.=&quot;普通文件&quot;;		</div><div class="line">				break;			</div><div class="line">			case &apos;dir&apos;:</div><div class="line">				$type.=&quot;目录文件&quot;;		</div><div class="line">				break;			</div><div class="line">			case &apos;block&apos;:</div><div class="line">				$type.=&quot;块设备文件&quot;;		</div><div class="line">				break;			</div><div class="line">			case &apos;char&apos;:</div><div class="line">				$type.=&quot;字符设备文件&quot;;		</div><div class="line">				break;			</div><div class="line">			case &apos;fifo&apos;:</div><div class="line">				$type.=&quot;命名管道文件&quot;;		</div><div class="line">				break;			</div><div class="line">			case &apos;link&apos;:</div><div class="line">				$type.=&quot;符号链接&quot;;		</div><div class="line">				break;			</div><div class="line">			case &apos;unknown&apos;:</div><div class="line">				$type.=&quot;末知类型&quot;;		</div><div class="line">				break;	</div><div class="line">			default:</div><div class="line">				$type.=&quot;没有检测到类型&quot;;		</div><div class="line">		&#125;</div><div class="line">		return $type;        //返回转换后的类型</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function getFileSize($bytes) &#123;        //自定义一个文件大小单位转换函数</div><div class="line">		if ($bytes &gt;= pow(2,40)) &#123;      //如果提供的字节数大于等于2的40次方，则条件成立</div><div class="line">			$return = round($bytes / pow(1024,4), 2);    //将字节大小转换为同等的T大小</div><div class="line">			$suffix = &quot;TB&quot;;                         //单位为TB</div><div class="line">		&#125; elseif ($bytes &gt;= pow(2,30)) &#123;  //如果提供的字节数大于等于2的30次方，则条件成立</div><div class="line">			$return = round($bytes / pow(1024,3), 2);    //将字节大小转换为同等的G大小</div><div class="line">			$suffix = &quot;GB&quot;;                         //单位为GB</div><div class="line">		&#125; elseif ($bytes &gt;= pow(2,20)) &#123;  //如果提供的字节数大于等于2的20次方，则条件成立</div><div class="line">			$return = round($bytes / pow(1024,2), 2);    //将字节大小转换为同等的M大小</div><div class="line">			$suffix = &quot;MB&quot;;                         //单位为MB</div><div class="line">		&#125; elseif ($bytes &gt;= pow(2,10)) &#123;  //如果提供的字节数大于等于2的10次方，则条件成立</div><div class="line">			$return = round($bytes / pow(1024,1), 2);    //将字节大小转换为同等的K大小</div><div class="line">			$suffix = &quot;KB&quot;;                         //单位为KB</div><div class="line">		&#125; else &#123;                     //否则提供的字节数小于2的10次方，则条件成立</div><div class="line">			$return = $bytes;                       //字节大小单位不变</div><div class="line">			$suffix = &quot;Byte&quot;;                       //单位为Byte</div><div class="line">		&#125;</div><div class="line">		return $return .&quot; &quot; . $suffix;                    //返回合适的文件大小和单位</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	getFilePro(&quot;file.php&quot;);  //调用自定义函数，将当前目录下的file.php文件传入，获取属性</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="目录的基本操作"><a href="#目录的基本操作" class="headerlink" title="目录的基本操作"></a>目录的基本操作</h2><h3 id="解析目录路径"><a href="#解析目录路径" class="headerlink" title="解析目录路径"></a>解析目录路径</h3><p>要描述一个文件的位置，可以使用绝对路径和相对路径。绝对路径是从根开始一级一级地进入各个子目录，最后指定该文件名或目录名。而相对路径是从当前目录进入某目录，最后指定该文件名或目录名。在系统的每个目录下都有两个特殊的目录“.”和“..”，分别指示当前目录和当前目录的父目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$unixPath=&quot;/var/www/html/index.php&quot;;		//在UNIX系统中的绝对路径，必须使用“/”作为路径分隔符</div><div class="line">$winPath=&quot;C:\\Appserv\\www\\index.php&quot;;		//在Windows系统中的绝对路径，默认使用“\”作为路径分隔符</div><div class="line">$winPath=&quot;C:\\Appserv\\www\\index.php&quot;;		//在Windows系统中也接受使用“/”作为路径分隔符</div><div class="line">$fileName1=&quot;file.txt&quot;;			//相对路径，当前目录下的file.txt文件</div><div class="line">$fileName2=&quot;javascript/common.js&quot;;			//相对路径。当前路径中javascript子目录下的common.js文件</div><div class="line">$fileName3=&quot;../images/logo.gif&quot;;			//相对路径。上一级目录中images子目录下的logo.gif文件</div></pre></td></tr></table></figure></p>
<p>为了程序可以有很好的移植性，建议都使用“/”作为文件的路径分隔符。</p>
<h4 id="函数basename"><a href="#函数basename" class="headerlink" title="函数basename()"></a>函数basename()</h4><p>该函数给出一个包含有指向一个文件的全部路径的字符串，本函数返回基本的文件名。第二个参数是可选参数，规定文件的扩展名。如果提供了则不会输出这个扩展名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$path = &quot;/var/www/html/page.php&quot;;    //包含有指向一个文件的全路径的字符串</div><div class="line"></div><div class="line">	echo basename($path);             //显示带有文件扩展名的文件名，输出page.php</div><div class="line">	echo basename($path,&quot;.php&quot;);       //显示不带有文件扩展名的文件名，输出page</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数dirname"><a href="#函数dirname" class="headerlink" title="函数dirname()"></a>函数dirname()</h4><p>该函数只需要一个参数，给出一个包含有指向一个文件的全路径的字符串，本函数返回去掉文件名后的目录名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$path = &quot;/var/www/html/page.php&quot;;  //包含有指向一个文件的全路径的字符串</div><div class="line"></div><div class="line">	echo dirname($path);              //返回目录名/var/www/html</div><div class="line">	echo dirname(&apos;c:/&apos;);                //返回目录名c:/</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数pathinfo"><a href="#函数pathinfo" class="headerlink" title="函数pathinfo()"></a>函数pathinfo()</h4><p>函数pathinfo()返回一个关联数组，其中包括指定路径中的目录名、基本名和扩展名三个部分。分别通过数组键dirname、basename和extension来引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$path = &quot;/var/www/html/page.php&quot;;  //包含有指向一个文件的全路径的字符串</div><div class="line">	$path_parts=pathinfo($path);        //返回包括指定路径中的目录名、基本名和扩展名关联数组</div><div class="line">	echo $path_parts[&quot;dirname&quot;];        //输出目录名/var/www/html</div><div class="line">	echo $path_parts[&quot;basename&quot;];       //输出基本名page.php</div><div class="line">	echo $path_parts[&quot;extension&quot;];       //输出扩展名.php</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><p>在进行PHP编程的时候，需要对服务器某个目录下面的文件进行浏览，通常称为遍历目录。取得一个目录下的文件和子目录，就需要用到opendir()函数、readdir()函数、closedir()函数和rewinddir()函数。</p>
<ul>
<li>函数opendir()用于打开指定目录，接受一个目录的路径及目录名作为参数，函数返回值为可供其他目录函数使用的目录句柄。如果该目录不存在或没有访问权限，则返回FALSE。</li>
<li>函数readdir()用于读取指定目录，接受已经用opendir()函数打开的可操作目录句柄作为参数，函数返回当前目录指针位置的一个文件名，并将目录指针向后移动一位。当指针位于目录的结尾时，因为没有文件存在则返回FALSE。</li>
<li>函数closedir()关闭指定目录，接受已经用opendir()函数打开的可操作目录句柄作为参数。函数无返回值，运行后将关闭打开的目录。</li>
<li>函数rewinddir()倒回目录句柄，接收已经用opendir()函数打开的可操作目录句柄作为参数。将目录指针重置目录到开始处，即倒回目录开头。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$num=0;                          	//用来统计子目录和文件的个数</div><div class="line">	$dirname=&apos;phpMyAdmin&apos;;            	//定义一个变量，保存当前目录下用来遍历的一个目录名</div><div class="line">	$dir_handle=opendir($dirname);       	//用opendir打开目录</div><div class="line"></div><div class="line">     	//将遍历的目录和文件名使用表格格式输出</div><div class="line">	echo &apos;&lt;table border=&quot;0&quot; align=&quot;center&quot; width=&quot;600&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&apos;;</div><div class="line">	echo &apos;&lt;caption&gt;&lt;h2&gt;目录&apos;.$dirname.&apos;下面的内容&lt;/h2&gt;&lt;/caption&gt;&apos;;     //输出表格标题</div><div class="line">	echo &apos;&lt;tr align=&quot;left&quot; bgcolor=&quot;#cccccc&quot;&gt;&apos;;                        //输出表格的字段名</div><div class="line">	echo &apos;&lt;th&gt;文件名&lt;/th&gt;&lt;th&gt;文件大小&lt;/th&gt;&lt;th&gt;文件类型&lt;/th&gt;&lt;th&gt;修改时间&lt;/th&gt;&lt;/tr&gt;&apos;;</div><div class="line">	while($file=readdir($dir_handle)) &#123;    		//使用readdir循环读取目录里的内容</div><div class="line">		$dirFile=$dirname.&quot;/&quot;.$file;      	//将目录下的文件和当前目录连接起来，才能在程序中使用</div><div class="line">		if($num++%2==0)             		//隔行一种颜色，同时也将计数器num累加</div><div class="line">			$bgcolor=&apos;#ffffff&apos;;         	//单行为白色背景</div><div class="line">		else</div><div class="line">			$bgcolor=&apos;#cccccc&apos;;        	//双行为灰色背景</div><div class="line">		echo &apos;&lt;tr bgcolor=&apos;.$bgcolor.&apos;&gt;&apos;;            	//输出行开始标记，并使用背景色</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$file.&apos;&lt;/td&gt;&apos;;                   	//显示文件名</div><div class="line">         	echo &apos;&lt;td&gt;&apos;.filesize($dirFile).&apos;&lt;/td&gt;&apos;;         //显示文件大小</div><div class="line">         	echo &apos;&lt;td&gt;&apos;.filetype($dirFile).&apos;&lt;/td&gt;&apos;;         //显示文件类型</div><div class="line">         	echo &apos;&lt;td&gt;&apos;.date(&quot;Y/n/t&quot;,filemtime($dirFile)).&apos;&lt;/td&gt;&apos;;       //格式化显示文件修改时间</div><div class="line">         	echo &apos;&lt;/tr&gt;&apos;;</div><div class="line">	&#125;</div><div class="line">	echo &apos;&lt;/table&gt;&apos;;                                     //关闭表格标记</div><div class="line">	closedir($dir_handle);                               //关闭文件操作句柄</div><div class="line"></div><div class="line">	echo &apos;在&lt;b&gt;&apos;.$dirname.&apos;&lt;/b&gt;目录下的子目录和文件共有&lt;b&gt;&apos;.$num.&apos;&lt;/b&gt;个&apos;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="统计目录大小"><a href="#统计目录大小" class="headerlink" title="统计目录大小"></a>统计目录大小</h3><p>计算文件的大小可以通过filesize()函数完成，统计磁盘大小也可以使用disk_free_space()和disk_total_space()两个函数实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function dirSize($directory) &#123;     	//自定义一个函数dirSize()，统计传入参数的目录大小</div><div class="line">		$dir_size=0;              	//整型变量初值为0，用来累加各个文件大小从而计算目录大小</div><div class="line"></div><div class="line">		if($dir_handle=@opendir($directory)) &#123;           		//打开目录，并判断是否能成功打开</div><div class="line">			while($filename=readdir($dir_handle)) &#123;      		//循环遍历目录下的所有文件</div><div class="line">				if($filename!=&quot;.&quot; &amp;&amp; $filename!=&quot;..&quot;) &#123;  	//一定要排除两个特殊的目录</div><div class="line">				    $subFile=$directory.&quot;/&quot;.$filename;   	//将目录下的子文件和当前目录相连</div><div class="line">					if(is_dir($subFile))               	//如果为目录</div><div class="line">						$dir_size+=dirSize($subFile);   //递归地调用自身函数，求子目录的大小</div><div class="line">					if(is_file($subFile))               	//如果是文件</div><div class="line">						$dir_size+=filesize($subFile);  //求出文件的大小并累加</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			closedir($dir_handle);                    //关闭文件资源</div><div class="line">			return $dir_size;                         //返回计算后的目录大小</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$dir_size=dirSize(&quot;phpMyAdmin&quot;);         	//调用该函数计算目录大小，返回目录大小的字节数</div><div class="line">	echo round($dir_size/pow(1024,1),2).&quot;KB&quot;;   	//将获取的目录字节数转换为“KB”单位并输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="建立和删除目录"><a href="#建立和删除目录" class="headerlink" title="建立和删除目录"></a>建立和删除目录</h3><p>在PHP中，使用mkdir()函数只需要传入一个目录名即可很容易地建立一个新目录。但删除目录所用的函数rmdir()，只能删除一个空目录并且目录必须存在。如果是非空的目录就需要先进入到路中，使用unlink()函数将目录中的每个文件都删除掉，再回来将这个空目录删除。如果目录中还存在子目录，而且子目录也非空，就要使用递归的方法了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function delDir($directory) &#123;         		//自定义函数递归的删除整个目录</div><div class="line">		if(file_exists($directory)) &#123;      	//判断目录是否存在，如果不存在rmdir()函数会出错</div><div class="line">			if($dir_handle=@opendir($directory)) &#123;      	//打开目录返回目录资源，并判断是否成功</div><div class="line">				while($filename=readdir($dir_handle)) &#123;  //遍历目录，读出目录中的文件或文件夹</div><div class="line">					if($filename!=&quot;.&quot; &amp;&amp; $filename!=&quot;..&quot;) &#123;   	//一定要排除两个特殊的目录</div><div class="line">						$subFile=$directory.&quot;/&quot;.$filename;   	//将目录下的文件和当前目录相连</div><div class="line">						if(is_dir($subFile))                	//如果是目录条件则成立</div><div class="line">							delDir($subFile);             	//递归调用自己删除子目录</div><div class="line">						if(is_file($subFile))                	//如果是文件条件则成立</div><div class="line">							unlink($subFile);             	//直接删除这个文件</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				closedir($dir_handle);                       	//关闭目录资源</div><div class="line">				rmdir($directory);                          	//删除空目录</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	delDir(&quot;phpMyAdmin&quot;);  //调用delDir()函数，将程序所在目录中的“phpMyAdmin”文件夹删除</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="复制或移动目录"><a href="#复制或移动目录" class="headerlink" title="复制或移动目录"></a>复制或移动目录</h3><p>要赋值一个包含多级子目录的目录，将涉及文件的赋值、目录创建等操作。赋值一个文件可以通过PHP提供的copy()函数完成，创建目录可以使用mkdir()函数，定义函数时，首先对原木了进行遍历，如果遇到的是普通文件，直接使用copy()函数进行复制。如果遍历时遇到一个目录，则必须建立该目录，然后再对该目录下的文件进行复制操作，如果还有子目录，则使用递归重复操作，最终将整个目录复制完成。如果是移动目录，只需在遍历时将赋值后的文件或目录删除即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	function copyDir($dirSrc, $dirTo) &#123;       //自定义函数递归的复制带有多级子目录的目录</div><div class="line">		if(is_file($dirTo)) &#123;               //如果目标不是一个目录，是一个已存在的文件则退出</div><div class="line">			echo &quot;目标不是目录不能创建!!&quot;;</div><div class="line">			return;                    //退出函数</div><div class="line">		&#125;</div><div class="line">		if(!file_exists($dirTo)) &#123;          //如果目标目录不存在则创建，存在则不变</div><div class="line">			mkdir($dirTo);             //创建目录目录</div><div class="line">		&#125;</div><div class="line">		if($dir_handle=@opendir($dirSrc)) &#123;           //打开目录返回目录资源，并判断是否成功</div><div class="line">			while($filename=readdir($dir_handle)) &#123;    //遍历目录，读出目录中的文件或文件夹</div><div class="line">				if($filename!=&quot;.&quot; &amp;&amp; $filename!=&quot;..&quot;) &#123;     //一定要排除两个特殊的目录</div><div class="line">					$subSrcFile=$dirSrc.&quot;/&quot;.$filename;     //将源目录的多级子目录连接</div><div class="line">					$subToFile=$dirTo.&quot;/&quot;.$filename;      //将目标目录的多级子目录连接</div><div class="line">						</div><div class="line">					if(is_dir($subSrcFile))                    //如果源文件是一个目录</div><div class="line">						copyDir($subSrcFile, $subToFile);     //递归调用自己复制子目录</div><div class="line">					if(is_file($subSrcFile))                   //如果源文件是一个普通文件</div><div class="line">						copy($subSrcFile, $subToFile);       //直接复制到目标位置</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			closedir($dir_handle);       //关闭目录资源</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	copyDir(&quot;phpMyAdmin&quot;, &quot;D:/admin&quot;);   //测试函数，将目录&quot;phpMyAdmin&quot;复制到&quot;D:/admin&quot;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>在PHP中可以通过标准函数fopen()建立与文件资源的连接，使用fclose()函数关闭通过fopen()函数打开的文件资源。</p>
<h4 id="函数fopen"><a href="#函数fopen" class="headerlink" title="函数fopen()"></a>函数fopen()</h4><p>该函数用来打开一个文件，并在打开一个文件时，还需要指定如何使用它。也就是以哪种文件模式打开文件资源。服务器上的操作系统文件必须知道对打开文件进行什么操作。操作系统需要了解在打开这个文件之后，这个文件是否允许其他的程序脚本再打开，还需要了解脚本的属主用户是否具有在这种方式下使用该文件的权限。该函数的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resource fopen(string filename,string mode[,bool use_include_path[,resource zcontext]])  //打开文件</div></pre></td></tr></table></figure></p>
<p>第一个参数需要提供要被打开文件的URL。这个URL可以是脚本所在的服务器中的绝对路径，也可以是相对路径，还可以是网络资源中的文件。<br>第二个参数需要提供文件模式，文件模式可以告诉操作系统如何处理来自其他人或脚本的访问请求，以及一种用来检查你是否有权访问这个特定文件的方法。当在打开文件时有三种选择：</p>
<ul>
<li>打开一个文件为了只读、只写或者是读和写。</li>
<li>如果要写一个文件，可以覆盖所有已有的文件内容，或者需要将新数据追加到文件末尾。</li>
<li>如果在一个区分二进制文件和纯文本文件的系统上写一个文件，还必须指定采用的方式。<br>函数fopen()也支持以上三种方式的组合，只需要在第二个参数中提供一个字符串，指定将对文件进行的操作即可。</li>
</ul>
<table>
<thead>
<tr>
<th>模式字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td style="text-align:left">只读方式打开文件，从文件开头开始读</td>
</tr>
<tr>
<td>r+</td>
<td style="text-align:left">读写方式打开文件，从文件开头开始读写</td>
</tr>
<tr>
<td>w</td>
<td style="text-align:left">只写方式打开文件，从文件开头开始写。如果文件已经存在，将文件指针指向文件头并将文件大小截为零，即删除所有文件已有的内容。如果该文件不存在，函数将创建这个文件</td>
</tr>
<tr>
<td>w+</td>
<td style="text-align:left">读写方式打开文件，从文件开头开始读写。如果文件已经存在，将文件指针指向文件头并将文件大小截为零，即删除所有文件已有的内容。如果文件不存在，函数将创建这个文件</td>
</tr>
<tr>
<td>x</td>
<td style="text-align:left">创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则fopen()调用失败并返回FALSE，并生成一条E_WARNING级别的错误信息。如果文件不存在则尝试创建之。仅能用于本地文件</td>
</tr>
<tr>
<td>x+</td>
<td style="text-align:left">创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则fopen()调用失败并返回FALSE，并生成一条E_WARNING级别的错误信息。如果文件不存在则尝试创建之。仅能用于本地文件</td>
</tr>
<tr>
<td>a</td>
<td style="text-align:left">写入方式打开，将文件指针指向文件末尾。如果该文件已有内容，将从该文件末尾开始追加。如果该文件不存在，函数将创建这个文件。</td>
</tr>
<tr>
<td>a+</td>
<td style="text-align:left">写入方式打开，将文件指针指向文件末尾。如果该文件已有内容，将从该文件末尾开始追加或读。如果该文件不存在，函数将创建这个文件。</td>
</tr>
<tr>
<td>b</td>
<td style="text-align:left">以二进制模式打开文件，用于与其他模式进行连接。如果文件系统能够区分二进制文件和文本文件，你可能会使用它。例如在Windows系统中可以区分，而UNIX系统则不区分。这个模式是默认的模式</td>
</tr>
<tr>
<td>t</td>
<td style="text-align:left">以文本模式打开文件，这个模式也只是windows系统下一个选项，不推荐使用</td>
</tr>
</tbody>
</table>
<p>第三个参数是可选的，如果资源位于本地文件系统，PHP则认为可以使用本地路径或相对路径来访问资源。如果这个参数设置为1，这样就会使PHP考虑配置指令include_path中指定的路径。<br>第四个参数也是可选的，fopen()函数允许文件名称以协议名称开始，例如“<a href="http://”，并且在一个远程位置打开该文件。通过设置这个参数，还可以支持一些其他的协议。" target="_blank" rel="external">http://”，并且在一个远程位置打开该文件。通过设置这个参数，还可以支持一些其他的协议。</a><br>如果fopen()函数成功打开一个文件，该函数将返回一个指向这个文件的文件指针。对该文件进行操作所使用的读、写以及其他的文件操作函数，都要使用这个资源来访问该文件。如果打开文件失败，则返回FALSE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	//使用绝对路径打开file.txt文件，选择只读模式，并返回资源$handle</div><div class="line">	$handle = fopen(&quot;/home/rasmus/file.txt&quot;,&quot;r&quot;);</div><div class="line">	//访问文档根目录下的文件，也以只读模式打开</div><div class="line">	$handle = fopen(&quot;$_SERVER[&apos;DOCUMENT_ROOT&apos;]/data/info.txt&quot;,&quot;r&quot;);</div><div class="line">	//在Windows平台上，转义文件路径中的每个反斜线，或者用斜线，以二进制和只写模式组合</div><div class="line">	$handle = fopen(&quot;c:\\data\\file.gif&quot;,&quot;wb&quot;);</div><div class="line">	//使用相对路径打开file.txt文件，选择只读模式，并返回资源$handle</div><div class="line">	$handle = fopen(&quot;../data/info.txt&quot;,&quot;r&quot;);</div><div class="line">	//打开远程文件，使用HTTP协议只能以只读的模式打开</div><div class="line">	$handle = fopen(&quot;http://www.example.com/&quot;,&quot;r&quot;);</div><div class="line">	//使用HTTP协议打开远程文件，如果FTP服务器可写，则可以以写的模式打开</div><div class="line">	$handle = fopen(&quot;ftp://user:password@example.com/somefile.txt&quot;,&quot;w&quot;);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数fclose"><a href="#函数fclose" class="headerlink" title="函数fclose()"></a>函数fclose()</h4><p>函数fclose()就会撤销fopen()打开的资源类型，成功时返回TRUE，否则返回FALSE。参数必须使用fopen()或fsockopen()函数打开的已存的文件指针。在目录操作中opendir()函数也是开启一个资源，使用closedir()将其关闭。</p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>将程序中的数据保存到文件中比较容易，使用fwrite()函数就可以将字符串内容写入文件中。在文件中通过字符序列\n表示换行符，标识文件中一行的末尾。当需要一次输入或输出一行信息时，不同的操作系统具有不同的结束符号，基于UNIX的系统使用“\n”作为行结束字符，基于Windows的系统使用“\n\r”作为行结束字符，基于Macintosh的系统使用“\r”作为行结束字符。当要写入一个文本文件并想插入一个新行时，需要使用相应操作系统的行结束符号。函数fwrite()的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int fwrite(resource handle,string string [,int length])			//写入文件</div></pre></td></tr></table></figure></p>
<p>第一个参数需要提供fopen()函数打开的文件资源，该函数将第二个参数提供的字符串内容输出到由第一个参数指定的资源中。如果给出了第三个可选参数length，fwrite()将在写入了length个字符时停止。否则将一直写入，直到到达内容结束时才停止。如果写入的内容少于length个字节，该函数也会在写完全部内容后停止。函数fwrite()执行完成以后会返回写入的字符数，出现错误时则返回FALSE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$fileName=&quot;data.txt&quot;;     //声明一个变量用来保存文件名		</div><div class="line">     	//使用fopen()函数以只写的模式打开文件，如果不存在则创建它，打开失败则通过程序</div><div class="line">	$handle = fopen($fileName, &apos;w&apos;) or die(&apos;打开&lt;b&gt;&apos;.$fileName.&apos;&lt;/b&gt;文件失败!!&apos;);</div><div class="line">	</div><div class="line">	for($row=0; $row&lt;10; $row++)                      //循环10次写入10行数据到文件中</div><div class="line">		fwrite($handle, $row.&quot;: www.lampbrother.net\n&quot;);	 //写入文件 </div><div class="line">		</div><div class="line">	fclose($handle);	         //关闭由fopen()打开的文件指针资源</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>另外，写入文件还可以使用fputs()函数，该函数是fwrite()函数的别名函数。如果需要快速写入文件还可以使用file_put_contents()函数，和依次调用fopen(),fwrite()以及fclose()函数的功能一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$fileName=&quot;data.txt&quot;;             //声明一个变量用来保存文件名</div><div class="line">	$data=&quot;共10行数据\n&quot;;           //声明一个变量用来保存被写入文件中的数据</div><div class="line"></div><div class="line">	for($row=0; $row&lt;10; $row++)     //使用循环形成10行数据</div><div class="line">		$data.=$row.&quot;: www.lampbrother.net\n&quot;;    //将10数据都存放到一个字符串变量中</div><div class="line">		</div><div class="line">	file_put_contents($fileName, $data);		    //一次将所有数据写入到指定的文件中</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>该函数可以将数据直接写入到指定的文件中。如果同时调用多次时，并向同一个文件中写入数据，则文件中只保存了最后一次调用该函数写入的数据。因为在每次调用时都会重新打开文件并将文件中原有的数据清空，所以不能连续写入多行数据。</p>
<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fread()</td>
<td style="text-align:left">读取打开的文件</td>
</tr>
<tr>
<td>file_get_contents()</td>
<td style="text-align:left">将文件读入字符串</td>
</tr>
<tr>
<td>fgets()</td>
<td style="text-align:left">从打开的文件中返回一行</td>
</tr>
<tr>
<td>fgetc()</td>
<td style="text-align:left">从打开的文件中返回字符</td>
</tr>
<tr>
<td>file()</td>
<td style="text-align:left">把文件读入一个数组中</td>
</tr>
<tr>
<td>readfile()</td>
<td style="text-align:left">读取一个文件，并输出到输出缓冲</td>
</tr>
</tbody>
</table>
<h4 id="函数fread"><a href="#函数fread" class="headerlink" title="函数fread()"></a>函数fread()</h4><p>该函数用来在打开的文件中读取指定长度的字符串。也可以安全用于二进制文件，在区分二进制文件和文本文件的系统（如Windows）打开文件时，fopen()函数的mode参数要加上’b’。函数fwrite()的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string fread(int handle,int length)		//读取打开的文件</div></pre></td></tr></table></figure></p>
<p>该函数从文件指针资源handle中读取最多length个字节。在读取完length个字节数，或到达EOF的时候，或当一个包可用都会停止读取文件，就看先碰到哪种情况了。该函数返回读取的内容字符串，如果失败则返回FALSE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">     	//从文件中读取指定字节数的内容存入到一个变量中</div><div class="line">	$filename = &quot;data.txt&quot;;                               //将本地文件名保存在变量中</div><div class="line">	$handle = fopen($filename, &quot;r&quot;) or die(&quot;文件打开失败&quot;);   //以只读的方式打开文件，返回文件资源</div><div class="line">	$contents = fread($handle, 100);                       //从文件中读取前100个字节</div><div class="line">	fclose($handle);                                    //关闭文件资源</div><div class="line">	echo $contents;                                    //将从文件中读取的内容输出</div><div class="line">	</div><div class="line">     	//从文件中读取全部内容存入到一个变量中，每次读取一部分，循环读取</div><div class="line">	$filename=&quot;c:\\files\\somepic.gif&quot;;                      //将二进制文件的文件名保存在变量中</div><div class="line">	$handle = fopen ($filename, &quot;rb&quot;) or die(&quot;文件打开失败&quot;);  //以只读的方式打开文件，模式加了’b’</div><div class="line">	$contents = &quot;&quot;;                             //声明一个用于保存全部文件内容的字符串</div><div class="line">	while (!feof($handle)) &#123;                      //循环读取文件中内容，使用feof()判断文件结尾</div><div class="line"> 		 $contents .= fread($handle, 1024);        //每次读取1024个字节</div><div class="line">	&#125;</div><div class="line">	fclose($handle);                            //关闭文件资源</div><div class="line">	echo $contents;                            //将从文件中读取的全部内容输出</div><div class="line"></div><div class="line">     	//另一种从文件中读取全部内容的方法</div><div class="line">	$filename = &quot;data.txt&quot;;                              //将本地文件名保存在变量中</div><div class="line">	$handle = fopen($filename, &quot;r&quot;) or die(&quot;文件打开失败&quot;);  //以只读的方式打开文件，返回文件资源</div><div class="line">	$contents = fread($handle, filesize ($filename));     //使用filesize()函数获取文件长度，一起读出</div><div class="line">	fclose($handle);                               //关闭文件资源</div><div class="line">	echo $contents;                               //将从文件中读取的全部内容输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>如果你只是想将一个文件的内容读入到一个字符串中，可以用file_get_contents()函数，它的性能比上面的代码好得多。file_get_contents()函数用来将文件的内容读入到一个字符串中的首选方法，如果操作系统支持还会使用内存映射技术来增强性能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	echo file_get_contents(&quot;data.txt&quot;);			//读取文本文件中的内容并输出</div><div class="line">	echo file_get_contents(&quot;c:\\files\\somepic.gif&quot;);				//读取二进制文件中的内容并输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数fgets-、fgetc"><a href="#函数fgets-、fgetc" class="headerlink" title="函数fgets()、fgetc()"></a>函数fgets()、fgetc()</h4><p>该函数一次至多从打开的文件资源中读取一行内容。函数fgets()的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string fgets(int handle[,int length)			//从打开的文件中返回一行</div></pre></td></tr></table></figure></p>
<p>第一个参数提供使用fopen()函数打开的资源。如果提供了第二个可选参数length，该函数返回length-1个字节。或者返回遇到换行或EOF之前读取的所以内容。如果忽略可选的length参数，默认为1024个字符前遇到换行符号，因此每次成功调用都会返回下一行。如果读取失败则返回FALSE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$handle = fopen(&quot;data.txt&quot;, &quot;r&quot;)  or die(&quot;文件打开失败&quot;);    //以只读模式打开文件</div><div class="line">	while (!feof($handle)) &#123;                   	//循环读取第一行，使用feof判断读取文件结尾</div><div class="line">  		$buffer = fgets($handle, 4096);         //一次读取打开文件中的一行内容</div><div class="line">   		echo $buffer.&quot;&lt;br&gt;&quot;;                 	//输出每一行，并加上HTML的换行标记</div><div class="line">	&#125;</div><div class="line">	fclose($handle);                         	//关闭打开的文件资源</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>函数fgetc()在打开的文件资源中只读取当前指针位置处的一个节符。如果遇到文件结束标志EOF时，将返回FALSE值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$fp = fopen(&apos;data.txt&apos;, &apos;r&apos;) or die(&quot;文件打开失败&quot;);    //以只读模式打开文件</div><div class="line">	</div><div class="line">	while (false !== ($char = fgetc($fp))) &#123;      //循环文件中读取一个节符碰到 EOF 标记停止</div><div class="line">   		 echo $char.&quot;&lt;br&gt;&quot;;                 //输出单个字符</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数file"><a href="#函数file" class="headerlink" title="函数file()"></a>函数file()</h4><p>该函数非常有用，与file_get_contents()类似，不需要使用fopen()函数打开文件，不同的是file()函数可以把整个文件读入到一个数组中。数组中的每个元素对应文件中的行，各元素由换行符分隔，同时换行符仍附加在每个元素的末尾。这样，就可以使用数组的相关函数对文件内容进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	print_r(file(&quot;test.txt&quot;);			//将文件test.txt中的内容读入到一个数组中，并输出。</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="函数readfile"><a href="#函数readfile" class="headerlink" title="函数readfile()"></a>函数readfile()</h4><p>该函数可以读取指定的整个文件，立即输出到输出缓冲区，并返回读取的字节数。该函数也不需要使用fopen()函数打开文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	readfile(&quot;data.txt&quot;);			//直接将文件data.txt中的数据独处并输出到浏览器</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="访问远程文件"><a href="#访问远程文件" class="headerlink" title="访问远程文件"></a>访问远程文件</h3><p>使用PHP不仅可以让用户通过浏览器访问服务器端的文件，还可以通过HTTP或FTP等协议访问其他服务器中的文件，可以在大多数需要文件名作为参数的函数中使用HTTP和FTP URL来代替文件名。使用fopen()函数将指定的文件名与资源绑定到一个流上，如果文件名是“scheme://..”的格式，则被当成一个URL，PHP将搜索协议处理器来处理此模式。<br>如果需要访问远程文件，必须在PHP的配置文件中激活“allow_url_fopen”选项，才能使用fopen()函数打开远程文件。而且还要确定其他服务器中的文件是否有访问权限，如果使用HTTP协议对远程文件进行连接，只能以“只读”模式打开。如果需要访问的远程FTP服务器中，对所提供的用户开启了“可写”权限，则使用FTP协议连接远程的文件时，就可以使用“可写”或“可读”模式打开文件。但不可以使用“可读可写”的模式。<br>使用PHP访问远程文件就向访问本地文件一样，都是使用相同的读写函数处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$file = fopen (&quot;http://www.lampbrother.com/&quot;, &quot;r&quot;) or die(&quot;打开远程文件失败！！&quot;);  //打开远程文件</div><div class="line"></div><div class="line">	while (!feof ($file)) &#123;              //循环从文件中读取内容</div><div class="line">    		$line = fgets ($file, 1024);     //每读取一行</div><div class="line">         //如果找到远程文件中的标题标记则取出标题，并退出循环，不在读取文件</div><div class="line">   		if (preg_match(&quot;/&lt;title&gt;(.*)&lt;\/title&gt;/&quot;, $line, $out)) &#123;    //使用正则匹配标题标记</div><div class="line">     			$title = $out[1];                        //将标题标记中的标题字符取出</div><div class="line">      			break;                                //退出循环，结束远程文件读取</div><div class="line">   		&#125;</div><div class="line">	&#125;</div><div class="line">	fclose($file);                  //关闭文件资源</div><div class="line">	echo $title;                   //输出获取到的远程网页的标题</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	//在ftp.lampbrother.net的远程服务器上创建文件，以写的模式打开</div><div class="line">	$file = fopen(&quot;ftp://user:password@ftp.lampbrother.net/path/to/file&quot;,&quot;w&quot;);</div><div class="line">	fwrite($file,&quot;Linux+Apache+MySQL+PHP&quot;);   	//将一个字符串写入到远程文件中去</div><div class="line">	fclose($file);				//关闭文件资源</div></pre></td></tr></table></figure>
<h3 id="移动文件指针"><a href="#移动文件指针" class="headerlink" title="移动文件指针"></a>移动文件指针</h3><p>在对文件进行读写过程中，有时需要在文件中跳转、从不同位置读取，以及将数据写入到不同的位置。指针的位置是以从文件头开始的字节数度量的，默认以不同模式打开文件时，文件指针通常在文件的开头或者结尾处，可以通过ftell()、fseek()和rewind()三个函数对文件指针进行操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int ftell(resource handle)				//返回文件指针的当前位置</div><div class="line">int fseek(resource handle,int offset[,int whence])			//移动文件指针到指定位置</div><div class="line">bool rewind(resource handle)			//移动文件指针到文件的开头</div></pre></td></tr></table></figure></p>
<p>使用这些函数时，必须提供一个用fopen()函数打开的、合法的文件指针。函数ftell()获取由指定的资源中的文件指针当前位置的偏移量;函数rewind()将文件指针移回到指定资源的开头；而函数fseek()则将指针移动到第二个参数offset指定的位置，如果没有提供第三个可选参数whence，则位置将设置为从文件开头的offset字节处。否则，第三个参数whence可以设置为三个可能的值，它将影响指针的位置。</p>
<ul>
<li>SEEK_CUR:设置指针位置为当前位置加上第二个参数所提供的offset字节</li>
<li>SEEK_END：设置指针位置为EOF加上offset字节。在这里，offset必须设置为负值</li>
<li>SEEK_SET:设置指针位置为offset字节处。这与忽略第三个参数whence效果相同。<br>如果fseek()函数执行成功，将返回0，失败则返回-1.如果将文件以追加模式“a”或者“a+”打开，写入文件的任何数据总是会被附加在后面，不会管文件指针的位置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$fp = fopen(&apos;data.txt&apos;, &apos;r&apos;) or die(&quot;文件打开失败&quot;);    //以只读模式打开文件</div><div class="line">	</div><div class="line">	echo ftell($fp).&quot;&lt;br&gt;&quot;;         //输出刚打开文件的指针默认位置，指针在文件的开头位置为0</div><div class="line">	echo fread($fp, 10).&quot;&lt;br&gt;&quot;;     //读取文件中的前10个字符输出，指针位置发生了变化</div><div class="line">	echo ftell($fp).&quot;&lt;br&gt;&quot;;         //读取文件的前10个字符之后，指针移动的位置在第10个字节处</div><div class="line">	fseek($fp, 100, SEEK_CUR);   	//将文件指针的位置，由当前位置向后移动100个字节数</div><div class="line">	echo ftell($fp).&quot;&lt;br&gt;&quot;;         //文件位置在110个字节处</div><div class="line">	echo fread($fp, 10).&quot;&lt;br&gt;&quot;;     //读取110到120字节数位置的字符串，读取后指针的位置为120</div><div class="line">	fseek($fp, -10, SEEK_END);   	//又将指针移动到倒数10个字节位置处</div><div class="line">	echo fread($fp, 10).&quot;&lt;br&gt;&quot;;     //输出文件中最后10个字符	</div><div class="line">	rewind($fp);                 	//又移动文件指针到文件的开头</div><div class="line">	echo ftell($fp).&quot;&lt;br&gt;&quot;;         //指针在文件的开头位置，输出0</div><div class="line"></div><div class="line">	fclose($fp);                	//关闭文件资源</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="文件的一些基本操作函数"><a href="#文件的一些基本操作函数" class="headerlink" title="文件的一些基本操作函数"></a>文件的一些基本操作函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:left">语法结构</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy()</td>
<td style="text-align:left">copy(来源文件，目的文件)</td>
<td style="text-align:left">复制文件</td>
</tr>
<tr>
<td>unlike()</td>
<td style="text-align:left">unlike(目标文件)</td>
<td style="text-align:left">删除文件</td>
</tr>
<tr>
<td>ftruncate()</td>
<td style="text-align:left">ftruncate(目标文件资源，截取长度)</td>
<td style="text-align:left">将文件截断到指定长度</td>
</tr>
<tr>
<td>rename()</td>
<td style="text-align:left">rename(旧文件名，新文件名)</td>
<td style="text-align:left">重命名文件或目录</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	if(copy(&apos;./file1.txt&apos;, &apos;../data/file2.txt&apos;)) &#123;              //复制文件示例</div><div class="line">		echo &quot;文件复制成功！&quot;;</div><div class="line">	&#125;else&#123;</div><div class="line">		echo &quot;文件复制失败！&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$filename=&quot;file1.txt&quot;;                           //删除文件示例</div><div class="line">	if(file_exists($filename))&#123;</div><div class="line">		if(unlink($filename)) &#123;</div><div class="line">			echo &quot;文件删除成功！&quot;;</div><div class="line">		&#125;else&#123;</div><div class="line">			echo &quot;文件删除失败！&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;else&#123;</div><div class="line">		echo &quot;目标文件不存在&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if(rename(&apos;./demo.php&apos;, &apos;./demo.html&apos;)) &#123;           //重命名文件示例</div><div class="line">		echo &quot;文件重命名成功！&quot;;</div><div class="line">	&#125;else&#123;</div><div class="line">		echo &quot;文件重命名失败&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$fp=fopen(&apos;./data.txt&apos;, &quot;r+&quot;) or die(&apos;文件打开失败&apos;);  //截取文件示例</div><div class="line">	if(ftruncate($fp, 1024)) &#123;</div><div class="line">		echo &quot;文件截取成功！&quot;;</div><div class="line">	&#125;else&#123;</div><div class="line">		echo &quot;文件截取失败！&quot;;</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="客户端上传设置"><a href="#客户端上传设置" class="headerlink" title="客户端上传设置"></a>客户端上传设置</h4><p>文件上传的最基础方法，是使用HTML表单选择本地文件进行提交，在form表单中可以通过<input="file">标记选择本地文件。如果支持文件上传操作，必须在<form>标签中将enctype和method两个属性指明相应的值。</form></input="file"></p>
<ul>
<li>enctype=”munltipart/form-data”用来指定表单编码数据方式，让服务器知道，我们要传递一个文件，并带有常规的表单信息</li>
<li>method=”POST”用来指明发送数据的方法。<br>另外，还需要在form表单中设置一个hidden类型的input框。其中name值为MAX_FILL_SIZE的隐藏值域，并通过设置其VALUE的值限制上传文件的大小（单位字节），但这个值不能超过PHP的配置文件中upload_max_filesize值设置的大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;form action=&quot;upload.php&quot;  method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">			&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1000000&quot;&gt;</div><div class="line">			选择文件：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;</div><div class="line">			&lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt;</div><div class="line">		&lt;/form&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="在服务器端通过PHP处理上传"><a href="#在服务器端通过PHP处理上传" class="headerlink" title="在服务器端通过PHP处理上传"></a>在服务器端通过PHP处理上传</h4><p>客户端的上传表单只能提供本地文件选择，以及提供将文件发送给服务器的标准化方式，但并没有提供相关功能来确定文件到达目的地后发生了什么。所以上传文件的接收和后续处理就要通过PHP脚本来处理。要通过PHP成功地管理文件上传，需要通过以下三方面信息。</p>
<ul>
<li>设置PHP配置文件中的指令：用于精细地调节PHP的文件上传功能</li>
<li>$_FILES多维数组：用于存储各种与上传文件有关的信息。</li>
<li>PHP的文件上传处理函数：用于上传文件的后续处理。</li>
</ul>
<h5 id="PHP配置文件中与文件上传有关的选项"><a href="#PHP配置文件中与文件上传有关的选项" class="headerlink" title="PHP配置文件中与文件上传有关的选项"></a>PHP配置文件中与文件上传有关的选项</h5><table>
<thead>
<tr>
<th>指令名</th>
<th style="text-align:left">默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_uploads</td>
<td style="text-align:left">ON</td>
<td>确定服务器上的PHP脚本是否可以接受HTTP文件上传</td>
</tr>
<tr>
<td>memory_limit</td>
<td style="text-align:left">8M</td>
<td>设置脚本可以分配的最大内存量，防止失控的脚本独占服务器内存</td>
</tr>
<tr>
<td>upload_max_filesize</td>
<td style="text-align:left">2M</td>
<td>限制PHP处理上传文件大小的最大值，此值必须小于post_max_size值</td>
</tr>
<tr>
<td>post_max_size</td>
<td style="text-align:left">8M</td>
<td>限制通过POST方法可以接受信息的最大值，此值应当大于配置指令upload_max_file的值，因为除了上传的文件之外，还可能传递其他的表单域</td>
</tr>
<tr>
<td>upload_tmp_dir</td>
<td style="text-align:left">NULL</td>
<td>上传文件存放的临时路径，可以是一个绝对路径。这个目录对于拥有此服务器进程用户必须是可写的。上传的文件在处理之前必须成功传输到服务器，所以必须指定一个位置，可以临时放置这些文件，知道文件移到最终目的地为止。例如：upload_tmp_dir=/tmp/.uploads/。默认值为NULL则为操作系统的临时文件夹</td>
</tr>
</tbody>
</table>
<p>表单提交给服务器的数据，可以通过在PHP脚本中使用全局数组 $_GET、 $_POST或 $_REQUEST 接收。而通过POST方法上传的文件有关信息都被存储在多维数组 $_FILES中，这些信息对于通过PHP脚本上传到服务器的文件至关重要。因为文件上传后，首先存储于服务器的临时目录中，同时在PHP脚本中就获取一个$_FILES全局数组。$_FILES数组的第二维中共有五项。</p>
<h5 id="全局数组-FILES中的元素说明"><a href="#全局数组-FILES中的元素说明" class="headerlink" title="全局数组$_FILES中的元素说明"></a>全局数组$_FILES中的元素说明</h5><table>
<thead>
<tr>
<th>数组</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$_FILES[“myfile”][“name”]</td>
<td style="text-align:left">客户端机器文件的原名称，包括扩展名</td>
</tr>
<tr>
<td>$_FILES[“myfile”][“size”]</td>
<td style="text-align:left">已上传文件的大小，单位为字节</td>
</tr>
<tr>
<td>$_FILES[“myfile”][“tmp_name”]</td>
<td style="text-align:left">文件被上传后，在服务器端存储的临时文件名。这是存储在临时目录（由PHP指令upload_tmp_dir指定）中所指定的文件名</td>
</tr>
<tr>
<td>$_FILES[“myfile”][“error”]</td>
<td style="text-align:left">伴随文件上传时产生的错误信息，有五个可能的值。<em>    0：表示没有发生任何错误，文件上传成功</em>    1：表示上传文件的大小超出了在PHP配置文件中指令upload_max_filesize选项限制的值<em>    2：表示上传文件大小超出了HTML表单中MAX_FILE_SIZE选项指定的值</em>    3：表示文件只被上载*    4：标识没有上载任何文件</td>
</tr>
<tr>
<td>$_FILES[“myfile”][“type”]</td>
<td style="text-align:left">获取从客户端上传文件MIME类型，MIME类型规定了各种文件格式的类型，每种MIME类型都是由“/”分隔的主类型和子类型组成，如“image/gif”，主类型为“图像”,子类型为GIF格式的文件，“text/html”代表文本的HTML文件，还有很多其他不同类型的文件。</td>
</tr>
</tbody>
</table>
<ul>
<li>函数is_upload_file()<br>该函数判断指定的文件是否通过HTTP POST上传的，如果是则返回TRUE。用于防止潜在的攻击者对原本不能通过脚本交互的文件进行非法管理，这可以用来确保恶意的用户无法欺骗脚本去访问不能访问的文件，例如/etc/passwd。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bool is_uploaded_file( string filename)			//判断指定的文件是否通过HTTP POST上传的</div></pre></td></tr></table></figure>
</li>
</ul>
<p>为了能使此函数正常工作，唯一的参数必须指定类似于$_FILES[‘userfile’][‘tmp_name’]的变量，才能判断指定的文件确定是上传文件。如果使用从客户端上传的文件名$_FILES[‘userfile’][‘name’]则不能正常运作。</p>
<ul>
<li>函数move_uploaded_file()<br>文件上传后，首先会存储于服务器的临时目录中，可以使用该函数将上传的文件移动到新位置。此函数的原型如下所示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bool move_uploaded_file(string filename,string destination)				//将上传的文件移动到新位置</div></pre></td></tr></table></figure>
</li>
</ul>
<p>虽然函数copy()和函数move()也同样好用，但函数move_uploaded_file()还提供了一种额外的功能，检查并确保由第一个参数filename指定的文件，是否是合法的上传文件。如果文件合法，则将其移到为由第二个参数destination指定的文件。如果filename不是合法的上传文件，不会出现任何操作，将返回FALSE。如果filename是合法的上传文件，但处于某些原因无法移动，不会出现任何操作，也将返回FALSE。此外还会发出一条警告。若成功则返回TRUE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	if($_FILES[&apos;myfile&apos;][&apos;error&apos;] &gt; 0) &#123;      //判断文件是否可以成功上传到服务器，0表示上传成功</div><div class="line">		echo &apos;上传错误: &apos;;</div><div class="line">    		switch ($_FILES[&apos;myfile&apos;][&apos;error&apos;]) &#123;</div><div class="line">     			case 1:  </div><div class="line">				echo &apos;上传文件大小超出了PHP配置文件中的约定值：upload_max_filesize&apos;;  </div><div class="line">				break;</div><div class="line">			case 2:  </div><div class="line">				echo &apos;上传文件大小超出了表单中的约定值：MAX_FILE_SIZE&apos;;  </div><div class="line">				break;</div><div class="line">			case 3:  </div><div class="line">				echo &apos;文件只被部分上载&apos;; </div><div class="line">			       	break;</div><div class="line">			case 4:  </div><div class="line">				echo &apos;没有上传任何文件&apos;; </div><div class="line">			       	break;</div><div class="line">   		&#125;</div><div class="line">		exit;       //如果$_FILES[&apos;myfile&apos;][&apos;error&apos;]大于0都是有错误，输出错误信息并退出程序</div><div class="line">	&#125;</div><div class="line">     	//获取上传文件的MIME类型中的主类型和子类型</div><div class="line">	list($maintype,$subtype)=explode(&quot;/&quot;,$_FILES[&apos;myfile&apos;][&apos;type&apos;]);	</div><div class="line">  	if ($maintype==&quot;text&quot;) &#123;    //通过主类型限制不能上传文本文件，例如.txt .html .php等文件文件</div><div class="line">		echo &apos;问题: 不能上传文本文件。&apos;;</div><div class="line">		exit;                //如果用户上传文本文件则退出程序</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$upfile = &apos;./uploads/&apos;.time().$_FILES[&apos;myfile&apos;][&apos;name&apos;];     //定义上传后的位置和新文件名</div><div class="line">	if (is_uploaded_file($_FILES[&apos;myfile&apos;][&apos;tmp_name&apos;])) &#123;     //判断是否为上传文件</div><div class="line"> 	    	if (!move_uploaded_file($_FILES[&apos;myfile&apos;][&apos;tmp_name&apos;], $upfile)) &#123;   //从移动文件</div><div class="line">        		echo &apos;问题: 不能将文件移动到指定目录。&apos;;</div><div class="line">       		exit;</div><div class="line">		&#125;</div><div class="line"> 	&#125;else&#123;</div><div class="line">		echo &apos;问题: 上传文件不是一个合法文件: &apos;;</div><div class="line">		echo $_FILES[&apos;myfile&apos;][&apos;name&apos;];</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	echo &apos;文件&apos;.$upfile.&apos;上传成功,大小为&apos;.$_FILES[&apos;myfile&apos;][&apos;size&apos;].&apos;！&lt;br&gt;&apos;;   //如果文件上传成功则输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="处理多个文件上传"><a href="#处理多个文件上传" class="headerlink" title="处理多个文件上传"></a>处理多个文件上传</h3><p>多个文件上传和单独文件上传的处理方式是一样的，只需要在客户端多提供几个类型为“file”的输入表单，并指定不同的“name”属性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;form action=&quot;mul_upload.php&quot;  method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">			&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1000000&quot;&gt;</div><div class="line">			选择文件1：&lt;input type=&quot;file&quot; name=&quot;myfile[]&quot;&gt;&lt;br&gt;</div><div class="line">			选择文件2：&lt;input type=&quot;file&quot; name=&quot;myfile[]&quot;&gt;&lt;br&gt;</div><div class="line">			选择文件3：&lt;input type=&quot;file&quot; name=&quot;myfile[]&quot;&gt;&lt;br&gt;</div><div class="line">			&lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt;</div><div class="line">		&lt;/form&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中，将三个文件类型的表单以数组的形式组织在一起。当上面的表单提交给PHP的脚本文件mul_upload.php时，在服务器端同时使用全局数组$_FILES存储所有上传文件的信息，但$_FILES由二维数组已经转变为三维数组，这样就可以存储多个上传文件的信息。在脚本文件mul_upload.php中，使用print_r()函数将$_FILES数组中的内容输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	print_r($_FILES);         //打印三维数组$_FILES中的内容，查看一下存储上传文件的结构</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>简单的文件下载只需要使用HTML的链接标记a,并将属性href的URL值指定下载的文件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;http://www.example.com/download/example.rar&quot;&gt;下载文件&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>如果通过上面的代码实现文件下载，只能处理一些浏览器不能默认识别的MIME类型文件，例如，当访问example.rar文件时，浏览器并没有直接打开，而是淡出一个下载提示框，提示用户“下载”还是“打开”等处理方式。但如果需要下载后缀名为.html的网页文件、图片文件以及PHP程序脚本文件等，用这种链接形式，则会将文件内容直接输出到浏览器中，并不会提示用户下载。</p>
<p>为了提供文件的安全性，不希望在a标签中给出文件的链接，则必须想浏览器发送必要的头信息，以通知浏览器将要进行下载文件的处理。PHP使用header()函数发送网页的头部信息给浏览器，该函数接受一个头信息的字符串作为参数。文件下载需要发送的头信息包括以下三部分，通过调用三次header()函数完成。以下载图片test.gif为例，需要发送的头信息的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">header(&apos;Content-Type:image/gif&apos;);			//发送指定文件MIME类型的头信息</div><div class="line">header(&apos;Content-Disposition:attachment;filename=&quot;test.gif&quot;&apos;);			//发送描述文件的头信息，附件和文件名</div><div class="line">header(&apos;Content-Length:3390&apos;);			//发送指定文件大小的信息，单位字节</div></pre></td></tr></table></figure></p>
<p>如果使用header()函数向浏览器发送了这三行头信息，图片test.gif就不会直接在浏览器中显示，而是让浏览器将该文件形式下载的形式。在函数header()中，“Content-Type”指定了文件的MIME类型，“Content-Disposition”用于文件的描述，值“attachment;filename=”test.gif””说明这是一个附件，并且指定了下载后的文件名，“Content-Length”则给出被下载文件的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$filename=&quot;test.gif&quot;;                                         //指定文件名</div><div class="line">	header(&apos;Content-Type: image/gif&apos;);                              //指定下载文件类型</div><div class="line">	header(&apos;Content-Disposition: attachment; filename=&quot;&apos;.$filename.&apos;&quot;&apos;);   //指定下载文件的描述</div><div class="line">	header(&apos;Content-Length: &apos;.filesize($filename));                     //指定下载文件的大小         </div><div class="line">	readfile($filename);       //将文件内容读取出来并直接输出，以便下载</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="MySQL数据库设计"><a href="#MySQL数据库设计" class="headerlink" title="MySQL数据库设计"></a>MySQL数据库设计</h1><h2 id="MySQL数据库管理"><a href="#MySQL数据库管理" class="headerlink" title="MySQL数据库管理"></a>MySQL数据库管理</h2><h3 id="结构化查询语句SQL"><a href="#结构化查询语句SQL" class="headerlink" title="结构化查询语句SQL"></a>结构化查询语句SQL</h3><p>SQL语句包含四个部分。</p>
<ul>
<li>数据定义语言（DDL）：用于定义和管理数据对象，包括数据库、数据表等。例如：CREATE、DROP、ALTER等语句</li>
<li>数据操作语言（DML）：用于操作数据库对象中所包含的数据。例如：INSERT、UPDATE、DELETE语句。</li>
<li>数据查询语言（DQL）：用于查询数据库对象 中所包含的数据，能够进行单表查询、连接查询、嵌套查询，以及集合查询等各种复杂程度不同的数据库查询，并将数据返回到客户机中显示。例如：SELECT语句。</li>
<li>数据控制语言（DCL）：是用来管理数据库的语言，包含管理权限及数据更改。例如:GRANT、REVOKE、COMMIT、ROLLBACK等语句。</li>
</ul>
<h3 id="MySQL数据库的连接与关闭"><a href="#MySQL数据库的连接与关闭" class="headerlink" title="MySQL数据库的连接与关闭"></a>MySQL数据库的连接与关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h 服务器主机地址 -u 用户名 -p 用户密码</div></pre></td></tr></table></figure>
<ul>
<li>-h：指定所连接的数据库服务器位置，可以是IP地址，也可以是服务器域名</li>
<li>-u：指定连接数据库服务器使用的用户名，例如root为管理员用户具有所有权限</li>
<li>-p：连接数据库服务器使用的密码，但-p和其后的参数之间不要有空格。最后是在该参数后直接回车，然后以密文的形式输入密码<br>如果需要退出客户机，可以任何输入exit或quit命令结束会话</li>
</ul>
<h3 id="创建、选择及查看数据库"><a href="#创建、选择及查看数据库" class="headerlink" title="创建、选择及查看数据库"></a>创建、选择及查看数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE DATABASE [IF NOT EXISTS]bookstore;			#创建一个名为bookstore的数据库</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP DATABASE [IF EXISTS]bookstore;					#删除一个名为bookstore的数据库</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW DATABASES;							#显示所有已建立的数据库名称列表</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">USE bookstore;					#打开bookstore数据库为当前数据库使用</div></pre></td></tr></table></figure>
<h2 id="MySQL数据库中数据表的设计"><a href="#MySQL数据库中数据表的设计" class="headerlink" title="MySQL数据库中数据表的设计"></a>MySQL数据库中数据表的设计</h2><h3 id="数据表（Table）"><a href="#数据表（Table）" class="headerlink" title="数据表（Table）"></a>数据表（Table）</h3><p>数据表是数据库中基本对象元素，以记录（行）和字段（列）组成的二维结构用于存储数据。数据表由表结构和表内容两部分组成，先建立表结构，然后才能输入数据。数据表结构设计主要包括：字段名称、字段类型和字段属性的设置。</p>
<h3 id="数据值和列类型"><a href="#数据值和列类型" class="headerlink" title="数据值和列类型"></a>数据值和列类型</h3><p>对MySQL中数据值的分类，有数值型、字符型、日期型和空值等，MySQL数据库的表是一个二维表，由一个或多个数据列构成。MySQL中的列类型有三种：数值类、字符串类和日期/时间类。</p>
<h4 id="数组类的数据列类型"><a href="#数组类的数据列类型" class="headerlink" title="数组类的数据列类型"></a>数组类的数据列类型</h4><p>MySQL中的数值分整型和浮点型两种。而整型中又分为五种整形数据列类型，即TINYINT,SMALLINT,MEDIUMINT,INT和BIGINT。MySQL也有三种浮点型数据列类型，分别是：FLOAT,BOUBLE和DECIMAL。</p>
<table>
<thead>
<tr>
<th>数据列类型</th>
<th style="text-align:left">存储空间</th>
<th>说明</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td style="text-align:left">1字节</td>
<td>非常小的整数</td>
<td>带符号值：-128-127   无符号：0-255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td style="text-align:left">2字节</td>
<td>较小的整数</td>
<td>带符号值：-32768-32767   无符号：0-65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td style="text-align:left">3字节</td>
<td>中等大小的整数</td>
<td>带符号值：-8388608-8388607   无符号：0-16777215</td>
</tr>
<tr>
<td>INT</td>
<td style="text-align:left">4字节</td>
<td>标准整数</td>
<td>带符号值：-2147483648-2147483647   无符号：0-4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td style="text-align:left">8字节</td>
<td>大整数</td>
<td>带符号值：-9223372036854775808-9233372036854775807   无符号：0-18446744073709551615</td>
</tr>
<tr>
<td>FLOAT</td>
<td style="text-align:left">4或8字节</td>
<td>单精度浮点数</td>
<td>最小非零值：+-1.175494351E-38 最大非零值：+-3.402823466E+38</td>
</tr>
<tr>
<td>DOUBLE</td>
<td style="text-align:left">8字节</td>
<td>双精度浮点数</td>
<td>最小非零值：+-2.2250738585072014E-308 最大非零值：+-1.7976931348623157E+308</td>
</tr>
<tr>
<td>DECIMAL</td>
<td style="text-align:left">自定义</td>
<td>以字符串形式表示的浮点数</td>
<td>取决于存储单位字节数</td>
</tr>
</tbody>
</table>
<h4 id="字符串类数据列类型"><a href="#字符串类数据列类型" class="headerlink" title="字符串类数据列类型"></a>字符串类数据列类型</h4><table>
<thead>
<tr>
<th>数据列类型</th>
<th style="text-align:left">存储空间</th>
<th>说明</th>
<th>最大长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR[(M)]</td>
<td style="text-align:left">M字节</td>
<td>定长字符串</td>
<td>M字节</td>
</tr>
<tr>
<td>VARCHAR[(M)]</td>
<td style="text-align:left">L+1字节</td>
<td>可变字符串</td>
<td>M字节</td>
</tr>
<tr>
<td>TINYBLOD,TINYTEXT</td>
<td style="text-align:left">L+1字节</td>
<td>非常小的BLOB(二进行大对象)和文本串</td>
<td>2e+8-1字节</td>
</tr>
<tr>
<td>BLOB,TEXT</td>
<td style="text-align:left">L+2字节</td>
<td>小BLOB和文本串</td>
<td>2e+16-4字节</td>
</tr>
<tr>
<td>MEDIUMBLOB,MEDIUMTEXT</td>
<td style="text-align:left">L+3字节</td>
<td>中等的BLOB和文本串</td>
<td>2e24-1字节</td>
</tr>
<tr>
<td>LONGBLOB,LONGTEXT</td>
<td style="text-align:left">L+4字节</td>
<td>大BLOB和文本串</td>
<td>2e32-1字节</td>
</tr>
<tr>
<td>ENUM(‘value1’,’value2’,…)</td>
<td style="text-align:left">1或2字节</td>
<td>枚举：可赋予某个枚举成员</td>
<td>65535个成员</td>
</tr>
<tr>
<td>SET(‘value1’,’value2’,…)</td>
<td style="text-align:left">1,2,3,4或8字节</td>
<td>集合：可赋予多个集合成员</td>
<td>64个成员</td>
</tr>
</tbody>
</table>
<p>对于可变长的字符串类型，其长度取决于实际存放在劣种的值的长度。此长度用L来表示。</p>
<h4 id="日期和时间型数据列类型"><a href="#日期和时间型数据列类型" class="headerlink" title="日期和时间型数据列类型"></a>日期和时间型数据列类型</h4><table>
<thead>
<tr>
<th>数据列类型</th>
<th style="text-align:left">存储空间</th>
<th>说明</th>
<th>最大长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td style="text-align:left">3字节</td>
<td>“YYYY-MM-DD”格式表示的日期值</td>
<td>1000-01-01~9999-12-31</td>
</tr>
<tr>
<td>TIME</td>
<td style="text-align:left">3字节</td>
<td>“hh:mm:ss”格式表示的时间值</td>
<td>-838:59:59~838:59:59</td>
</tr>
<tr>
<td>DATETIME</td>
<td style="text-align:left">8字节</td>
<td>“YYYY-MM-DD hh:mm:ss”格式</td>
<td>1000-01-01 00:00:00到9999-12-31 23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td style="text-align:left">4字节</td>
<td>“YYYYMMDDhhmmss”格式表示的时间戳</td>
<td>19700101000000~2037年的某个时刻</td>
</tr>
<tr>
<td>YEAR</td>
<td style="text-align:left">1字节</td>
<td>“YYYY”格式的年份量</td>
<td>1901~2155</td>
</tr>
</tbody>
</table>
<h4 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h4><p>NULL意味着”没有值”或”未知值”，MySQL中，0或NULL都意味着假而其他值意味着真。布尔运算的默认真值是1.</p>
<h3 id="数据字段属性"><a href="#数据字段属性" class="headerlink" title="数据字段属性"></a>数据字段属性</h3><h4 id="UNSIGNED"><a href="#UNSIGNED" class="headerlink" title="UNSIGNED"></a>UNSIGNED</h4><p>该属性也只能用于设置数值类型，在数值之前自动用0补齐数据列出现负数。</p>
<h4 id="ZEROFILL"><a href="#ZEROFILL" class="headerlink" title="ZEROFILL"></a>ZEROFILL</h4><p>该属性也只能用于设置数值类型，在数值之前自动用0补充不足的位数。</p>
<h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h4><p>该属性用于设置字段的自动增量属性，当数值类型的字段设置为自动增量时，每增加一条新纪录，该字段的值就自动加1，而且此字段的值不允许重复。此修饰符只能修饰整数类型的字段。</p>
<h4 id="NULL和NOT-NULL"><a href="#NULL和NOT-NULL" class="headerlink" title="NULL和NOT NULL"></a>NULL和NOT NULL</h4><p>默认为NULL，即插入值时没有在此字段插入值，默认为NULL值，如果指定了NOT NULL，则必须在插入值时在此字段添入值</p>
<h4 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h4><p>可以通过此属性来指定一个默认值，如果没有在此列添加值，那么默认添加此值。</p>
<h3 id="创建、修改及删除表"><a href="#创建、修改及删除表" class="headerlink" title="创建、修改及删除表"></a>创建、修改及删除表</h3><h4 id="创建表（CREATE-TABLE）"><a href="#创建表（CREATE-TABLE）" class="headerlink" title="创建表（CREATE TABLE）"></a>创建表（CREATE TABLE）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE [IF NOT EXISTS] 表名称（			#创建带给定名称的表，必须拥有表CREATE权限</div><div class="line">	字段名1 列类型 [属性][索引],			#声明表中第一个字段，必须有字段名和列类型</div><div class="line">	字段名2 列类型 [属性][索引],			</div><div class="line">	...,</div><div class="line">	字段名n 列类型 [属性][索引],			#每个字段的属性和索引都是可选的，根据需要设置</div><div class="line">）[表类型][表字符集];							#在创建表时也可指定可选的表类型和字符集的设置</div></pre></td></tr></table></figure>
<p>其中[]中的为可选的内容，一个表可以由一个或多个字段（列）组成，在字段名后面一定要注明该字段的数据类型。每个字段也可以使用属性对其进行限制说明，但属性是可选的，根据表的需要进行声明。</p>
<h4 id="修改表（ALTER-TABLE）"><a href="#修改表（ALTER-TABLE）" class="headerlink" title="修改表（ALTER TABLE）"></a>修改表（ALTER TABLE）</h4><p>可以用ALTER TABLE语句来修改表的结构，包括添加新的字段、删除原有的字段、修改列的类型、属性及索引，甚至可以修改表的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE 表名 ACTION；				#修改表的语法格式</div></pre></td></tr></table></figure></p>
<p>其中ACTION是ALTER TABLE的从句，包括为指定的表添加一新列、为表添加一个索引、更改指定列默认值、更改列类型、删除一列、删除索引、更改表名等语句。</p>
<ul>
<li>为指定的数据表添加一新字段，可以在ACTION从句中使用ADD关键字实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE 表名 ADD 字段名 &lt;建表语句&gt;[FIRST|AFTER 列名]		#为指定的表添加新列</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果没指定可选的FIRST或AFTER，则在列尾添加一列，否则在指定列添加新列。</p>
<ul>
<li>为指定的数据表为了更改原有字段的类型，可使用CHANGE或MODIFY子句。如果原列的名字和新列的名字相同，则change或Modify的作用相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE 表名 CHANGE(MODIFY) 列表 &lt;建表语句&gt;		#为指定的表修改列类型</div></pre></td></tr></table></figure>
</li>
</ul>
<p>CHANGE除了更改类型外还能更改列名，而MODIFY不能实现这个功能。</p>
<ul>
<li>如果需要为指定的数据表重新命名，可使用RENAME AS子句，给出旧表名和新表名即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE 旧表名 RENAME AS 新表名			#为 指定的数据表重新命名</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="删除表（DROP-TABLE）"><a href="#删除表（DROP-TABLE）" class="headerlink" title="删除表（DROP TABLE）"></a>删除表（DROP TABLE）</h4><p>可以使用SQL的DROP TABLE语句删除。删除表要比创建和修改表要容易得多，只需要指定表名即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP TABLE[IF EXISTS] 表名</div></pre></td></tr></table></figure></p>
<p>当不能确定数据表是否存在，如果存在就删除它，如果存在就删除它，不存在则删除时也不行出现错误，就可在DROPTABLE语句中增加IF EXISTS。同CREATE TABLE一样，IF EXISTS语句在含有DROP TABLE的SQL脚本中很常用，如果不存在待删除的表，脚本会继续向下执行而不会跑出错误。</p>
<h3 id="数据表的类型及存储位置"><a href="#数据表的类型及存储位置" class="headerlink" title="数据表的类型及存储位置"></a>数据表的类型及存储位置</h3><p>MySQL支持MyISAM、InnoDB、HEAP、BOB、ARCHIVE、CSV等多种数据表类型，在创建一个新MySQL数据库表时，可以为它设置一个类型。</p>
<h4 id="MyISAM数据表"><a href="#MyISAM数据表" class="headerlink" title="MyISAM数据表"></a>MyISAM数据表</h4><p>MyISAM数据表类型的特点是成熟、稳定和易于管理。</p>
<h4 id="InnoDB数据表"><a href="#InnoDB数据表" class="headerlink" title="InnoDB数据表"></a>InnoDB数据表</h4><p>InnoDB给MySQL提供了具有提交，回滚和崩溃恢复能力的事务安全存储引擎。</p>
<h4 id="MyISAM和InnoDB两个表的功能简单对比"><a href="#MyISAM和InnoDB两个表的功能简单对比" class="headerlink" title="MyISAM和InnoDB两个表的功能简单对比"></a>MyISAM和InnoDB两个表的功能简单对比</h4><table>
<thead>
<tr>
<th>表类型功能对比</th>
<th style="text-align:left">MyISAM表</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务处理</td>
<td style="text-align:left">不支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据行锁定</td>
<td style="text-align:left">不支持，只有表锁定</td>
<td>支持</td>
</tr>
<tr>
<td>外键约束</td>
<td style="text-align:left">不支持</td>
<td>支持</td>
</tr>
<tr>
<td>表空间大小</td>
<td style="text-align:left">相对小</td>
<td>相对大，最大是2倍</td>
</tr>
<tr>
<td>全文索引</td>
<td style="text-align:left">支持</td>
<td>不支持</td>
</tr>
<tr>
<td>COUNT问题</td>
<td style="text-align:left">无</td>
<td>执行COUNT(*)查询，速度慢</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE t(i INT) ENGINE = INNODB;				#新建表t时指定表类型为INNODB</div><div class="line">CREATE TABLE t(i INT) TYPE = MYISAM;				#新建表t时指定表类型为MYISAM</div></pre></td></tr></table></figure>
<h3 id="数据表的默认字符集"><a href="#数据表的默认字符集" class="headerlink" title="数据表的默认字符集"></a>数据表的默认字符集</h3><p>使用CREATE TABLE命令创建数据表时，如果没有明确地指定任何字符集，则新创建数据库的字符集将由MySQL配置文件里character-set-server选项的设置决定。在MySQL配置文件（Linux系统为/etc/my.cnf文件，Windows系统则是my.ini文件）里设置数据表的字符集。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">character-set-server = gbk		#设置MySQL服务器的字符集</div><div class="line">collation-server	= gbk_chinese_ci		#设置排序方法</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CREATE DATABASE IF NOT EXISTS mydb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</div><div class="line">#为新创建的数据库mydb设置默认的字符集</div></pre></td></tr></table></figure>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>在MySQL中主要有四类索引：主键索引（PRIMARY KEY）、唯一索引（UNIQUE）、常规索引（INDEX）和全文索引（FULLTEXT）。</p>
<h4 id="主键索引（PRIMARY-KEY）"><a href="#主键索引（PRIMARY-KEY）" class="headerlink" title="主键索引（PRIMARY KEY）"></a>主键索引（PRIMARY KEY）</h4><p>主键索引是关系数据库中最常见的索引类型，主要作用是确定数据表里一条特定的数据记录的位置。数据表会根据主键的唯一性来唯一标识每条记录，使用任意两条记录里的主键字段不允许是同样的内容，这样可以加快寻址定位时的速度。最好为每张数据表指定一个主键，但一个表只能指定一个主键，而且主键的值不能为空，不过可以有多个候选索引。</p>
<h4 id="唯一索引（UNIQUE）"><a href="#唯一索引（UNIQUE）" class="headerlink" title="唯一索引（UNIQUE）"></a>唯一索引（UNIQUE）</h4><p>唯一索引与主键索引一样，都可以防止创建重复的值。但是，不同之处在于，每个数据表中只能有一个主键索引，但可以有多个唯一索引。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该使用关键字UNIQUE把它定义为一个唯一索引。</p>
<h4 id="常规索引（INDEX）"><a href="#常规索引（INDEX）" class="headerlink" title="常规索引（INDEX）"></a>常规索引（INDEX）</h4><p>创建常规索引可以使用关键字KEY或INDEX随表一同创建，KEY通常是INDEX同义词。也可以在创建表之后CREATE INDEX或ALTER TABLE命令来创建。<br>如果在创建表时没有创建索引，就需要使用CREATE INDEX命令来创建同样的常规索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX ind ON carts(userId,bookId）;			#创建名称为ind的索引为carts表的两个列</div></pre></td></tr></table></figure></p>
<h4 id="全文索引（FULLTEXT）"><a href="#全文索引（FULLTEXT）" class="headerlink" title="全文索引（FULLTEXT）"></a>全文索引（FULLTEXT）</h4><p>全文索引在MySQL中是一个FULLTEXT类型索引，但FULLTEXT索引只能用于MyISAM表，并且只可以在CHAR、VARCHAR或TEXT类型的列上创建，也允许创建在一个或多个数据列上。</p>
<h2 id="SQL语言设计"><a href="#SQL语言设计" class="headerlink" title="SQL语言设计"></a>SQL语言设计</h2><h3 id="使用DML命令操作数据表中的数据记录"><a href="#使用DML命令操作数据表中的数据记录" class="headerlink" title="使用DML命令操作数据表中的数据记录"></a>使用DML命令操作数据表中的数据记录</h3><p>为了修改数据库中的数据，SQL的数据操纵语言（DML）提供了增（INSERT）、删（DELETE）、改（UPDATE）语句。</p>
<h4 id="使用INSERT语句想数据表中添加数据"><a href="#使用INSERT语句想数据表中添加数据" class="headerlink" title="使用INSERT语句想数据表中添加数据"></a>使用INSERT语句想数据表中添加数据</h4><p>插入数据是向已经存在的数据表中添加一条新的记录，应该使用INSERT INTO语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INSERT INTO 表名 [(字段名1,字段名2,...,字段名n] VALUES(&apos;值1&apos;,&apos;值2&apos;,...,&apos;值n&apos;);</div></pre></td></tr></table></figure></p>
<p>在表名后面的括号中是该表中定义的字段名称列表，它们与VALUES子句后面的表达式列表的值是一一对应的，个数也要相等，并且表达式值的类型必须与字段的类型一致。需要用逗号将各个数据分开，字符型数据要用单引号括起来。INSERT语句也可以省略字段列表，但必须插入一行完整的数据，而且必须按表中定义的字段顺序为全部字段提供值。</p>
<h4 id="使用UPDATE语句更新数据表中已存在的数据"><a href="#使用UPDATE语句更新数据表中已存在的数据" class="headerlink" title="使用UPDATE语句更新数据表中已存在的数据"></a>使用UPDATE语句更新数据表中已存在的数据</h4><p>SQL语句可以使用UPDATE语句对表中的一列或多列数据进行修改，必须指定需要修改的字段，以及需要赋予的新值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UPDATE 表名				#需要给出被修改的表格</div><div class="line">SET 字段名=表达式[, .....]			#可以对表中一列或多列数据进行修改</div><div class="line">[WHERE 条件];					#给出必要的WHERE子名指定要更新的数据行</div></pre></td></tr></table></figure></p>
<p>其中的WHERE子句是必需的，如果不使用WHERE检索条件，则UPDATE语句会将数据表中全部数据行都修改。</p>
<h4 id="使用DELETE语句删除数据表中不需要的数据记录"><a href="#使用DELETE语句删除数据表中不需要的数据记录" class="headerlink" title="使用DELETE语句删除数据表中不需要的数据记录"></a>使用DELETE语句删除数据表中不需要的数据记录</h4><p>使用DELETE语句用来删除数据表中的一条或多条数据记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE FROM 表名 [WHERE 条件];			#删除表中记录行的DELETE语法格式</div></pre></td></tr></table></figure></p>
<p>如果没有指定WHERE子句的检索条件，DELETE语句将会删除数据表中的全部数据记录，使用数据库中只剩下数据表结构。</p>
<h3 id="通过DQL命令查询数据表中的数据"><a href="#通过DQL命令查询数据表中的数据" class="headerlink" title="通过DQL命令查询数据表中的数据"></a>通过DQL命令查询数据表中的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT [ALL|DISTINCT]				#使用SELECT语句查询检索</div><div class="line">&#123;*|table.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,...]]&#125;				#选择哪些数据列</div><div class="line">FROM tableexpression[,...][IN externaldatabase]				#指定SELECT语句中字段的来源</div><div class="line">[WHERE...]			#数据行必须满足哪些检索条件</div><div class="line">[GROUP BY...]			#指明按照哪几字段来分组</div><div class="line">[HAVING...]			#过滤分组的记录，必须满足的次要条件</div><div class="line">[ORDER BY...]			#按一个或多个字段排序查询结果</div><div class="line">[LIMIT count];			#对结构个数限制</div></pre></td></tr></table></figure>
<p>用中括号“[]”括起来的部分表示是可选的，用大括号“{}”括起来的部分是标识必须从中选择其中的一个。FROM子句指定了SELECT语句中字段的来源，FROM子句后面是包含一个或多个的表达式（由逗号分开），其中的表达式可为单一表名称、已保存的查询或由INNER JOIN、LEFT JOIN或RIGHT JOIN得到的复合结果。</p>
<h4 id="选择特定的字段"><a href="#选择特定的字段" class="headerlink" title="选择特定的字段"></a>选择特定的字段</h4><p>使用SELECT语句检索记录的特定字段，多个字段可以用逗号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT field1,field2 FROM table1;</div></pre></td></tr></table></figure></p>
<p>可以使用“<em>”从表中检索出所有字段，使用“SELECT</em>”主要是针对用户的书写方便而言。对于不同的数据表，这个操作可将表中每一行、列的数据全部检索出来。</p>
<h4 id="使用AS子句为字段取别名"><a href="#使用AS子句为字段取别名" class="headerlink" title="使用AS子句为字段取别名"></a>使用AS子句为字段取别名</h4><p>如果想为返回的列取一个新的标题，以及经过对字段的计算或总结之后，产生了一个新的值，希望把它放到一个新的列里显示，则用AS保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT Name as &apos;名称&apos;,author as &apos;作者&apos;,price as &apos;价格&apos;FROM tables;</div></pre></td></tr></table></figure></p>
<p>定义别名时一定要使用单引号引起来。其中AS关键字是可选的，在原字段名和别名之间使用一个空格即可。<br>在有多个表关联查询的情况下，如果表中有同名的字段时，则必须使用别名加以区分。</p>
<h4 id="DISTINCT关键字的使用"><a href="#DISTINCT关键字的使用" class="headerlink" title="DISTINCT关键字的使用"></a>DISTINCT关键字的使用</h4><p>在使用SELECT语句返回的记录结构中包含重复的记录，可以使用DISTINCT关键字取消重复的数据，只返回一个。DISTINCT关键字的作用范围是整个查询的列表，而不是单独的一列。同时对两列数据进行查询时，使用了DISTINCT关键字，将返回这两列数据的唯一组合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT idFROM table;			#取消id列中重复的数据。</div></pre></td></tr></table></figure></p>
<p>使用DISTINCT关键字可以返回简单、明了的数据，但服务器必须话费更多的时间去执行对查询结果的分类和整理。与DISTINCT相对应的是ALL关键字，用于返回满足SELECT语句条件的所有记录。</p>
<h4 id="在SELECT语句中使用表达式的列"><a href="#在SELECT语句中使用表达式的列" class="headerlink" title="在SELECT语句中使用表达式的列"></a>在SELECT语句中使用表达式的列</h4><p>在SQL语句中，表达式可用于一些诸如SELECT语句的ORDER BY或HAVING子句、SELECT、DELETE或UPDATE语句的WHERE子句或SET语句之类的地方。使用文本值、column值、NULL值、函数、操作符来书写表达式。主要包括算术表达式、逻辑表达式，以及使用SQL函数表达式。<br>在SELECT语句中使用表达式重新对数据列进行计算。</p>
<h4 id="使用WHERE子句按条件检索"><a href="#使用WHERE子句按条件检索" class="headerlink" title="使用WHERE子句按条件检索"></a>使用WHERE子句按条件检索</h4><p>在SELECT语句中，可以使用WHERE子句指定搜索条件，实现从数据表中检索出符合条件的记录。其中，搜索条件可以由一个或多个逻辑表达式组成，这些表达式指定关于某一记录是真或假的条件。在WHERE子句中，可以通过逻辑操作符和比较操作符和比较操作符指定基本的表达式条件。</p>
<h5 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h5><table>
<thead>
<tr>
<th>操作符</th>
<th style="text-align:left">语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND或&amp;&amp;</td>
<td style="text-align:left">a AND b或a &amp;&amp; b</td>
<td>逻辑与</td>
</tr>
<tr>
<td>OR或//</td>
<td style="text-align:left">a OR b或a // b</td>
<td>逻辑或</td>
</tr>
<tr>
<td>XOR</td>
<td style="text-align:left">a XOR b</td>
<td>逻辑异或</td>
</tr>
<tr>
<td>NOT或！</td>
<td style="text-align:left">NOT a或！a</td>
<td>逻辑非</td>
</tr>
</tbody>
</table>
<h5 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h5><table>
<thead>
<tr>
<th>操作符</th>
<th style="text-align:left">语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS NULL</td>
<td style="text-align:left">a IS NULL</td>
<td>若操作数a为NULL，则为真</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td style="text-align:left">a IS NOT NULL</td>
<td>若操作数a不为NULL，则为真</td>
</tr>
<tr>
<td>BETWEEN</td>
<td style="text-align:left">a BETWEEN b AND c</td>
<td>若a在b和c之间（包括b和c），则为真</td>
</tr>
<tr>
<td>NOT BETWEEN</td>
<td style="text-align:left">a NOT BETWEEN b AND c</td>
<td>若a不在b和c之间（包括b和c），则为真</td>
</tr>
<tr>
<td>LIKE</td>
<td style="text-align:left">a LIKE b</td>
<td>SQL模式匹配，若a匹配b，则为真</td>
</tr>
<tr>
<td>NOT LIKE</td>
<td style="text-align:left">a NOT LIKE b</td>
<td>SQL模式匹配，若a不匹配b，则为真</td>
</tr>
<tr>
<td>IN</td>
<td style="text-align:left">a IN(b1,b2,b3,…)</td>
<td>若a等于b1,b2,b3,…中的某一个，则为真</td>
</tr>
</tbody>
</table>
<h4 id="根据空值（NULL）确定检索条件"><a href="#根据空值（NULL）确定检索条件" class="headerlink" title="根据空值（NULL）确定检索条件"></a>根据空值（NULL）确定检索条件</h4><p>空值只能定义在允许NULL字段中出现，NULL值是特殊的值，代表“无值”，与0和空字符串（”）都不相同。当在不支持默认值的字段中未输入值，或在字段中显式的设置为空，就会出现空值，但不能用处理已知值的方式来出来NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT*FROM books WHERE detail IS NOT NULL;		#查找不为空的数据</div></pre></td></tr></table></figure></p>
<h4 id="使用BETWEEN-AND进行范围比较查询"><a href="#使用BETWEEN-AND进行范围比较查询" class="headerlink" title="使用BETWEEN AND进行范围比较查询"></a>使用BETWEEN AND进行范围比较查询</h4><p>需要对某个字段通过范围的值进行比较查询，可以使用BETWEEN AND关键字实现，其中AND是多重条件符号，比较时也包括边界条件。也可以使用”&gt;=”和”=&lt;”完成相同的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT name,price FROM books WHERE price BETWEEN 30 AND 80;</div><div class="line">SELECT name,price FROM books WHERE price &gt;= 30 AND price &lt;=80;</div></pre></td></tr></table></figure></p>
<h4 id="使用IN进行范围比较查询"><a href="#使用IN进行范围比较查询" class="headerlink" title="使用IN进行范围比较查询"></a>使用IN进行范围比较查询</h4><p>在WHERE子句中，使用IN关键字并在后面的括号”（）”中提供一个值的列表，以供与相应的字段进行比较。该列表中至少应该存在一个值，如果有多个值可以使用逗号”，”分隔。</p>
<h4 id="使用LIKE进行模糊查询"><a href="#使用LIKE进行模糊查询" class="headerlink" title="使用LIKE进行模糊查询"></a>使用LIKE进行模糊查询</h4><p>在SELECT语句的WHERE子句中，可以使用LIKE关键字对数据表中的记录进行模糊查询，将查询结果锁定在一个范围内。在查询条件中通常会与”_”和”%”两个通配符一起使用，可以实现复制的检索查询。</p>
<ul>
<li>百分号”%”：表示0个或任意多个字符。</li>
<li>下划线”_”：表示单个的任意一个字符。</li>
</ul>
<h4 id="多表查询（连接查询）"><a href="#多表查询（连接查询）" class="headerlink" title="多表查询（连接查询）"></a>多表查询（连接查询）</h4><ul>
<li>非等值和等值的多表查询<br>多表查询和普通的单表查询相似，都是使用SELECT语句。只不过在多表查询时需要把多张表的名字，全部填写在FROM子句中，并用逗号”，”将表名分开。同时，也可以对数据表使用别名进行引用。为了在查询时区分多个表中出现的重复字段名，可以在字段列表中使用”表名.列名”的形式，如果不存在重名的列，可以省略表名。</li>
<li>自身连接查询<br>连接查询操作不仅可以用于多个表之间，也可以是一个表与其自己进行拼接，称为自身连接查询。当一个表所代表的实体之间有关系时，就可以使用自身连接查询。</li>
<li>复合连接查询<br>在FROM子句后面有n个表需要查询，则在WHERE子句中就需要有多个连接条件。至少要比出现的表格数量少一个，也就是不能少于n-1个查询条件，多个条件使用”AND”关键词连接即可。</li>
</ul>
<h4 id="嵌套查询（子查询）"><a href="#嵌套查询（子查询）" class="headerlink" title="嵌套查询（子查询）"></a>嵌套查询（子查询）</h4><p>嵌套查询是在一个SELECT语句的WHERE子句中，包含另一个SELECT语句，也可以称为子查询。在子查询中只能返回一列，并将形成的结果又作为父查询的条件，在主句中进行一布查询。SQL允许多层嵌套查询，嵌套查询的求解方法是由里向外处理，即每个子查询都是在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</p>
<h4 id="使用ORDER-BY对查询结果排序"><a href="#使用ORDER-BY对查询结果排序" class="headerlink" title="使用ORDER BY对查询结果排序"></a>使用ORDER BY对查询结果排序</h4><p>在SELECT语句中使用ORDER BY子句，对检索的结果进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT id,name FROM books ORDER BY id DESC;</div></pre></td></tr></table></figure></p>
<p>ORDER BY后面可以接一列或多列用于排序的字段，并且使用DESC或ASC关键字设计字段排序的方式。默认情况下按照升序排列，即使用ASC关键字。否则要按照降序排列，必须使用DESC关键字。ORDER BY子句可以和SELECT语句中的其他子句一起使用，但在子查询中不能哟ORDER BY子句，因为ORDER BY子句只能对最终查询结果排序。</p>
<h4 id="使用LIMIT限定结构行数"><a href="#使用LIMIT限定结构行数" class="headerlink" title="使用LIMIT限定结构行数"></a>使用LIMIT限定结构行数</h4><p>LIMIT子句可以和其他的SELECT子句一起使用，它可以指定两个参数，分别用以设置返回记录的起始位置，和返回记录的数量。</p>
<h4 id="使用统计函数"><a href="#使用统计函数" class="headerlink" title="使用统计函数"></a>使用统计函数</h4><table>
<thead>
<tr>
<th>统计函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT()</td>
<td style="text-align:left">返回满足SELECT语句中指定条件的记录数，例如，COUNT（*）返回找到的记录行数</td>
</tr>
<tr>
<td>SUM()</td>
<td style="text-align:left">通常为数值字段或表达列作统计，返回一列的总和</td>
</tr>
<tr>
<td>AVG()</td>
<td style="text-align:left">通常为数值字段或表达列作统计，返回一列的平均值</td>
</tr>
<tr>
<td>MAX()</td>
<td style="text-align:left">可以为数值字段、字符字段或表达列作统计，返回一列中最大的值</td>
</tr>
<tr>
<td>MIN()</td>
<td style="text-align:left">可以为数值字段、字符字段或表达列统计，返回一列中最小的值</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT 函数名 （列名1或*）, ...函数名 （列名n） FROM 表名;		#使用统计函数</div></pre></td></tr></table></figure>
<h4 id="使用GROUP-BY对查询结构分组"><a href="#使用GROUP-BY对查询结构分组" class="headerlink" title="使用GROUP BY对查询结构分组"></a>使用GROUP BY对查询结构分组</h4><p>GROUP BY子句将表按列值分组，列的值相同的分为一组。如果GROUP BY后面有多个列名，则先按第一个列名分组，再在每组中按第二个列名分组。</p>
<h2 id="使用PHP脚本向MySQL服务器发送SQL"><a href="#使用PHP脚本向MySQL服务器发送SQL" class="headerlink" title="使用PHP脚本向MySQL服务器发送SQL"></a>使用PHP脚本向MySQL服务器发送SQL</h2><h3 id="在PHP脚本中连接MySQL服务器"><a href="#在PHP脚本中连接MySQL服务器" class="headerlink" title="在PHP脚本中连接MySQL服务器"></a>在PHP脚本中连接MySQL服务器</h3><p>PHP可以通过MySQL功能模块去连接MySQL服务器，办法是调用mysql_connect()函数，和使用MySQL客户机程序连接MySQL服务器类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resource mysql_connect([string server[,string username[,string password[,bool new_link[,int client_flags]]]]])</div></pre></td></tr></table></figure></p>
<p>通常只要提供前三个参数即可，包括MySQL服务器的主机名、MySQL用户名和密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;mysql_pass&quot;);			//使用PHP程序连接MySQL服务器</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    $link=mysql_connect(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_password&quot;) or die(&quot;连接失败: &quot;.mysql_error());</div><div class="line">    echo &quot;与MySQL服务器建立的连接成功:&lt;br&gt;&quot;;          //连接成功则会输出这条提示信息</div><div class="line">    echo mysql_get_client_info();                          //客户端API函数库的版本信息</div><div class="line">    echo mysql_get_host_info();                           //与MySQL服务器的连接类型</div><div class="line">    echo mysql_get_proto_info();                          //通信协议的版本信息</div><div class="line">    echo mysql_get_server_info();                         //MySQL服务器的版本信息</div><div class="line">    echo mysql_client_encoding();                         //客户端使用的默认字符集</div><div class="line">    echo mysql_stat();                                   //MySQL服务器的当前工作状态</div><div class="line">    mysql_close($link);                                  //关闭与MySQL服务器建立的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="在PHP程序中选择已创建的数据库"><a href="#在PHP程序中选择已创建的数据库" class="headerlink" title="在PHP程序中选择已创建的数据库"></a>在PHP程序中选择已创建的数据库</h3><p>为了避免每次调用PHP的mysql扩展函数时都指定目录数据库，最好先用mysql_select_db()函数为后续操作选定一个默认数据库，这个函数和SQL命令“USE bookstore”功能相似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$link=mysql_connect(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_password&quot;) or die(&quot;连接失败: &quot;.mysql_error());</div><div class="line">	mysql_select_db(&apos;bookstore&apos;,$link)or die(&apos;不能选定数据库：&apos;.mysql_error());</div><div class="line">	mysql_close($link);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="执行SQL命令"><a href="#执行SQL命令" class="headerlink" title="执行SQL命令"></a>执行SQL命令</h3><p>在PHP脚本中，只要把SQL命令作为一个字符串传递给mysql_query函数，就会将其发送到MySQL服务器中并执行。如果想访问的不是当前数据库，就需要调用mysql_db_query()函数来执行SQL命令并明确地给出数据库的名字。这两个函数的最后一个参数都是可选的，即mysql_connect()函数返回的连接标识号，只要在与同一个MySQL服务器建立多条连接的时候才必须给出这个参数。<br>mysql_query()函数可以用来执行DDL、DML、DQL及DCL等任何一种SQL命令，如果想执行一条以上的SQL命令，就需要为它们分别调用一次mysql_query()函数。如果SQL命令执行成功，mysql_query()函数将返回一个非0值。如果没有执行不成功，该函数将返回FALSE（即数值0），并会生成一条出错信息，出错原因可以利用mysql_errno()和mysql_error()函数来确定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    $link=mysql_connect(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_pass&quot;) or die(&quot;连接失败: &quot;.mysql_error());</div><div class="line">    //为后续的mysql扩展函数的操作选定一个默认的数据库，它相当于SQL命令use bookstore</div><div class="line">    mysql_select_db(&apos;bookstore&apos;) or die (&apos;不能选定数据库 bookstore : &apos; . mysql_error());</div><div class="line">   </div><div class="line">    //将插入3条的INSERT语句声明为一个字符串 </div><div class="line">    $insert=&quot;INSERT INTO books(bookName, publisher, author, price, detail) VALUES</div><div class="line">	    (&apos;PHP&apos;, &apos;电子工业&apos;, &apos;高某某&apos;, &apos;80.00&apos;, &apos;与PHP相关的图书&apos;),</div><div class="line">	    (&apos;JSP&apos;, &apos;人民邮电&apos;, &apos;洛某某&apos;, &apos;50.00&apos;, &apos;与JSP相关的图书&apos;),</div><div class="line">	    (&apos;ASP&apos;, &apos;电子工业&apos;, &apos;峰某某&apos;, &apos;30.00&apos;, &apos;与ASP相关的图书&apos;)&quot;;</div><div class="line"></div><div class="line">    //使用mysql_query()函数发送INSERT语句，如果成功返回TRUE，失败则返回FALSE</div><div class="line">    $result=mysql_query($insert);          </div><div class="line">    if($result &amp;&amp; mysql_affected_rows()&gt;0)&#123;</div><div class="line">	    echo &quot;数据记录插入成功，最后一条插入的数据记录ID为：&quot;.mysql_insert_id().&quot;&lt;br&gt;&quot;;</div><div class="line">    &#125;else&#123;</div><div class="line">	    echo &quot;插入记录失败，错误号：&quot;.mysql_errno().&quot;，错误原因：&quot;.mysql_error().&quot;&lt;br&gt;&quot;;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    //执行UPDATE命令修改表books中的一条记录，将图书名为PHP的记录价格修改为79.90</div><div class="line">    $result1=mysql_query(&quot;UPDATE books SET price=&apos;79.9&apos; WHERE bookName=&apos;PHP&apos;&quot;);</div><div class="line">    if($result1 &amp;&amp; mysql_affected_rows()&gt;0)&#123;</div><div class="line">	    echo &quot;数据记录修改成功&lt;br&gt;&quot;;</div><div class="line">    &#125;else&#123;</div><div class="line">	    echo &quot;修改数据失败，错误号：&quot;.mysql_errno().&quot;，错误原因：&quot;.mysql_error().&quot;&lt;br&gt;&quot;;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    //执行DELETE命令删除表books中图书名为JSP的记录</div><div class="line">    $result2=mysql_query(&quot;DELETE FROM books WHERE bookName=&apos;JSP&apos;&quot;);</div><div class="line">    if($result2 &amp;&amp; mysql_affected_rows()&gt;0)&#123;</div><div class="line">	    echo &quot;数据记录删除成功&lt;br&gt;&quot;;</div><div class="line">    &#125;else&#123;</div><div class="line">	    echo &quot;删除数据失败，错误号：&quot;.mysql_errno().&quot;，错误原因：&quot;.mysql_error().&quot;&lt;br&gt;&quot;;</div><div class="line">    &#125;</div><div class="line">    mysql_close($link);                               //关闭与MySQL服务器建立的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="在PHP脚本中处理SELECT查询结果集"><a href="#在PHP脚本中处理SELECT查询结果集" class="headerlink" title="在PHP脚本中处理SELECT查询结果集"></a>在PHP脚本中处理SELECT查询结果集</h3><p>在PHP脚本中执行SELECT查询命令，也是调用mysql_query()函数，但和执行DML不同的是，执行SELECT命令之后mysql_query()函数的返回值是一个PHP资源的引用指针（结果集）。这个返回值可以用在各种结果集处理函数中，对结果数据包的各个字段进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$result=mysql_query(&quot;SELECT * FROM books&quot;);			//执行SELECT语句返回结果集资源$result</div><div class="line">$rows=mysql_num_rows($result);			//从结果几种获得数据记录行的个数</div><div class="line">$cols=mysql_num_fields($result);		//从结果中获得数据记录列的个数</div></pre></td></tr></table></figure></p>
<ul>
<li>mysql_fetch_row():该函数将一条结构记录返回并以一个普通索引数组的形式保存。</li>
<li>mysql_fetch_assoc():该函数将一条结果记录返回并以一个普通关联数组的形式保存。</li>
<li>mysql_fetch_array():该函数可以将结果数据表中的每一行获取为一个关联数组或索引数组，或者同时获取为关联和索引数组。可以通过为该函数传递MYSQL_ASSOC、MYSQL_NUM或MYSQL_BOTH中的一个常量返回不同的数组形态，默认使用MYSQL_BOTH常量将两种数组一起返回。</li>
<li>mysql_fetch_object():该函数将以一个对象的形式返回一条结果记录，它的各个字段需要以对象的方式进行访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    $link=mysql_connect(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_pass&quot;) or die(&quot;连接失败: &quot;.mysql_error());</div><div class="line">    mysql_select_db(&apos;bookstore&apos;) or die (&apos;不能选定数据库 bookstore : &apos; . mysql_error());</div><div class="line">   </div><div class="line">    //执行DQL命令返回结果集$result</div><div class="line">    $result=mysql_query(&quot;select bookId, bookName, author, publisher,price,detail from books&quot;);           </div><div class="line">    echo &apos;&lt;table align=&quot;center&quot; width=&quot;80%&quot; border=&quot;1&quot;&gt;&apos;;   //以HTML表格输出结果</div><div class="line">    echo &apos;&lt;caption&gt;&lt;h1&gt;图书信息表&lt;/h1&gt;&lt;/caption&gt;&apos;;      //输出表格标题</div><div class="line">    echo &apos;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;图书名&lt;/th&gt;&lt;th&gt;作者&lt;/th&gt;&lt;th&gt;出版社&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt;&lt;th&gt;介绍&lt;/th&gt;&apos;;</div><div class="line">    while($row=mysql_fetch_row($result))&#123;               //循环从结果集中遍历每条记录到数组中</div><div class="line">	    echo &apos;&lt;tr&gt;&apos;;                                  //每遍历一条记录输出一个行标记</div><div class="line">	    foreach($row as $data)&#123;                        //循环遍历一条数据记录中的每个字段</div><div class="line">	    	      echo &apos;&lt;td&gt;&apos;.$data.&apos;&lt;/td&gt;&apos;;                 //以表格形式输出每个字段</div><div class="line">	    &#125;</div><div class="line">	    echo &apos;&lt;/tr&gt;&apos;;                                  //输出每行的结束标记</div><div class="line">    &#125;</div><div class="line">    echo &apos;&lt;/table&gt;&apos;;</div><div class="line">    mysql_free_result($result);                          //释放查询的结果集资源</div><div class="line">    mysql_close($link);                                //关闭与MySQL服务器建立的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h1 id="PHP的mysqli扩展"><a href="#PHP的mysqli扩展" class="headerlink" title="PHP的mysqli扩展"></a>PHP的mysqli扩展</h1><h2 id="启用mysqli扩展模块"><a href="#启用mysqli扩展模块" class="headerlink" title="启用mysqli扩展模块"></a>启用mysqli扩展模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension=php_mysqli.dll			//在php.ini文件中启动这一行</div></pre></td></tr></table></figure>
<p>mysqli扩展不仅提供了mysql模块的所有功能，也相应地增加了一些新特征。mysqli扩展模块包括mysqli、mysqli_result和mysqli_stmt三个类，通过这三个类的使用，就可以连接MySQL数据库服务器和选择数据库、查询和获取数据，以及使用预处理语句简化了重复执行的查询语句。</p>
<h2 id="使用mysqli类"><a href="#使用mysqli类" class="headerlink" title="使用mysqli类"></a>使用mysqli类</h2><h3 id="mysqli类中的成员方法"><a href="#mysqli类中的成员方法" class="headerlink" title="mysqli类中的成员方法"></a>mysqli类中的成员方法</h3><table>
<thead>
<tr>
<th>成员方法名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>_construct()</td>
<td style="text-align:left">构造方法，用于创建一个新的mysqli对象，也可以建立一个连接</td>
</tr>
<tr>
<td>autocommit()</td>
<td style="text-align:left">开启或关闭数据库修改自动提交</td>
</tr>
<tr>
<td>change_user</td>
<td style="text-align:left">改变了数据库连接所指定的用户</td>
</tr>
<tr>
<td>caracter_set_name()</td>
<td style="text-align:left">返回数据库连接默认的字符集</td>
</tr>
<tr>
<td>close()</td>
<td style="text-align:left">关闭先前打开连接</td>
</tr>
<tr>
<td>commit()</td>
<td style="text-align:left">提交当前的事务</td>
</tr>
<tr>
<td>connect()</td>
<td style="text-align:left">打开一个新的连接到MySQL数据库服务器</td>
</tr>
<tr>
<td>debug()</td>
<td style="text-align:left">执行调试操作</td>
</tr>
<tr>
<td>dump_debug_info()</td>
<td style="text-align:left">转储调试信息</td>
</tr>
<tr>
<td>get_client_info()</td>
<td style="text-align:left">返回客户端版本</td>
</tr>
<tr>
<td>get_host_info()</td>
<td style="text-align:left">返回一个字符串代表的连接使用类型，如：Localhost via UNIX socket</td>
</tr>
<tr>
<td>get_server_info()</td>
<td style="text-align:left">返回MySQL服务器的版本</td>
</tr>
<tr>
<td>get_server_version()</td>
<td style="text-align:left">返回整数形式的MySQL服务器版本</td>
</tr>
<tr>
<td>init()</td>
<td style="text-align:left">初始化MySQLi并返回一个资源</td>
</tr>
<tr>
<td>info()</td>
<td style="text-align:left">检索有关最近执行的查询</td>
</tr>
<tr>
<td>kill()</td>
<td style="text-align:left">要求服务器去杀死一个MySQL线程</td>
</tr>
<tr>
<td>multi_query()</td>
<td style="text-align:left">执行多个查询语句</td>
</tr>
<tr>
<td>more_results()</td>
<td style="text-align:left">从多查询语句中检查是否有任何更多的查询结果</td>
</tr>
<tr>
<td>Next_result()</td>
<td style="text-align:left">从当前执行的多查询中读取下一个结果</td>
</tr>
<tr>
<td>options()</td>
<td style="text-align:left">设置选项</td>
</tr>
<tr>
<td>ping()</td>
<td style="text-align:left">如果没有连接，ping一台服务器连接或重新连接</td>
</tr>
<tr>
<td>prepare()</td>
<td style="text-align:left">准备一个SQL语句的执行，返回mysqli_stmt对象</td>
</tr>
<tr>
<td>query()</td>
<td style="text-align:left">与数据库的任何交互都是通过查询进行的，该方法向数据库发送查询来执行</td>
</tr>
<tr>
<td>real_connect()</td>
<td style="text-align:left">试图打开一个连接到MySQL数据库服务器</td>
</tr>
<tr>
<td>escape_string()</td>
<td style="text-align:left">转义特殊字符的字符串，用于在一个SQL语句，并考虑到当前的字符集的连接</td>
</tr>
<tr>
<td>rollback()</td>
<td style="text-align:left">回滚当前的事务</td>
</tr>
<tr>
<td>select_db()</td>
<td style="text-align:left">为数据库查询选择默认的数据库</td>
</tr>
<tr>
<td>set_charset()</td>
<td style="text-align:left">设置默认客户端字符集</td>
</tr>
<tr>
<td>ssl_set()</td>
<td style="text-align:left">使用SSL用于建立安全连接</td>
</tr>
<tr>
<td>stat()</td>
<td style="text-align:left">获取当前的系统状态</td>
</tr>
<tr>
<td>stmt_init()</td>
<td style="text-align:left">初始化一个声明，并返回一个mysqli_stmt对象</td>
</tr>
<tr>
<td>store_result()</td>
<td style="text-align:left">从最后查询中转让结果集</td>
</tr>
<tr>
<td>thread_safe()</td>
<td style="text-align:left">是否考虑返回安全的线程</td>
</tr>
</tbody>
</table>
<h3 id="mysqli类中的成员属性"><a href="#mysqli类中的成员属性" class="headerlink" title="mysqli类中的成员属性"></a>mysqli类中的成员属性</h3><table>
<thead>
<tr>
<th>成员属性名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$affect_rows</td>
<td style="text-align:left">在前一个MySQL操作中获取影响的行数</td>
</tr>
<tr>
<td>$client_info</td>
<td style="text-align:left">MySQL客户端版本为一个字符串返回</td>
</tr>
<tr>
<td>$client_version</td>
<td style="text-align:left">MySQL客户端版本为一个整数返回</td>
</tr>
<tr>
<td>$errno</td>
<td style="text-align:left">返回最近函数调用的错误代码</td>
</tr>
<tr>
<td>$error</td>
<td style="text-align:left">返回最近函数调用的错误信息字符串</td>
</tr>
<tr>
<td>$field_count</td>
<td style="text-align:left">传回最近查询获取的列数</td>
</tr>
<tr>
<td>$host_info</td>
<td style="text-align:left">返回一个字符串的连接类型使用</td>
</tr>
<tr>
<td>$info</td>
<td style="text-align:left">检索有关最近执行的查询</td>
</tr>
<tr>
<td>$insert_id</td>
<td style="text-align:left">返回使用最后查询自动生成的编号</td>
</tr>
<tr>
<td>$protocal_version</td>
<td style="text-align:left">返回MySQL协议使用的版本</td>
</tr>
<tr>
<td>$sqlstate</td>
<td style="text-align:left">返回一个字符串包含SQLSTATE错误码的最后一个错</td>
</tr>
<tr>
<td>$thread_id</td>
<td style="text-align:left">为当前连接返回线程ID</td>
</tr>
<tr>
<td>$warning_count</td>
<td style="text-align:left">返回前一个SQL语句执行过程中产生的警告数量</td>
</tr>
</tbody>
</table>
<h3 id="连接MySQL服务器"><a href="#连接MySQL服务器" class="headerlink" title="连接MySQL服务器"></a>连接MySQL服务器</h3><p>通过mysqli类的构造方法实例化对象，其构造方法的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class mysqli&#123;</div><div class="line">	__construct ([string host[,string username[,string passwd[,string dbname[,int port[,string socket]]]]]])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造方法还有两个可选的参数：MySQL服务器的端口号、一个套接字文件或命名管道。但是这两个可选参数很少使用。</p>
<p>如果连接成功，该构造方法将返回一个mysqli对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mysqli=new mysqli(&quot;localhost&quot;,&quot;mysql_user&quot;,&quot;mysql_pwd&quot;,&quot;mylib&quot;);		//连接MySQL数据库服务器</div></pre></td></tr></table></figure></p>
<p>如果在创建mysqli对象没有想构造方法传入连接参数，就需要多写几行代码，调用mysqli对象中的connect()方法连接MySQL数据库服务器，还可以使用select_db()方法特别指定数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php	</div><div class="line">	$mysqli=new mysqli();			//创建mysqli对象</div><div class="line">	$mysqli-&gt;connect(&quot;localhost&quot;,&quot;mysql_user&quot;,&quot;mysql_pwd&quot;);			//连接指定的MySQL数据库服务器</div><div class="line">	$mysqli-&gt;select_db(&quot;mylib&quot;);				//选择特定的数据库</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="处理连接错误报告"><a href="#处理连接错误报告" class="headerlink" title="处理连接错误报告"></a>处理连接错误报告</h3><p>在连接过程中难免会出现错误，应该及时让用户得到通知。在连接出错时mysqli对象并没有创建成功，所以不能调用mysqli对象中的成员获取这些错误信息，要通过mysqli扩展中的过程方式获取。使用mysqli_connect_errno()函数测试在建立连接的过程中是否发生错误，相关的出错信息由mysqli_connect_error()函数负责返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$mysqli=new mysqli(&quot;localhost&quot;,&quot;mysql_user&quot;,&quot;mysql_pwd&quot;,&quot;dbname&quot;);</div><div class="line">	/*	检查连接，如果连接出错输出错误信息并退出程序	*/</div><div class="line">	if(mysqli_connect_errno())&#123;</div><div class="line">		printf(&quot;连接失败：%s\n&quot;,mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="关闭与MySQL服务器连接"><a href="#关闭与MySQL服务器连接" class="headerlink" title="关闭与MySQL服务器连接"></a>关闭与MySQL服务器连接</h3><p>完成数据库访问工作，如果不再需要连接到数据库，应该明确地释放有关的mysqli对象。随意脚本执行结束后，所有打开的数据库连接都将自动关闭，资源被回收。但是，在执行过程中，又肯页面需要多个数据库连接，各个连接要在适当的时候将其关闭。mysqli对象中的close()方法负责关闭打开数据库连接，成功时返回TRUE，否则返回FALSE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">     	/* 连接MySQL数据库并，成功则返回mysqli 对象*/</div><div class="line">	$mysqli = new mysqli(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_pwd&quot;, &quot;mylib&quot;);</div><div class="line">	/* 检查连接，如果连接出错输出错误信息并退出程序 */ </div><div class="line">	if (mysqli_connect_errno()) &#123;</div><div class="line"> 		printf(&quot;连接失败: %s&lt;br&gt;&quot;, mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125;</div><div class="line">	/* 打印当前数据库使用字符集字符串 */</div><div class="line">	printf (&quot;当前数据库的字符集： %s&lt;br&gt;&quot;, $mysqli-&gt;character_set_name());</div><div class="line">	/* 打印客户端版本 */</div><div class="line">	printf(&quot;客户端库版本： %s&lt;br&gt;&quot;, $mysqli-&gt;get_client_info());</div><div class="line">	/* 打印服务器主机信息 */</div><div class="line">	printf(&quot;主机信息： %s&lt;br&gt;&quot;, $mysqli-&gt;host_info);</div><div class="line">	/* 打印字符串形式MySQL服务器版本 */</div><div class="line">	printf(&quot;服务器版本: %s&lt;br&gt;&quot;, $mysqli-&gt;server_info);</div><div class="line">	/*打印整数形式MySQL服务器版本*/</div><div class="line">	printf(&quot;服务器版本：%d&lt;br&gt;&quot;, $mysqli-&gt;server_version);</div><div class="line">	/* 关闭打开的数据库连接 */</div><div class="line">	$mysqli-&gt;close();	</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="执行SQL命令-1"><a href="#执行SQL命令-1" class="headerlink" title="执行SQL命令"></a>执行SQL命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;mylib&quot;);</div><div class="line">	if (mysqli_connect_errno()) &#123;</div><div class="line"> 		printf(&quot;连接失败: %s&lt;br&gt;&quot;, mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125;</div><div class="line">     	/* 执行SQL命令向表中插入一条记录，并获取改变的记录数和新ID值 */</div><div class="line">	if($mysqli-&gt;query(&quot;insert into 表名(列1, 列2) values (&apos;值1&apos;,&apos;值2&apos;)&quot;))&#123;</div><div class="line">		echo &quot;改变的记录数：&quot;.$mysqli-&gt;affected_rows.&quot;&lt;br&gt;&quot;;</div><div class="line">		echo &quot;新插入的ID值：&quot;.$mysqli-&gt;insert_id.&quot;&lt;br&gt;&quot;;</div><div class="line">	&#125;</div><div class="line">	$mysqli-&gt;close();	</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="使用mysqli-result类"><a href="#使用mysqli-result类" class="headerlink" title="使用mysqli_result类"></a>使用mysqli_result类</h2><table>
<thead>
<tr>
<th>成员方法名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>close()</td>
<td style="text-align:left">释放内存并关闭结果集</td>
</tr>
<tr>
<td>data_seek()</td>
<td style="text-align:left">明确改变当前结果记录顺序</td>
</tr>
<tr>
<td>fetch_field()</td>
<td style="text-align:left">从结果集中获得某一个字段的信息</td>
</tr>
<tr>
<td>fetch_fields()</td>
<td style="text-align:left">从结果集中获得全部字段的信息</td>
</tr>
<tr>
<td>fetch_field_direct()</td>
<td style="text-align:left">从一个指定的列中获得类的详细信息，返回一个包含列信息的对象</td>
</tr>
<tr>
<td>fetch_array()</td>
<td style="text-align:left">将以一个普通索引数组和关联数组两种形式返回一条结果记录</td>
</tr>
<tr>
<td>fetch_assoc()</td>
<td style="text-align:left">将以一个普通关联数组的形式返回一条结果记录</td>
</tr>
<tr>
<td>fetch_object()</td>
<td style="text-align:left">将以一个对象的形式返回一条结果记录</td>
</tr>
<tr>
<td>fetch_seek()</td>
<td style="text-align:left">设置结果集中字段的偏移位置</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>成员属性名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$current_field</td>
<td style="text-align:left">获取当前结果中指向的字段偏移位置，是一个整数</td>
</tr>
<tr>
<td>$field_count</td>
<td style="text-align:left">从查询的结果中获取列的个数</td>
</tr>
<tr>
<td>$lengths</td>
<td style="text-align:left">返回一个数组，保存在结果集中获取当前行的每一列的长度</td>
</tr>
<tr>
<td>$num_rows</td>
<td style="text-align:left">返回结果集中包含记录的行数</td>
</tr>
</tbody>
</table>
<h3 id="从结果集中解析数据"><a href="#从结果集中解析数据" class="headerlink" title="从结果集中解析数据"></a>从结果集中解析数据</h3><h4 id="result-gt-fetch-row"><a href="#result-gt-fetch-row" class="headerlink" title="$result-&gt;fetch_row()"></a>$result-&gt;fetch_row()</h4><p>该方法从结果集中获取一条结果记录，将值存放在一个索引数组中，与其他三个方法相比是最方便的方法。它的各个字段需要以$row[$n]的方式访问，其中$row是从结果集中获取的一行记录返回的数据，$n为连续的整数下标。因为返回的是索引数组，所以还可以和list()函数结合在一起使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;demo&quot;);  //连接本地demo数据库</div><div class="line">	if (mysqli_connect_errno()) &#123;</div><div class="line"> 		printf(&quot;连接失败: %s&lt;br&gt;&quot;, mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125;</div><div class="line">	$mysqli-&gt;query(&quot;set names gb2312&quot;);                     //设置字符集为国标2312码</div><div class="line">     	/* 将部门编号为D01的联系人姓名和电子邮件全部取出存入到结果集中 */</div><div class="line">	$result = $mysqli-&gt;query(&quot;SELECT name, email FROM contactInfo WHERE departmentId=&apos;D01&apos;&quot;);</div><div class="line">	echo &apos;D01部门的联系人姓名和电子邮件：&apos;;</div><div class="line">	echo &apos;&lt;ol&gt;&apos;;</div><div class="line">	while(list($name, $email)=$result-&gt;fetch_row())&#123;     //从结果集中遍历每条数据</div><div class="line">		echo &apos;&lt;li&gt;&apos;.$name.&apos; : &apos;.$email.&apos;&lt;/li&gt;&apos;;            //以列表形式输出每条记录</div><div class="line">	&#125;	</div><div class="line">	echo &apos;&lt;/ol&gt;&apos;;</div><div class="line">    	$result-&gt;close();                                 //关闭结果集</div><div class="line">	$mysqli-&gt;close();	                           //关闭与数据库的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="result-gt-fetch-assoc"><a href="#result-gt-fetch-assoc" class="headerlink" title="$result-&gt;fetch_assoc()"></a>$result-&gt;fetch_assoc()</h4><p>该方法将以一个关联数组的形式返回一条结果记录，数据表的字段名表示键，字段内容表示值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$mysqli = new mysqli(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_pwd&quot;, &quot;demo&quot;);  //连接MySQL数据库</div><div class="line">	if (mysqli_connect_errno()) &#123;                                   //检查连接错误</div><div class="line"> 		printf(&quot;连接失败: %s&lt;br&gt;&quot;, mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125;</div><div class="line">	$mysqli-&gt;query(&quot;set names gb2312&quot;);                            //设置查询字符集</div><div class="line">	$result = $mysqli-&gt;query(&quot;SELECT * FROM contactInfo&quot;);          //执行查询语句获取结果集</div><div class="line"></div><div class="line">	echo &apos;&lt;table width=&quot;90%&quot; border=&quot;1&quot; align=&quot;center&quot;&gt;&apos;;               //打印HTML表格</div><div class="line">	echo &apos;&lt;caption&gt;&lt;h1&gt;联系人信息表&lt;/h1&gt;&lt;/caption&gt;&apos;;                //输出表名</div><div class="line">	echo &apos;&lt;th&gt;用户ID&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;部门编号&lt;/th&gt;&apos;;          //输出字段名</div><div class="line">	echo &apos;&lt;th&gt;联系地址&lt;/th&gt;&lt;th&gt;联系电话&lt;/th&gt;&lt;th&gt;电子邮件&lt;/th&gt;&apos;;    </div><div class="line">	while($row=$result-&gt;fetch_assoc())&#123;                            //循环从结果集中遍历记录</div><div class="line">		echo &apos;&lt;tr align=&quot;center&quot;&gt;&apos;;                                //输出行标记</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;uid&quot;].&apos;&lt;/td&gt;&apos;;                            //输出用户ID</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;name&quot;].&apos;&lt;/td&gt;&apos;;                          //输出用户姓名</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;departmentId&quot;].&apos;&lt;/td&gt;&apos;;                    //输出部门编号</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;address&quot;].&apos;&lt;/td&gt;&apos;;                        //输出联系地址</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;phone&quot;].&apos;&lt;/td&gt;&apos;;                         //输出联系电话</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;email&quot;].&apos;&lt;/td&gt;&apos;;                          //输出电子邮件</div><div class="line">		echo &apos;&lt;/tr&gt;&apos;;</div><div class="line">	&#125;	</div><div class="line">	echo &apos;&lt;/table&gt;&apos;;</div><div class="line">     	$result-&gt;close();                                           //关闭结果集释放内存</div><div class="line">	$mysqli-&gt;close();	                                      //关闭与数据库服务器的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="result-gt-fetch-array"><a href="#result-gt-fetch-array" class="headerlink" title="$result-&gt;fetch_array()"></a>$result-&gt;fetch_array()</h4><p>该方法可以说是fetch_row()和fetch_assoc()两个方法的结合版本，可以将结果集的各条记录获取为一个关联数组或数值索引数组，或者同时获取为关联数组和索引数组。默认情况下，会同时获取这两种数组。可以通过在该方法的参数在该方法的参数中传入如下不同的值来修改这种默认行为。</p>
<ul>
<li>MYSQLI_ASSOC:记录被作为关联数组返回，字段名为键，字段内容为值。</li>
<li>MYSQLI_NUM:记录被作为索引数组返回，按查询中指定的字段名顺序排序。</li>
<li>MYSQLI_BOTH:这是默认值，记录即未做关联数组又作为索引数组返回。因此，每个字段可以根据其索引偏移引用，也可以根据字段名来引用。</li>
</ul>
<h4 id="result-gt-fetch-object"><a href="#result-gt-fetch-object" class="headerlink" title="$result-&gt;fetch_object()"></a>$result-&gt;fetch_object()</h4><p>该方法与前面三个方法不同，它将以一个对象的形式返回一条结果记录，而不是数组。它的各个字段需要以对象的方式进行访问，数据列的名字区分字母大小写情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$mysqli = new mysqli(&quot;localhost&quot;, &quot;mysql_user&quot;, &quot;mysql_pwd&quot;, &quot;demo&quot;);  //连接MySQL数据库</div><div class="line">	if (mysqli_connect_errno()) &#123;                                   //检查连接错误</div><div class="line"> 		printf(&quot;连接失败: %s&lt;br&gt;&quot;, mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125;</div><div class="line">	$mysqli-&gt;query(&quot;set names gb2312&quot;);                            //设置查询字符集</div><div class="line">	$result = $mysqli-&gt;query(&quot;SELECT * FROM contactInfo&quot;);          //执行查询语句获取结果集</div><div class="line"></div><div class="line">	echo &apos;&lt;table width=&quot;90%&quot; border=&quot;1&quot; align=&quot;center&quot;&gt;&apos;;               //打印HTML表格</div><div class="line">	echo &apos;&lt;caption&gt;&lt;h1&gt;联系人信息表&lt;/h1&gt;&lt;/caption&gt;&apos;;                //输出表名</div><div class="line">	echo &apos;&lt;th&gt;用户ID&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;部门编号&lt;/th&gt;&apos;;          //输出字段名</div><div class="line">	echo &apos;&lt;th&gt;联系地址&lt;/th&gt;&lt;th&gt;联系电话&lt;/th&gt;&lt;th&gt;电子邮件&lt;/th&gt;&apos;;    </div><div class="line">	while($rowObj=$result-&gt;fetch_object())&#123;                        //循环从结果集中遍历记录</div><div class="line">		echo &apos;&lt;tr align=&quot;center&quot;&gt;&apos;;                                //输出行标记</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$rowObj-&gt;uid.&apos;&lt;/td&gt;&apos;;                          //输出用户ID</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$rowObj-&gt;name.&apos;&lt;/td&gt;&apos;;                        //输出用户姓名</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$rowObj-&gt;departmentId.&apos;&lt;/td&gt;&apos;;                  //输出部门编号</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$rowObj-&gt;address.&apos;&lt;/td&gt;&apos;;                       //输出联系地址</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$rowObj-&gt;phone.&apos;&lt;/td&gt;&apos;;                        //输出联系电话</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$rowObj-&gt;email.&apos;&lt;/td&gt;&apos;;                         //输出电子邮件</div><div class="line">		echo &apos;&lt;/tr&gt;&apos;;</div><div class="line">	&#125;	</div><div class="line">	echo &apos;&lt;/table&gt;&apos;;</div><div class="line">    	$result-&gt;close();                                           //关闭结果集释放内存</div><div class="line">	$mysqli-&gt;close();	                                      //关闭与数据库服务器的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="从结果集中获取数据列的信息"><a href="#从结果集中获取数据列的信息" class="headerlink" title="从结果集中获取数据列的信息"></a>从结果集中获取数据列的信息</h3><p>在解析结果集时，不仅需要从中遍历数据，有时也需要获取数据表的属性和各个字段的信息。可以通过结果集对象中的field_count属性给出结果数据表里的数据列的个数、使用current_field属性获取指向当前列的位置、使用field_seek()方法改变指向当前列的偏移位置，以及通过fetch_field（）方法返回的对象中获取当前列的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;demo&quot;);    //连接MySQL数据库</div><div class="line">	if (mysqli_connect_errno()) &#123;                                        //检查连接错误</div><div class="line"> 		printf(&quot;连接失败: %s&lt;br&gt;&quot;, mysqli_connect_error());</div><div class="line">		exit();</div><div class="line">	&#125; </div><div class="line">	$mysqli-&gt;query(&quot;set names gb2312&quot;);                             //设置查询字符集</div><div class="line">	$result = $mysqli-&gt;query(&quot;SELECT * FROM contactInfo&quot;);           //执行查询语句获取结果集</div><div class="line"></div><div class="line">	echo &quot;结果数据表里数据列个数为：&quot;.$result-&gt;field_count.&quot;列&lt;br&gt;&quot;;   //从查询结果中获取列数</div><div class="line">	echo &quot;默认当前列的指针位置为第：&quot;.$result-&gt;current_field.&quot;列&lt;br&gt;&quot;;  //打印默认列的指针位置</div><div class="line">	echo &quot;将指向当前列的指针移动到第二列;&lt;br&gt;&quot;;</div><div class="line">	$result-&gt;field_seek(1);                      //将当前列指针移至第二列（默认0代表第一列）</div><div class="line">	echo &quot;指向当前列的指针位置为第：&quot;.$result-&gt;current_field.&quot;列&lt;br&gt;&quot;;   //打印当前列的指针位置</div><div class="line">	echo &quot;第二列的信息如下所示：&lt;br&gt;&quot;;</div><div class="line">	$finfo = $result-&gt;fetch_field();                                //获取当前列的对象</div><div class="line">	echo &quot;列的名称：&quot;.$finfo-&gt;name.&quot;&lt;br&gt;&quot;;                       //打印列的名称</div><div class="line">	echo &quot;数据列来自数据表：&quot;.$finfo-&gt;table.&quot;&lt;br&gt;&quot;;               //打印本列来自哪个数据表</div><div class="line">	echo &quot;本列最长字符串的长度&quot;.$finfo-&gt;max_length.&quot;&lt;br&gt;&quot;;        //打印本列中最长字符串长度</div><div class="line"></div><div class="line">     	$result-&gt;close();                                           //关闭结果集释放内存</div><div class="line">	$mysqli-&gt;close();	                                      //关闭与数据库服务器的连接</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="数据库抽象层PDO"><a href="#数据库抽象层PDO" class="headerlink" title="数据库抽象层PDO"></a>数据库抽象层PDO</h1><h2 id="PDO所支持的数据库"><a href="#PDO所支持的数据库" class="headerlink" title="PDO所支持的数据库"></a>PDO所支持的数据库</h2><p>PDO就是一个“数据库访问抽象层”，作用是统一各种数据库的访问接口，能够轻松地在不同数据库之间进行切换，使得数据库间的移植容易实现。</p>
<table>
<thead>
<tr>
<th>驱动名</th>
<th style="text-align:left">对应访问的数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>PDO_DBLIB</td>
<td style="text-align:left">FreeTDS/Microsoft SQL Server/Sybase</td>
</tr>
<tr>
<td>PDO_FIREBIED</td>
<td style="text-align:left">Firebird/Interbase 6</td>
</tr>
<tr>
<td>PDO_MYSQL</td>
<td style="text-align:left">MySQL 3.x/4.x/5.x</td>
</tr>
<tr>
<td>PDO_OCI</td>
<td style="text-align:left">Oracle</td>
</tr>
<tr>
<td>PDO_ODBC</td>
<td style="text-align:left">ODBC v3</td>
</tr>
<tr>
<td>PDO_PGSQL</td>
<td style="text-align:left">PostgreSQL</td>
</tr>
<tr>
<td>PDO_SQLITE</td>
<td style="text-align:left">SQLite 2.x/3.x</td>
</tr>
</tbody>
</table>
<h2 id="PDO的安装"><a href="#PDO的安装" class="headerlink" title="PDO的安装"></a>PDO的安装</h2><p>在Linux环境下为启用对MySQL的PDO驱动程序支持，需要在安装PHP5.1以上版本的源代码包环境时，向configure命令添加如下标志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--with-pdo-mysql=/usr/local/mysql		//其中“/usr/local/mysql”为MySQL服务器安装目录</div></pre></td></tr></table></figure></p>
<p>在Windows环境下PHP5.1以上版本中，PDO和主要数据库的驱动同PHP一样作为扩展发布，要激活它们只需要简单地编辑php.ini文件。下面都是用分号在前面注释掉了支持的扩展模块，我们在后面追加下面的一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension=php_pdo.dll			//所以PDO驱动程序共享的扩展，必须有</div></pre></td></tr></table></figure></p>
<p>上面一行是所以PDO驱动程序共享必须要有的扩展。然后，就看使用什么数据库，如果使用MySQL，那么添加下面的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension=php_pdo_mysql.dll				//如果使用MySQL，那么添加这一行</div></pre></td></tr></table></figure></p>
<p>如果要激活其他一种数据库的PDO驱动程序，添加下面其中的一行，如果要激活多个数据库的PDO驱动程序，添加下面的多行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extension=php_pdo_mssql.dll			//如果要使用SQL Server，那么添加这一行</div><div class="line">extension=php_pdo_odbc.dll			//如果要使用ODBC驱动程序，那么添加这一行</div><div class="line">extension=php_pdo_oci.dll			//如果要使用Oracle驱动程序，那么添加这一行</div></pre></td></tr></table></figure></p>
<p>保存修改的php.ini文件变化，重启Apache服务器，查看phpinfo()函数PDO是否开启。</p>
<h2 id="创建PDO对象"><a href="#创建PDO对象" class="headerlink" title="创建PDO对象"></a>创建PDO对象</h2><p>使用PDO在与不同数据库管理系统之间交互时，PDO对象中的成员方法是统一各种数据库的访问接口，所以在使用PDO与数据库交互之间，首先要创建一个PDO对象。在通过构造方法创建对象的同时，需要建立一个与数据库服务器的连接，并选择一个数据库。PDO的构造方法原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__construct(string dsn[,string username[,string password[,array driver_options]]])		//PDO的构造方法</div></pre></td></tr></table></figure></p>
<p>在构造方法中，第一个必选的参数是数据源名（DSN），用来定义一个确定的数据库和必须用到的驱动程序。DSN的PDO命名惯例为PDO驱动程序的名称，后面一个冒号，再后面是可选的驱动程序的数据库连接变量信息，如主机名、端口和数据库名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">oci:dbname=//localhost:1521/mydb			//连接Oracle服务器的数据源名（DSN）</div><div class="line">mysql:host=localhost;dbname=testdb			//连接MySQL服务器的数据源名（DSN）</div></pre></td></tr></table></figure></p>
<p>构造方法中的第二参数username和第三个参数password分别指定用于连接数据库的用户名和密码，是可选参数。最后一个参数driver_options需要一个数组，用来指定连接所需的所有额外选项，传递附加的调优参数到PDO或底层驱动程序。</p>
<h3 id="以多种方法调用构造方法"><a href="#以多种方法调用构造方法" class="headerlink" title="以多种方法调用构造方法"></a>以多种方法调用构造方法</h3><h4 id="将参数嵌入到构造函数"><a href="#将参数嵌入到构造函数" class="headerlink" title="将参数嵌入到构造函数"></a>将参数嵌入到构造函数</h4><p>在DSN字符串中加载OCI驱动程序并指定了两个可选参数：第一个是数据库名称，第二个是字符集。使用了特定的字符集连接一个特定的数据库，如果不指定任何信息就会使用默认的数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">			$dbh = new PDO(&quot;OCI:dbname=accounts;charset=UTF-8&quot;,&quot;scott&quot;,&quot;tiger&quot;);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">			echo &quot;数据库连接失败：	&quot;.$e-&gt;getMessage();</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>OCI:dbname=accounts告诉PDO它应该使用OCI驱动程序，并且应该使用“accounts”数据库。对于MySQL驱动程序，第一个冒号后面的所有内容都将用做MySQL的DSN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$dsn=&apos;mysql:dbname=testdb;host=127.0.0.1&apos;;</div><div class="line">	$user=&apos;dbuser&apos;;</div><div class="line">	$password=&apos;dbpass&apos;;</div><div class="line">	try&#123;</div><div class="line">			$dbh = new PDO($dsn,$user,$password);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">			echo &apos;数据库连接失败： &apos;.$e-&gt;getMessage();</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="将参数存放在文件中"><a href="#将参数存放在文件中" class="headerlink" title="将参数存放在文件中"></a>将参数存放在文件中</h4><p>在创建PDO对象时，可以把DSN字符串放在另一个本地或远程文件中，并在构造函数中引用这个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">		$dbh = new PDO(&apos;uri:file://usr/local/dbconnect&apos;,&apos;webuser&apos;,&apos;password&apos;);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		ehco&apos;连接失败： &apos;.$e-&gt;getMessage();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>只要将文件/usr/local/dbconnect中的DSN驱动改变，就可以在多种数据库系统之间切换。但要确保该文件由负责执行PHP脚本的用户拥有，而且此用户拥有必要的权限。</p>
<h4 id="引用php-ini"><a href="#引用php-ini" class="headerlink" title="引用php.ini"></a>引用php.ini</h4><p>也可以在PHP服务器的配置文件中维护DSN信息，只要在php.ini文件中把DSN信息赋给一个名为pdo.dsn.aliasname的配置参数，这里aliasname是后面将提供给构造函数的DSN别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[PDO]</div><div class="line">pdo.dsn.orcalepdo=&quot;OCI:dbname=//localhost:1521/mydb;charset=UTF-8&quot;;</div></pre></td></tr></table></figure></p>
<p>重启启动Apache服务器后，就可以在PHP程序中，调用PDO构造方法时，在第一个参数中使用这个别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">		$dbh=new PDO(&quot;orcalepdo&quot;,&quot;scott&quot;,&quot;tiger&quot;);	//使用php.ini文件中的oraclepdo别名</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &quot;数据库连接失败： &quot;.$-&gt;getMessage();</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="PDO与连接有关选项"><a href="#PDO与连接有关选项" class="headerlink" title="PDO与连接有关选项"></a>PDO与连接有关选项</h4><p>在创建PDO对象时，有一些与数据库连接有关的选项，可以将必要的几个选项组成数组传递给构造方法的第四个参数driver_opts中，用来传递附加的调优参数到PDO或底层驱动程序。</p>
<table>
<thead>
<tr>
<th>选项名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PDO::ATTR_AUTOCOMMIT</td>
<td style="text-align:left">确定PDO是否关闭自动提交功能，设置FALSE值时关闭</td>
</tr>
<tr>
<td>PDO::ATTR_CASE</td>
<td style="text-align:left">强制PDO获取的表字符的大小写转换，或原样使用列信息</td>
</tr>
<tr>
<td>PDO::ATTR_ERRMODE</td>
<td style="text-align:left">设置错误处理的模式</td>
</tr>
<tr>
<td>PDO::ATTR_PERSISTENT</td>
<td style="text-align:left">确定连接是否为持久连接，默认值为FALSE</td>
</tr>
<tr>
<td>PDO::ATTR_ORACLE_NULLS</td>
<td style="text-align:left">将返回的空字符串转换为SQL的NULL</td>
</tr>
<tr>
<td>PDO::ATTR_PREFETCH</td>
<td style="text-align:left">设置应用程序提前获取的数据大小，以K字节为单位</td>
</tr>
<tr>
<td>PDO::ATTR_TIMEOUT</td>
<td style="text-align:left">设置超时之前等待的时间</td>
</tr>
<tr>
<td>PDO::ATTR_SERVER_INFO</td>
<td style="text-align:left">包含与数据库特有的服务器信息</td>
</tr>
<tr>
<td>PDO::ATTR_SERVER_VERSION</td>
<td style="text-align:left">包含与数据库服务器版本号有关的信息</td>
</tr>
<tr>
<td>PDO::ATTR_CLIENT_VERSION</td>
<td style="text-align:left">包含与数据库客户端版本号有关的信息</td>
</tr>
<tr>
<td>PDO::ATTR_CONNECTION_STATUS</td>
<td style="text-align:left">包含与数据库特有的与连接状态有关的信息</td>
</tr>
</tbody>
</table>
<h3 id="PDO对象中的成员方法"><a href="#PDO对象中的成员方法" class="headerlink" title="PDO对象中的成员方法"></a>PDO对象中的成员方法</h3><table>
<thead>
<tr>
<th>成员方法名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute()</td>
<td style="text-align:left">获取一个“数据库连接对象”的属性</td>
</tr>
<tr>
<td>setAttribute()</td>
<td style="text-align:left">为一个“数据库连接对象”设定属性</td>
</tr>
<tr>
<td>errorCode()</td>
<td style="text-align:left">获取错误码</td>
</tr>
<tr>
<td>errorInfo()</td>
<td style="text-align:left">获取错误的信息</td>
</tr>
<tr>
<td>exec()</td>
<td style="text-align:left">处理一条SQL语句，并返回所影响的条目数</td>
</tr>
<tr>
<td>query()</td>
<td style="text-align:left">处理一条SQL语句，并返回一个“PDOStatement”对象</td>
</tr>
<tr>
<td>lastInsertId()</td>
<td style="text-align:left">获取插入到表中的最后一条数据的主键值</td>
</tr>
<tr>
<td>prepare()</td>
<td style="text-align:left">负责准备要执行的SQL语句</td>
</tr>
<tr>
<td>getAvailableDrivers()</td>
<td style="text-align:left">获取有效的PDO驱动器名称</td>
</tr>
<tr>
<td>beginTransaction()</td>
<td style="text-align:left">开始一个事务，表明回滚起始点</td>
</tr>
<tr>
<td>commit()</td>
<td style="text-align:left">提交一个事务，并执行SQL</td>
</tr>
<tr>
<td>rollback()</td>
<td style="text-align:left">回滚一个事务</td>
</tr>
</tbody>
</table>
<h2 id="使用PDO对象"><a href="#使用PDO对象" class="headerlink" title="使用PDO对象"></a>使用PDO对象</h2><h3 id="调整PDO的行为属性"><a href="#调整PDO的行为属性" class="headerlink" title="调整PDO的行为属性"></a>调整PDO的行为属性</h3><h4 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute()"></a>getAttribute()</h4><p>该方法只需要提供一个参数，传递一个特定属性名称，执行成功返回该属性所指定的值，否则返回NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$opt=array(PDO::ATTR_PERSISTENT =&gt; TRUE);</div><div class="line">	try &#123;</div><div class="line">   		$dbh = new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;, &apos;mysql_user&apos;, &apos;mysql_pwd&apos;, $opt);</div><div class="line">	&#125; catch (PDOException $e) &#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line">	echo &quot;\nPDO是否关闭自动提交功能：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_AUTOCOMMIT);</div><div class="line">	echo &quot;\n当前PDO的错误处理的模式：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_ERRMODE);</div><div class="line">	echo &quot;\n表字段字符的大小写转换： &quot;.$dbh-&gt;getAttribute(PDO::ATTR_CASE);</div><div class="line">	echo &quot;\n与连接状态相关特有信息： &quot;.$dbh-&gt;getAttribute(PDO::ATTR_CONNECTION_STATUS);</div><div class="line">	echo &quot;\n空字符串转换为SQL的null：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_ORACLE_NULLS);</div><div class="line">	echo &quot;\n应用程序提前获取数据大小：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_PERSISTENT);</div><div class="line">	echo &quot;\n与数据库特有的服务器信息：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_SERVER_INFO);</div><div class="line">	echo &quot;\n数据库服务器版本号信息：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_SERVER_VERSION);</div><div class="line">	echo &quot;\n数据库客户端版本号信息：&quot;.$dbh-&gt;getAttribute(PDO::ATTR_CLIENT_VERSION);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute()"></a>setAttribute()</h4><p>这个方法需要两个参数，第一个参数提供PDO对象特定的属性名，第二个参数则是为这个指定的属性赋一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);		//设置抛出异常处理错误</div></pre></td></tr></table></figure></p>
<h3 id="使用PDO执行SQL语句"><a href="#使用PDO执行SQL语句" class="headerlink" title="使用PDO执行SQL语句"></a>使用PDO执行SQL语句</h3><h4 id="使用PDO-exec-方法"><a href="#使用PDO-exec-方法" class="headerlink" title="使用PDO::exec()方法"></a>使用PDO::exec()方法</h4><p>当执行INSERT、UPDATE和DELETE等没有结果集的查询时，使用PDO对象中的exec()方法去执行。该方法成功执行后，将返回受影响的行数。该方法不能用于SELECT查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">		$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;	</div><div class="line">	&#125;</div><div class="line">	$query=&quot;UPDATE contactInfo SET phone=&apos;15801680168&apos; where name=&apos;高某某&apos;&quot;;</div><div class="line">	$affected=$dbh-&gt;exec($query);</div><div class="line">	if($affected)&#123;</div><div class="line">		echo &apos;数据表contactInfo中受影响的行数为：&apos;.$affected;</div><div class="line">	&#125;else&#123;</div><div class="line">		print_r($dbh-&gt;errorInfo());</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="使用PDO-query-方法"><a href="#使用PDO-query-方法" class="headerlink" title="使用PDO::query()方法"></a>使用PDO::query()方法</h4><p>当执行返回结果集的SELECT查询时，或者所影响的行数无关紧要时，应当使用PDO对象中的query()方法。如果该方法成功执行指定的查询，返回一个PDOStatement对象。如果使用了query()方法，并想了解影响的行总数，可以使用PDO对象中的rowCount()方法获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">	　　$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);　　</div><div class="line">	　　$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line">	$query=&quot;SELECT name, phone, email FROM contactInfo WHERE departmentId=&apos;D01&apos;&quot;;	</div><div class="line">	try &#123;</div><div class="line">		$pdostatement=$dbh-&gt;query($query);</div><div class="line">　　　　　	echo &quot;一共从表中获取到&quot;.$pdostatement-&gt;rowCount().&quot;条记录:\n&quot;;</div><div class="line">		foreach ($pdostatement as $row) &#123;</div><div class="line">       		echo $row[&apos;name&apos;] . &quot;\t&quot;;</div><div class="line">       		echo $row[&apos;phone&apos;] . &quot;\t&quot;;</div><div class="line">        		echo $row[&apos;email&apos;] . &quot;\n&quot;;</div><div class="line">    		&#125;</div><div class="line">	&#125; catch (PDOException $e) &#123;</div><div class="line">		echo $e-&gt;getMessage();</div><div class="line"> 		print_r($dbh-&gt;errorInfo());</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="PDO对预处理语句的支持"><a href="#PDO对预处理语句的支持" class="headerlink" title="PDO对预处理语句的支持"></a>PDO对预处理语句的支持</h2><h3 id="了解PDOStatement对象"><a href="#了解PDOStatement对象" class="headerlink" title="了解PDOStatement对象"></a>了解PDOStatement对象</h3><table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bindColumn()</td>
<td style="text-align:left">用来匹配列名和一个指定的变量名，这样每次获取各行记录时，会自动将相应的列值赋给该变量</td>
</tr>
<tr>
<td>bindParam()</td>
<td style="text-align:left">将参数绑定到相应的查询占位符上</td>
</tr>
<tr>
<td>bindValue()</td>
<td style="text-align:left">将一值绑定到对应的一个参数中</td>
</tr>
<tr>
<td>closeCursor()</td>
<td style="text-align:left">关闭游标，使该声明再次被执行</td>
</tr>
<tr>
<td>columnCount()</td>
<td style="text-align:left">在结果集中返回列的数目</td>
</tr>
<tr>
<td>errorCode()</td>
<td style="text-align:left">获取错误码</td>
</tr>
<tr>
<td>errorInfo()</td>
<td style="text-align:left">获取错误的信息</td>
</tr>
<tr>
<td>execute()</td>
<td style="text-align:left">负责执行一个准备好的预处理查询</td>
</tr>
<tr>
<td>fetch()</td>
<td style="text-align:left">返回结果集的下一行，当到达结果集末尾时返回FALSE</td>
</tr>
<tr>
<td>fetchAll()</td>
<td style="text-align:left">通过一次调用就可以获取结果集中的所有行，并赋给返回的数组</td>
</tr>
<tr>
<td>fetchColumn()</td>
<td style="text-align:left">返回结果集中下一行某个列的值</td>
</tr>
<tr>
<td>fetchObject()</td>
<td style="text-align:left">获取下一行记录并返回它作为一个对象</td>
</tr>
<tr>
<td>getAttribute()</td>
<td style="text-align:left">获取一个声明属性</td>
</tr>
<tr>
<td>getColumnMeta()</td>
<td style="text-align:left">在结果集中返回某一列的属性信息</td>
</tr>
<tr>
<td>nextRowset()</td>
<td style="text-align:left">检索下一行集（结果集）</td>
</tr>
<tr>
<td>rowCount()</td>
<td style="text-align:left">返回使用query（）方法执行的SELECT语句后受影响的行总数</td>
</tr>
<tr>
<td>setAttribute()</td>
<td style="text-align:left">为一个预处理语句设置属性</td>
</tr>
<tr>
<td>setFetchMode()</td>
<td style="text-align:left">设置需要结果集合的类型</td>
</tr>
</tbody>
</table>
<h3 id="准备语句"><a href="#准备语句" class="headerlink" title="准备语句"></a>准备语句</h3><p>PDO中有两种使用占位符的语法：“命名参数”和“问号参数”。</p>
<ul>
<li><p>使用命名参数作为占位符的INSERT查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$dbh-&gt;prepare(&quot;INSERT INTO contactInfo(name,address,phone) VALUES(:name,:address,:phone)&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>使用问号（？）参数作为占位符的INSERT查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$dbh-&gt;prepare(&quot;INSERT INTO contactInfo(name,address,phone) VALUES(?,?,?)&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="绑定参数"><a href="#绑定参数" class="headerlink" title="绑定参数"></a>绑定参数</h3><p>当查询准备好之后，需要在每次执行时替换输入的参数。可以通过PDOStatement对象中的bindParam()方法，把参数绑定到准备好的查询中相应的占位符。方法bindParame()的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bindParam(mixed parameter,mixed&amp;variable[,int data_type[,int length[,mixed driver_options]]])</div></pre></td></tr></table></figure></p>
<p>第一个参数parameter是必选项，如果在准备好的查询中，占位符语法使用名字参数时，将名字参数字符串作为bindParam()方法的第一个参数提供。如果占位符语法使用问号参数时，将准备好的查询中列值占位符的索引偏移量，作为该方法的第一个参数提供。<br>第二个参数variable也是必选项，提供赋给第一个参数所指定占位符的值。它需要按引用传递，在结合准备存储过程使用此方时，可以根据存储过程的某个动作修改这个值。因为该参数是按引用传递，所以只能提供变量作为参数，不能直接提供数值。<br>第三个参数data_type是可选项，显示地为当前被绑定的参数设置数据类型。</p>
<ul>
<li>PDO::PARAM_BOOL:代表boolean数据类型</li>
<li>PDO::PARAM_NULL:代表SQL中NULL类型</li>
<li>PDO::PARAM_INT:代表SQL中INTEGER数据类型</li>
<li>PDO::PARAM_STR:代表SQL中CHAR、VARCHAR和其他字符串数据类型</li>
<li>PDO::PARAM_LOB:代表SQL中大对象数据类型</li>
<li>PDO::PARAM_STMT:代表PDOStatement对象类型</li>
<li>PDO::PARAM_INPUT_OUTPUT:专为存储过程使用的数据类型，可以在过程执行后修改</li>
</ul>
<p>第四个参数length是可选项，用于指定数据类型的长度，当在第三个参数中使用PDO_PARAM_INPUT_OUTPUT数据类型时必须使用这个参数。<br>第五个参数driver_options是可选项，通过该参数提供任何数据库驱动程序特定的选项。</p>
<h3 id="执行准备好的查询"><a href="#执行准备好的查询" class="headerlink" title="执行准备好的查询"></a>执行准备好的查询</h3><p>当准备好查询并绑定了相应的参数，就可以通过调用PDOStatement类对象中的execute（）方法反复执行了。<br>execute()方法中提供了一个可选参数，该参数由准备查询中的命名参数占位符组成的数组，这是第二种为预处理查询在执行中替换输入参数的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">	try&#123;</div><div class="line">		$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$query=&quot;INSERT INTO contactInfo (name, address, phone) VALUES (:name, :address, :phone)&quot;;</div><div class="line">	$stmt=$dbh-&gt;prepare($query);</div><div class="line"></div><div class="line">	$stmt-&gt;execute(array(&quot;:name&quot;=&gt;&quot;赵某某&quot;,&quot;:address&quot;=&gt;&quot;海淀区&quot;, &quot;:phone&quot;=&gt;&quot;15801688348&quot;));</div><div class="line"></div><div class="line">	$stmt-&gt;execute(array(&quot;:name&quot;=&gt;&quot;孙某某&quot;,&quot;:address&quot;=&gt;&quot;宣武区&quot;, &quot;:phone&quot;=&gt;&quot;15801688698&quot;));</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><h4 id="fetch-方法"><a href="#fetch-方法" class="headerlink" title="fetch()方法"></a>fetch()方法</h4><p>DOStatement类中的fetch()方法可以将结果集中当前行的记录以某种方法返回，并将结果集指针移至下一行，当到达结果集末尾时返回FALSE。该方法的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fetch([int fetch_style[,int cursor_orientation[,int cursor_offset]]])	//返回结果集的下一行</div></pre></td></tr></table></figure></p>
<p>第一个参数fetch_style是必选项，获取的一行数据记录中，各列的引用方式取决于这个参数如何设置。可以使用的设置以下六种。</p>
<ul>
<li>PDO::FETCH_ASSOC:从结果集中获取按列名为索引的关联数组</li>
<li>PDO::FETCH_NUM:从结果集中获取一个按列在航中的数值偏移为索引的值数组</li>
<li>PDO::FETCH_BOTH:这是默认值，包含上面两种数组</li>
<li>PDO::FETCH_OBJ：从结果集当前行的记录中获取其属性对应各个列名的一个对象</li>
<li>PDO::FETCH_BOUND:使用fetch()返回TRUE，并将获取的列值赋给通过bindParam()方法中指定的相应变量</li>
<li>PDO::FETCH_LAZY：创建关联数组和索引数组，以及包含列属性的一个对象，从而可以在这三种接口中任选一种</li>
</ul>
<p>第二个参数curosr_orientation是可选项，用来确定当对象是一个可滚动的游标时应当获取哪一行。<br>第三个参数cursor_offset也是可选项，需要提供一个整数值，表示要获取的行相对于当前游标位置的偏移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">	try&#123;</div><div class="line">		$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line">	echo &apos;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=90%&gt;&apos;;</div><div class="line">	echo &apos;&lt;caption&gt;&lt;h1&gt;联系人信息表&lt;/h1&gt;&lt;/caption&gt;&apos;;</div><div class="line">	echo &apos;&lt;tr bgcolor=&quot;#cccccc&quot;&gt;&apos;;</div><div class="line">	echo &apos;&lt;th&gt;UID&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;联系地址&lt;/th&gt;&lt;th&gt;联系电话&lt;/th&gt;&lt;th&gt;电子邮件&lt;/th&gt;&lt;/tr&gt;&apos;;</div><div class="line">	$stmt=$dbh-&gt;query(&quot;select uid,name,address,phone,email from contactInfo&quot;);</div><div class="line">	while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))&#123;</div><div class="line">		echo &apos;&lt;tr&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;uid&quot;].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;name&quot;].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;address&quot;].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;phone&quot;].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[&quot;email&quot;].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;/tr&gt;&apos;;</div><div class="line">	&#125;</div><div class="line">	echo &apos;&lt;/table&gt;&apos;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="fetchAll-方法"><a href="#fetchAll-方法" class="headerlink" title="fetchAll()方法"></a>fetchAll()方法</h4><p>fetchAll()方法与上一个方法fetch()类似，但是该方法只需要调用一次就可以获取结果集中的所有行，并赋给返回的数组。该方法的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fetchAll([int fetch_style[,int column_index]])			//一次调用返回结果集中所有行</div></pre></td></tr></table></figure></p>
<p>第一个参数fetch_style是必选项，以何种方式引用所获取的列取决于该参数。默认值为PDO::FETCH_BOTH，还可以指定PDO::FETCH_COLUMN值，从结果集中返回一个包含单列的所有值。<br>第二个参数column_index是可选项，需要提供一个整数索引，当在fetchAll()方法的第一个参数中指定PDO::FETCH_COLUMN值时，从结果集中返回通过该参数提供的索引所指定列的所有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">		$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line">	echo &apos;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=90%&gt;&apos;;</div><div class="line">	echo &apos;&lt;caption&gt;&lt;h1&gt;联系人信息表&lt;/h1&gt;&lt;/caption&gt;&apos;;</div><div class="line">	echo &apos;&lt;tr bgcolor=&quot;#cccccc&quot;&gt;&apos;;</div><div class="line">	echo &apos;&lt;th&gt;UID&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;联系地址&lt;/th&gt;&lt;th&gt;联系电话&lt;/th&gt;&lt;th&gt;电子邮件&lt;/th&gt;&lt;/tr&gt;&apos;;	$stmt=$dbh-&gt;prepare(&quot;select uid,name,address,phone,email from contactInfo&quot;);</div><div class="line">	$stmt-&gt;execute();</div><div class="line">	$allRows=$stmt-&gt;fetchAll(PDO::FETCH_NUM);</div><div class="line">	foreach($allRows as $row)&#123;</div><div class="line">		echo &apos;&lt;tr&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[0].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[1].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[2].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[3].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;td&gt;&apos;.$row[4].&apos;&lt;/td&gt;&apos;;</div><div class="line">		echo &apos;&lt;/tr&gt;&apos;;</div><div class="line">	&#125;</div><div class="line">	echo &apos;&lt;/table&gt;&apos;;</div><div class="line"></div><div class="line">	$stmt-&gt;execute();</div><div class="line">	$row=$stmt-&gt;fetchAll(PDO::FETCH_COLUMN, 1);</div><div class="line">	echo &apos;所有联系人的姓名：&apos;;</div><div class="line">	print_r($row);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="bindColumn-方法"><a href="#bindColumn-方法" class="headerlink" title="bindColumn()方法"></a>bindColumn()方法</h4><p>使用该方法可以将一个列和一个指定的变量名绑定，这样在每次使用fetch()方法获取各行记录时，会自动将相应的列值赋给该变量，但必须是在fetch()方法第一个参数设置为PDO：：FETCH_BOTH值时。bindColumn()方法的原型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bindColumn(mixed coumn,mixed&amp;param[,int type])		//设置绑定列值到变量上</div></pre></td></tr></table></figure></p>
<p>第一个参数column为必选项，可以使用整数的列偏移位置索引（索引值从1开始），或是列的名称字符串。第二个参数param也是必选项，需要传递一个引用，所以必须提供一个相应的变量名。第三个参数type是可选项，通过设置变量的类型来限制变量值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	try&#123;</div><div class="line">		$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);</div><div class="line">		$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</div><div class="line">	&#125;catch(PDOException $e)&#123;</div><div class="line">		echo &apos;数据库连接失败：&apos;.$e-&gt;getMessage();</div><div class="line">		exit;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	$query=&quot;SELECT uid, name, phone, email FROM contactInfo WHERE departmentId=&apos;D01&apos;&quot;;</div><div class="line">	try &#123;</div><div class="line">		$stmt=$dbh-&gt;prepare($query);</div><div class="line">		$stmt-&gt;execute();</div><div class="line">		$stmt-&gt;bindColumn(1, $uid);</div><div class="line">		$stmt-&gt;bindColumn(2, $name);</div><div class="line">		$stmt-&gt;bindColumn(&apos;phone&apos;, $phone);</div><div class="line">		$stmt-&gt;bindColumn(&apos;email&apos;, $email);</div><div class="line"></div><div class="line">		while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123;</div><div class="line">			 echo $uid.&quot;\t&quot;.$name.&quot;\t&quot;.$phone.&quot;\t&quot;.$email.&quot;\n&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125; catch (PDOException $e) &#123;</div><div class="line">		echo $e-&gt;getMessage();</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h4 id="大数据对象的存取"><a href="#大数据对象的存取" class="headerlink" title="大数据对象的存取"></a>大数据对象的存取</h4><p>PDO允许在bindParam()或bindColumn()调用中通过使用PDO::PARAM_LOB类型代码来使用大型数据库类型。PDO::PARAM_LOB告诉PDO将数据映射为流，所以可以使用PHP中文件处理函数来操纵这样的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$dbh=new PDO(&apos;mysql:dbname=testdb;host=localhost&apos;,&apos;mysql_user&apos;,&apos;mysql_pwd&apos;);		//连接数据库</div><div class="line">	$stmt=$dbh-&gt;prepare(&quot;inset into images(contenttype,imagedata)values(?,?)&quot;);			//准备插入查询</div><div class="line">	$fp=fopen($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],&apos;rb&apos;);			//使用fopen()函数打开上传的文件</div><div class="line">	$stmt-&gt;bindParam(1,$_FILES[&apos;flie&apos;][&apos;type&apos;]);			//将上传的MIME类型绑定到第一个参数中</div><div class="line">	$stmt-&gt;bindParam(2,$fp,PDO_PARAM_LOB);			//将上传文件的二进制数据和第二个参数绑定</div><div class="line">	$stmt-&gt;execute();			//执行准备好的并绑定了参数的查询</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h1><h2 id="Cookie的应用"><a href="#Cookie的应用" class="headerlink" title="Cookie的应用"></a>Cookie的应用</h2><h3 id="Cookie概述"><a href="#Cookie概述" class="headerlink" title="Cookie概述"></a>Cookie概述</h3><p>Cookie是用来将使用者资料记录在客户端的技术，这种技术让Web服务器能将一些只需存放于客户端，或者可以在客户端进行运算的资料，存放于用户的电脑系统之中。</p>
<h3 id="向客户端电脑中设置Cookie"><a href="#向客户端电脑中设置Cookie" class="headerlink" title="向客户端电脑中设置Cookie"></a>向客户端电脑中设置Cookie</h3><p>使用PHP内建的setCookie()函数来新建立一个Cookie。Cookie是HTTP标头的一部分，因此setCookie()函数必须在其他信息被输出到浏览器前调用，所以即使是空格或空行都不要在调用setCookie()函数之前输出。setCookie()函数的语法格式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool setcookie(string $name[,string $value[,int $expire[,string $path[,string $domain[,bool $secure]]]]])</div></pre></td></tr></table></figure></p>
<p>setcookie()函数定义一个和其余的HTTP标头一起发送的Cookie，它的所有参数是对应HTTP标头Cookie资料的属性。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$name</td>
<td style="text-align:left">Cookie的识别名称</td>
<td style="text-align:left">使用$_COOKIE[‘cookiename’]调用名为cookiename的Cookie</td>
</tr>
<tr>
<td>$value</td>
<td style="text-align:left">Cookie的值，可以为数值或字符串形态，此值保存在客户端，不要用来保存敏感数据</td>
<td style="text-align:left">假定第一个参数为‘cookiename’，可以通过$_COOKIE[‘cookiename’]取得其值</td>
</tr>
<tr>
<td>$expire</td>
<td style="text-align:left">Cookie的生成期限，这是个Unix时间戳，即从Unix纪元开始的秒数</td>
<td style="text-align:left">如time()+60<em>60</em>24*7将设定Cookie在一周后失效，如果未设定cookie,则会在会话结束后就立即失效</td>
</tr>
<tr>
<td>$panth</td>
<td style="text-align:left">Cookie在服务器端的指定路径，当设定此值时，服务器中只有指定路径下的网页或程序可以存取此Cookie</td>
<td style="text-align:left">如果该参数设为“/”的话，cookie就在整个domain内有效，如果设为‘/foo’,cookie就只在domain下的/foo/目录及其子目录内有效，默认值为设定cookie的当前目录</td>
</tr>
<tr>
<td>$domain</td>
<td style="text-align:left">指定此Cookie所属服务器的网址名称，预设是建立此Cookie服务器的网址</td>
<td style="text-align:left">要使cookie能在如example.com域名下所有子域名都有效的话，该参数应该设为“.example.com”。虽然“.”并不是必须的，但加上它会兼容更多浏览。如果该参数设置为www.example.com的话，就只在www子域内有效</td>
</tr>
<tr>
<td>$secure</td>
<td style="text-align:left">指明Cookie是否仅通过安全的HTTPS连接传送中Cookie的安全识别常数，如果设定此值代表只有在某种情况下，才能在客户端与服务器之间传递</td>
<td style="text-align:left">当设成TRUE时，Cookie仅在安全的连接中被设置。默认值为FALSE</td>
</tr>
</tbody>
</table>
<p>如果只有name这一个参数，则原有此名称的Cookie选项将会被删除，可以使用空字符串（“ ”）来略过此参数。参数expire和secure是个整数，可以使用0来略过参数，而不是使用空字符串。但参数expire是一个正规的Unix时间整数，由time()或mktime()函数传回。参数secure指出此Cookie将只有在安全的HTTPS连接时传送。在实际建立Cookie是通常仅使用前三项参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	setcookie(&quot;username&quot;,&quot;test&quot;,time()+60*60*24*7);			//向客户端发送一个Cookie</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>全部参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	setcookie(&quot;username&quot;,&quot;test&quot;,time()+60*60*24*7，&quot;/test&quot;,&quot;.example.com&quot;,1);			//使用全部参数设置</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="在PHP脚本中读取Cookie的资料内容"><a href="#在PHP脚本中读取Cookie的资料内容" class="headerlink" title="在PHP脚本中读取Cookie的资料内容"></a>在PHP脚本中读取Cookie的资料内容</h3><p>在设置Cookie的脚本中，第一次读取它的信息并不会生效，必须刷新或到下一个页面才可以看到Cookie值，因为Cookie要先被设置到客户端，再次访问时才能被发送回来，这时才能被获取。所以要测试一个Cookie是否被成功的设定，可以在其到期之前通过另一个页面来访问其值。可以简单地使用print_r(_COOKIE)指令来调试现有的Cookies。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	print_r($_COOKIE);			//输出Cookie中保存的所有用户信息</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="数组形态的Cookie应用"><a href="#数组形态的Cookie应用" class="headerlink" title="数组形态的Cookie应用"></a>数组形态的Cookie应用</h3><p>Cookie也可以利用多维数组的形式，将多个内容值存储在相同Cookie名称标识符下。但不能直接使用setCookie()函数，将数组变量插入到第二个参数作为Cookie的值，因为setCookie()函数的第二个参数必须传一个字符串的值。如果需要将数组变量设置到Cookie中，可以在setCookie()函数的第二个参数中，通过在Cookie标识名称中指定数组下标的形式设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	setcookie(&quot;user[username]&quot;,&quot;username&quot;);				//设置为$_COOKIE[&quot;user&quot;][&quot;username&quot;]</div><div class="line">	setcookie(&quot;user[password]&quot;,&quot;md5(&quot;123456&quot;)&quot;);		//设置为$_COOKIE[&quot;user&quot;][&quot;password&quot;]</div><div class="line">	setcookie(&quot;user[email]&quot;,&quot;test@example.com&quot;);		//设置为$_COOKIE[&quot;user&quot;][&quot;email&quot;]</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>用forecho()函数遍历Cookie<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	forecho($_COOKIE[&quot;user&quot;]as $key=&gt;$value)&#123;</div><div class="line">		echo $key.&quot;:&quot;.$value.&quot;\n&quot;;</div><div class="line">		&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h3><p>删除保存在客户端的Cookie，可以使用两种方法。第一种方法，省略setcookie()函数所有参数列，仅导入第一个参数cookie识别名称参数，来删除指定名称的Cookie资料；第二种方式，利用setcookie()函数，把目标Cookie设定为“已过期”状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	//只指定Cookie识别名称一个参数，即删除客户端中这个指定名称的Cookie资料</div><div class="line">	setCookie(&quot;Account&quot;);		//第一种方法</div><div class="line">	//设置Cookie在当前时间之前已经过期，因此系统会自动删除识别名称isLogin的Cookie</div><div class="line">	setCookie(&quot;isLogin&quot;,&quot;&quot;,time()-1);		//第二种方法</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Session的应用"><a href="#Session的应用" class="headerlink" title="Session的应用"></a>Session的应用</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session技术是将使用者相关的资料存放在服务器的系统之下，所以使用者无法停止Session的使用。<br>在客户端仅需要保存由服务器为用户创建的一个Session标识符，称为Session ID;而在服务器端保存Session变量的值。Session ID是一个既不会重复，又不容易被找到规律的，由32位十六进制数组成的字符串。Session ID会保存在客户端的Cookie里，如果用户阻止Cookie的使用，则可以将Session ID保存在用户浏览器地址栏的URL中。当用户请求Web服务器时，就会把Session ID发送给服务器，再通过Session ID提取保存在服务器中的Seesion变量。可以把Session中保存的变量，当做是这个用户的全局变量，同一个用户对每个脚本的访问都共享这些变量。<br>当某个用户向Web服务器发出请求时，服务器首先会检查这个客户端的请求里是否已经包含了一个Session ID。如果包含，说明之前已经为此用户创建过Session，服务器则按该Session ID把Session检索出来使用。如果客户端请求不包含Session ID，则为该用户创建一个Session，并且生成一个与此Session关联的Session ID,在本次响应中被传送给客户端保存。<br>Session是存放与服务器之中，为了避免对服务器系统造成过大的负荷，因此Session并不像Cookie是一种半永久性的存在。Session会因为下面两种状况而自然消失。</p>
<ul>
<li>第一个状况，当使用者关闭浏览器，失去与服务器之间的连接之后，Session即会自动消失。而当使用者下次登入网址时，再另行配置一个Session使用。</li>
<li>第二种状况，Session指定的有效期限到期。一般而言PHP系统中对于Session的生存时间并无定义，也就是说预设值为零。可以通过修改php.ini配置文件中有关“session.cookie.lift_time”项目，来设定Session的有效期限，以秒为单位指定了发送给浏览器的Cookie的生命周期。值为0表示“直到关闭浏览器”，默认为0.当系统赋予Session有效期限后，不管浏览器是否开启，Session都会自动消失。</li>
</ul>
<h3 id="配置Session"><a href="#配置Session" class="headerlink" title="配置Session"></a>配置Session</h3><table>
<thead>
<tr>
<th>选项名</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>session.auto_start</td>
<td style="text-align:left">自动启动会话，0标识禁用，1表示开启</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td>session.cache_expire</td>
<td style="text-align:left">为缓存中的会话页设置当前时间，单位分钟</td>
<td style="text-align:left">180</td>
</tr>
<tr>
<td>session.cookie_domain</td>
<td style="text-align:left">指定会话Cookie中的域</td>
<td style="text-align:left">none</td>
</tr>
<tr>
<td>session.cookie_lifetime</td>
<td style="text-align:left">Cookie中的Session ID在客户机上保存的时间，0标识延续到浏览器关闭时</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td>session.cookie_path</td>
<td style="text-align:left">在会话Cookie中要设置的路径</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td>seesion.name</td>
<td style="text-align:left">会话的名称，在客户端用做Cookie的标识名称</td>
<td style="text-align:left">PHPSESSID</td>
</tr>
<tr>
<td>session.save_path</td>
<td style="text-align:left">会话在服务器存储的路径</td>
<td style="text-align:left">/tmp</td>
</tr>
<tr>
<td>seesion.use_cookies</td>
<td style="text-align:left">配置在客户端使用Cookie的会话，1表示允许</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<h3 id="Session的声明与使用"><a href="#Session的声明与使用" class="headerlink" title="Session的声明与使用"></a>Session的声明与使用</h3><p>Session的设置不同于Cookie，必须先启动，在PHP中必须调用session_start()函数，以便让PHP核心程序，将和Session相关的内建环境变量预先载入至内存中。seesion_star()函数的语法格式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool session_start(void)		//创建Session,开始一个会话，进行Session初始化</div></pre></td></tr></table></figure></p>
<p>函数Session_start()有两个作用，一是开始一个会话，二是返回已经存在的会话。这个函数没有参数，且返回值均为TRUE。</p>
<h3 id="注册一个会话变量和读取Session"><a href="#注册一个会话变量和读取Session" class="headerlink" title="注册一个会话变量和读取Session"></a>注册一个会话变量和读取Session</h3><p>注册和读取Session变量，都要通过访问$_SESSION数组完成。在$_SESSION关联数组中农工的键名具有和PHP中普通变量名相同的命名规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	session_start();			//启动Session的初始化</div><div class="line">	$_SESSION[&quot;username&quot;]=&quot;admin&quot;;			//注册Session变量，赋值为一个用户的名称</div><div class="line">	$_SESSION[&quot;password&quot;]=&quot;123456&quot;;			//注册Session变量，赋值为一个用户的密码</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>Seesion变量的文件的内容结构：</p>
<pre><code>变量名|类型:长度:值;        //每个变量都使用相同的结构保存
</code></pre><h3 id="注销变量与销毁Session"><a href="#注销变量与销毁Session" class="headerlink" title="注销变量与销毁Session"></a>注销变量与销毁Session</h3><p>销毁和当前Session有关的所以资料，可以调用session_destroy()函数结束当前的会话，并清空会话中的所有资源。该函数的语法格式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool session_destroy(void)		//销毁和当前Session有关的所有资料</div></pre></td></tr></table></figure></p>
<p>该函数用来关闭Session的运作，如果成功则传回TRUE，销毁Session资料失败则返回false.但该函数并不会释放和当前的Session相关的变量，也不会删除保存在客户端Cookie中的Session ID.因为$_SESSION数组和自定义的数组在使用上是相同的，所以我们可以使用unset()函数释放在Session中注册的单个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unset($_SESSION[&quot;username&quot;]);		//删除在Sesssion中注册的用户名变量</div><div class="line">unset($_SESSION[&quot;password&quot;]);		//删除在Session中注册的用户密码变量</div></pre></td></tr></table></figure></p>
<p>不要使用unset($_SESSION)删除整个$_SESSION数组，这样将不能再通过$_SESSION超全局数组注册变量了。但如果想把某个用户在Session中注册的所有变量都删除，可以直接将数组变量$_SESSION赋上一个空数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$_SESSION=array();			//将某个用户在Session中注册的变量全部清除</div></pre></td></tr></table></figure></p>
<p>在PHP脚本中，可以通过调用session_name()函数获取Session名称。删除保存在客户端Cookie中的Session ID.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	if(isset($_COOKIE[session_name()]))&#123;			//判断Cookie中是否保存Session ID</div><div class="line">			setcookie(session_name(),&quot;&quot;,time()-3600,&quot;/&quot;);		//删除包含Session ID的Cookie</div><div class="line">			&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>Session的注销过程共需要四个步骤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    	 //第一步：开启Session并初使化</div><div class="line">	session_start();       </div><div class="line">     	//第二步：删除所有Session的变量，也可用unset($_SESSION[xxx])逐个删除</div><div class="line">	$_SESSION = array();   </div><div class="line">	//第三步：如果使用基于Cookie的Session，使用setCooike()删除包含Session Id的Cookie</div><div class="line">	if (isset($_COOKIE[session_name()])) &#123;</div><div class="line">   		setcookie(session_name(), &apos;&apos;, time()-42000, &apos;/&apos;);</div><div class="line">	&#125;</div><div class="line">	//第四步：最后彻底销毁Session</div><div class="line">	session_destroy();</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="传递Session-ID"><a href="#传递Session-ID" class="headerlink" title="传递Session ID"></a>传递Session ID</h3><p>使用Session跟踪一个用户，是通过在各个方面之间传递唯一的Session ID，并通过Session ID提取这个用户在服务器中保存的Session。常见的Session ID传送方法有以下两种。</p>
<ul>
<li>第一种方法是基于Cookie的方式传递Session ID，这种方法更优化，但由于不总是可用，因为用户在客户端可以屏蔽Cookie。</li>
<li>第二种方法则是通过URL参数进行传递，直接将会话ID嵌入到URL中。</li>
</ul>
<h4 id="通过Cookie传递Session-ID"><a href="#通过Cookie传递Session-ID" class="headerlink" title="通过Cookie传递Session ID"></a>通过Cookie传递Session ID</h4><p>如果客户端没有禁用Cookie，则在PHP脚本中通过session_start()函数进行初始化后，服务器会自动发送HTTP标头将Session ID保存到客户端电脑的Cookie中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setCookie(session_name(),session_id(),0,&apos;/&apos;)			//虚拟向Cookie中设置Session ID的过程</div></pre></td></tr></table></figure></p>
<ul>
<li>在第一个参数中调用session_name()函数，返回当前Session的名称做为Cookie的标识名称。Session名称的默认值为PHPSESSID，是在php.ini文件中由session.name选项指定的值。也可以调用session_name()函数时提供参数改变当前Session名称。</li>
<li>在第二个参数中调用session_id()函数，返回当前Session ID作为Cookie的值。也可以通过调用session_id()函数时提供参数设定当前Session ID</li>
<li>第三个参数的值0，是通过在php.ini文件中由session.cookie_lifetime选项设置的值。默认值为0，表示Session ID将在客户机的Cookie中延续到浏览器关闭</li>
<li>最后一个参数“/”，表示在Cookie中要设置的路径在整个域内都有效</li>
</ul>
<h4 id="通过URL传递Session-ID"><a href="#通过URL传递Session-ID" class="headerlink" title="通过URL传递Session ID"></a>通过URL传递Session ID</h4><p>PHP可以重写客户请求的URL，把SessionID添加到URL信息中。可以手动地在每个超链接的URL中都添加一个SessionID,但工作量比较大，不建议使用这种方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	session_start();</div><div class="line">	echo&apos;&lt;a href=&quot;demo.php?&apos;.session_name().&apos;=&apos;.session_id().&apos;&quot;&gt;链接演示&lt;/a&gt;;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/notes/安全牛：网络渗透与深度防御整理笔记.html" rel="next" title="安全牛：网络渗透与深度防御视频-整理笔记">
                <i class="fa fa-chevron-left"></i> 安全牛：网络渗透与深度防御视频-整理笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/linux/第一周-Linux作为服务器操作系统的优势.html" rel="prev" title="Linux作为服务器操作系统的优势">
                Linux作为服务器操作系统的优势 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="posts/notes/《细说PHP》学习笔记.html"
           data-title="《细说PHP》学习笔记" data-url="http://uknowsec.cn/posts/notes/《细说PHP》学习笔记.html">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://obr4sfdq7.bkt.clouddn.com/avatar.jpg"
               alt="uknow" />
          <p class="site-author-name" itemprop="name">uknow</p>
          <p class="site-description motion-element" itemprop="description">不忘初心，方得始终</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">63</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/uknowsec" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3477219002" target="_blank">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  Others
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP的基本语法"><span class="nav-number">1.</span> <span class="nav-text">PHP的基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP第一个程序"><span class="nav-number">1.1.</span> <span class="nav-text">PHP第一个程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PHP语言标记"><span class="nav-number">1.1.1.</span> <span class="nav-text">PHP语言标记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PHP语言嵌入HTML中的位置"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">PHP语言嵌入HTML中的位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用四对不同的开始和结束标记"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">使用四对不同的开始和结束标记</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令分隔符-“分号”"><span class="nav-number">1.1.2.</span> <span class="nav-text">指令分隔符 “分号”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序注释"><span class="nav-number">1.1.3.</span> <span class="nav-text">程序注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的声明"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的命名"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变变量"><span class="nav-number">1.2.3.</span> <span class="nav-text">可变变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的引用赋值"><span class="nav-number">1.2.4.</span> <span class="nav-text">变量的引用赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的类型"><span class="nav-number">1.3.</span> <span class="nav-text">变量的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔型（boolean）"><span class="nav-number">1.3.2.</span> <span class="nav-text">布尔型（boolean）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#整型（integer）"><span class="nav-number">1.3.3.</span> <span class="nav-text">整型（integer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点型（float）"><span class="nav-number">1.3.4.</span> <span class="nav-text">浮点型（float）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串（string）"><span class="nav-number">1.3.5.</span> <span class="nav-text">字符串（string）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组（array）"><span class="nav-number">1.3.6.</span> <span class="nav-text">数组（array）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象（object）"><span class="nav-number">1.3.7.</span> <span class="nav-text">对象（object）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NULL类型"><span class="nav-number">1.3.8.</span> <span class="nav-text">NULL类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪类型介绍"><span class="nav-number">1.3.9.</span> <span class="nav-text">伪类型介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量"><span class="nav-number">1.4.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常量的定义和使用"><span class="nav-number">1.4.1.</span> <span class="nav-text">常量的定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义常量"><span class="nav-number">1.4.2.</span> <span class="nav-text">预定义常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP中的运算符"><span class="nav-number">1.5.</span> <span class="nav-text">PHP中的运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">1.5.1.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串运算符"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">字符串运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他运算符"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">其他运算符</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP语言结构"><span class="nav-number">2.</span> <span class="nav-text">PHP语言结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分支结构"><span class="nav-number">2.1.</span> <span class="nav-text">分支结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一条件分支结构（if）"><span class="nav-number">2.1.1.</span> <span class="nav-text">单一条件分支结构（if）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双向条件分支结构（else子句）"><span class="nav-number">2.1.2.</span> <span class="nav-text">双向条件分支结构（else子句）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多向条件分支结构（elseif子句）"><span class="nav-number">2.1.3.</span> <span class="nav-text">多向条件分支结构（elseif子句）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多向条件分支结构（switch语句）"><span class="nav-number">2.1.4.</span> <span class="nav-text">多向条件分支结构（switch语句）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#巢状条件分支结构"><span class="nav-number">2.1.5.</span> <span class="nav-text">巢状条件分支结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环结构"><span class="nav-number">2.2.</span> <span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while语句"><span class="nav-number">2.2.1.</span> <span class="nav-text">while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do…while循环"><span class="nav-number">2.2.2.</span> <span class="nav-text">do…while循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for语句"><span class="nav-number">2.2.3.</span> <span class="nav-text">for语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP中的函数"><span class="nav-number">2.3.</span> <span class="nav-text">PHP中的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明"><span class="nav-number">2.3.1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数的传递"><span class="nav-number">2.3.2.</span> <span class="nav-text">参数的传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量函数"><span class="nav-number">2.3.3.</span> <span class="nav-text">变量函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP中的数组与数据结构"><span class="nav-number">3.</span> <span class="nav-text">PHP中的数组与数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的概述"><span class="nav-number">3.1.</span> <span class="nav-text">数组的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的分类"><span class="nav-number">3.1.1.</span> <span class="nav-text">数组的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的定义"><span class="nav-number">3.2.</span> <span class="nav-text">数组的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直接复制的方式声明数组"><span class="nav-number">3.2.1.</span> <span class="nav-text">直接复制的方式声明数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用array-语言结构新建数组"><span class="nav-number">3.2.2.</span> <span class="nav-text">使用array()语言结构新建数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多维数组的声明"><span class="nav-number">3.2.3.</span> <span class="nav-text">多维数组的声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的遍历"><span class="nav-number">3.3.</span> <span class="nav-text">数组的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用for语句循环遍历数组"><span class="nav-number">3.3.1.</span> <span class="nav-text">使用for语句循环遍历数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用foreach语句遍历数组"><span class="nav-number">3.3.2.</span> <span class="nav-text">使用foreach语句遍历数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#联合使用list-、each-和while-循环遍历数组"><span class="nav-number">3.3.3.</span> <span class="nav-text">联合使用list()、each()和while()循环遍历数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用数组的内部指针控制函数遍历数组"><span class="nav-number">3.3.4.</span> <span class="nav-text">使用数组的内部指针控制函数遍历数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义数组"><span class="nav-number">3.4.</span> <span class="nav-text">预定义数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器变量：-SERVER"><span class="nav-number">3.4.1.</span> <span class="nav-text">服务器变量：$_SERVER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量：-ENV"><span class="nav-number">3.4.2.</span> <span class="nav-text">环境变量：$_ENV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-POST变量：-POST"><span class="nav-number">3.4.3.</span> <span class="nav-text">HTTP POST变量：$_POST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#request变量：-REQUEST"><span class="nav-number">3.4.4.</span> <span class="nav-text">request变量：$_REQUEST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP文件上传变量：-FILES"><span class="nav-number">3.4.5.</span> <span class="nav-text">HTTP文件上传变量：$_FILES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Cookies：-COOKIE"><span class="nav-number">3.4.6.</span> <span class="nav-text">HTTP Cookies：$_COOKIE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session变量：-SESSION"><span class="nav-number">3.4.7.</span> <span class="nav-text">Session变量：$_SESSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Global变量：-GLOBALS"><span class="nav-number">3.4.8.</span> <span class="nav-text">Global变量：$_GLOBALS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的相关处理函数"><span class="nav-number">3.5.</span> <span class="nav-text">数组的相关处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的键-值操作函数"><span class="nav-number">3.5.1.</span> <span class="nav-text">数组的键/值操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-value"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">函数array_value()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-key"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">函数array_key()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数in-array"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">函数in_array()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-flip"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">函数array_flip()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-reverse"><span class="nav-number">3.5.1.5.</span> <span class="nav-text">函数array_reverse()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#统计数组元素的个数和唯一性"><span class="nav-number">3.5.2.</span> <span class="nav-text">统计数组元素的个数和唯一性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数count"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">函数count()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-count-values"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">函数array_count_values()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-unique"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">函数array_unique()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用回调函数处理数组的函数"><span class="nav-number">3.5.3.</span> <span class="nav-text">使用回调函数处理数组的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-filter"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">函数array_filter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-walk"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">函数array_walk()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-map"><span class="nav-number">3.5.3.3.</span> <span class="nav-text">函数array_map()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的排序函数"><span class="nav-number">3.5.4.</span> <span class="nav-text">数组的排序函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单的数组排序函数"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">简单的数组排序函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据键名对数组排序"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">根据键名对数组排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据元素的值对数组排序"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">根据元素的值对数组排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据“自然排序”法对数组排序"><span class="nav-number">3.5.4.4.</span> <span class="nav-text">根据“自然排序”法对数组排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据用户自定的规则对数组排序"><span class="nav-number">3.5.4.5.</span> <span class="nav-text">根据用户自定的规则对数组排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多维数组的排序"><span class="nav-number">3.5.4.6.</span> <span class="nav-text">多维数组的排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拆分、合并、分解和接合数组"><span class="nav-number">3.5.5.</span> <span class="nav-text">拆分、合并、分解和接合数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-slice"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">函数array_slice()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-splice"><span class="nav-number">3.5.5.2.</span> <span class="nav-text">函数array_splice()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-combine"><span class="nav-number">3.5.5.3.</span> <span class="nav-text">函数array_combine()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-merge"><span class="nav-number">3.5.5.4.</span> <span class="nav-text">函数array_merge()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-intersect"><span class="nav-number">3.5.5.5.</span> <span class="nav-text">函数array_intersect()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-diff"><span class="nav-number">3.5.5.6.</span> <span class="nav-text">函数array_diff()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组与数据结构"><span class="nav-number">3.5.6.</span> <span class="nav-text">数组与数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用数组实现堆栈"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">使用数组实现堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用数组实现队列"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">使用数组实现队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他有用的数组处理函数"><span class="nav-number">3.5.7.</span> <span class="nav-text">其他有用的数组处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-rand"><span class="nav-number">3.5.7.1.</span> <span class="nav-text">函数array_rand()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数shuffle"><span class="nav-number">3.5.7.2.</span> <span class="nav-text">函数shuffle()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数array-sum"><span class="nav-number">3.5.7.3.</span> <span class="nav-text">函数array_sum()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数range"><span class="nav-number">3.5.7.4.</span> <span class="nav-text">函数range()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP面向对象的程序设计"><span class="nav-number">4.</span> <span class="nav-text">PHP面向对象的程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何抽象一个类"><span class="nav-number">4.1.</span> <span class="nav-text">如何抽象一个类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的声明"><span class="nav-number">4.1.1.</span> <span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员属性"><span class="nav-number">4.1.2.</span> <span class="nav-text">成员属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员方法"><span class="nav-number">4.1.3.</span> <span class="nav-text">成员方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过类实例化对象"><span class="nav-number">4.2.</span> <span class="nav-text">通过类实例化对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象"><span class="nav-number">4.2.1.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象类型在内存中的分配"><span class="nav-number">4.2.2.</span> <span class="nav-text">对象类型在内存中的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈空间段"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">栈空间段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆空间段"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">堆空间段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据段"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">数据段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码段"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">代码段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象中成员的访问"><span class="nav-number">4.2.3.</span> <span class="nav-text">对象中成员的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法与析构方法"><span class="nav-number">4.2.4.</span> <span class="nav-text">构造方法与析构方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#析构方法"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">析构方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装性"><span class="nav-number">4.3.</span> <span class="nav-text">封装性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置私有成员"><span class="nav-number">4.3.1.</span> <span class="nav-text">设置私有成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有成员的访问"><span class="nav-number">4.3.2.</span> <span class="nav-text">私有成员的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-、get-、isset-和unset-四种方法"><span class="nav-number">4.3.3.</span> <span class="nav-text">set()、get()、isset()和unset()四种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#魔术方法-set"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">魔术方法__set()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#魔法方法-get"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">魔法方法__get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#魔法方法isset-和unset"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">魔法方法isset()和unset()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承性"><span class="nav-number">4.4.</span> <span class="nav-text">继承性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类继承的应用"><span class="nav-number">4.4.1.</span> <span class="nav-text">类继承的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问类型控制"><span class="nav-number">4.4.2.</span> <span class="nav-text">访问类型控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公有的访问修饰符public"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">公有的访问修饰符public</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#私有的访问修饰符private"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">私有的访问修饰符private</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保护的访问修饰符protected"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">保护的访问修饰符protected</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的关键字和魔术方法"><span class="nav-number">4.5.</span> <span class="nav-text">常见的关键字和魔术方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final关键字的应用"><span class="nav-number">4.5.1.</span> <span class="nav-text">final关键字的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static和const关键字的使用"><span class="nav-number">4.5.2.</span> <span class="nav-text">static和const关键字的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static关键字"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const关键字"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">const关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆对象"><span class="nav-number">4.5.3.</span> <span class="nav-text">克隆对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类中通用的方法-toString"><span class="nav-number">4.5.4.</span> <span class="nav-text">类中通用的方法__toString()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-call-方法处理错误调用"><span class="nav-number">4.5.5.</span> <span class="nav-text">通过__call()方法处理错误调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象串行化"><span class="nav-number">4.5.6.</span> <span class="nav-text">对象串行化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类与接口"><span class="nav-number">4.6.</span> <span class="nav-text">抽象类与接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象方法和抽象类"><span class="nav-number">4.6.1.</span> <span class="nav-text">抽象方法和抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口技术"><span class="nav-number">4.6.2.</span> <span class="nav-text">接口技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串处理与正则表达式"><span class="nav-number">5.</span> <span class="nav-text">字符串处理与正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的处理介绍"><span class="nav-number">5.1.</span> <span class="nav-text">字符串的处理介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的处理方式"><span class="nav-number">5.1.1.</span> <span class="nav-text">字符串的处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串类型的特点"><span class="nav-number">5.1.2.</span> <span class="nav-text">字符串类型的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的字符串输出函数"><span class="nav-number">5.2.</span> <span class="nav-text">常用的字符串输出函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数echo"><span class="nav-number">5.2.1.</span> <span class="nav-text">函数echo()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数print"><span class="nav-number">5.2.2.</span> <span class="nav-text">函数print()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数die"><span class="nav-number">5.2.3.</span> <span class="nav-text">函数die()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数printf"><span class="nav-number">5.2.4.</span> <span class="nav-text">函数printf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数sprintf"><span class="nav-number">5.2.5.</span> <span class="nav-text">函数sprintf()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的字符串格式化函数"><span class="nav-number">5.3.</span> <span class="nav-text">常用的字符串格式化函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#取出空格和字符串填补函数"><span class="nav-number">5.3.1.</span> <span class="nav-text">取出空格和字符串填补函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串大小写转换"><span class="nav-number">5.3.2.</span> <span class="nav-text">字符串大小写转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和HTML标签相关的字符串格式化"><span class="nav-number">5.3.3.</span> <span class="nav-text">和HTML标签相关的字符串格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数nl2br"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">函数nl2br()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数htmlspecialchars"><span class="nav-number">5.3.4.</span> <span class="nav-text">函数htmlspecialchars()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他字符串格式化函数"><span class="nav-number">5.3.5.</span> <span class="nav-text">其他字符串格式化函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数strrev"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">函数strrev()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数number-format"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">函数number_format()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数md5"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">函数md5()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串比较函数"><span class="nav-number">5.4.</span> <span class="nav-text">字符串比较函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按字节顺序进行字符串比较"><span class="nav-number">5.4.1.</span> <span class="nav-text">按字节顺序进行字符串比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按自然排序进行字符串比较"><span class="nav-number">5.4.2.</span> <span class="nav-text">按自然排序进行字符串比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式在字符串处理中的应用"><span class="nav-number">5.5.</span> <span class="nav-text">正则表达式在字符串处理中的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与Perl兼容的正则表达式函数"><span class="nav-number">5.6.</span> <span class="nav-text">与Perl兼容的正则表达式函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP常用功能模块"><span class="nav-number">6.</span> <span class="nav-text">PHP常用功能模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期和时间"><span class="nav-number">6.1.</span> <span class="nav-text">日期和时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX时间戳"><span class="nav-number">6.1.1.</span> <span class="nav-text">UNIX时间戳</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将日期和时间转变成UNIX时间戳"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">将日期和时间转变成UNIX时间戳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日期计算"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">日期计算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在PHP中获取日期和时间"><span class="nav-number">6.1.2.</span> <span class="nav-text">在PHP中获取日期和时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期和时间格式化输出"><span class="nav-number">6.1.3.</span> <span class="nav-text">日期和时间格式化输出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统处理"><span class="nav-number">7.</span> <span class="nav-text">文件系统处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统概述"><span class="nav-number">7.1.</span> <span class="nav-text">文件系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件类型"><span class="nav-number">7.1.1.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件属性"><span class="nav-number">7.1.2.</span> <span class="nav-text">文件属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录的基本操作"><span class="nav-number">7.2.</span> <span class="nav-text">目录的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析目录路径"><span class="nav-number">7.2.1.</span> <span class="nav-text">解析目录路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数basename"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">函数basename()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数dirname"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">函数dirname()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数pathinfo"><span class="nav-number">7.2.1.3.</span> <span class="nav-text">函数pathinfo()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历目录"><span class="nav-number">7.2.2.</span> <span class="nav-text">遍历目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#统计目录大小"><span class="nav-number">7.2.3.</span> <span class="nav-text">统计目录大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建立和删除目录"><span class="nav-number">7.2.4.</span> <span class="nav-text">建立和删除目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制或移动目录"><span class="nav-number">7.2.5.</span> <span class="nav-text">复制或移动目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的基本操作"><span class="nav-number">7.3.</span> <span class="nav-text">文件的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件的打开与关闭"><span class="nav-number">7.3.1.</span> <span class="nav-text">文件的打开与关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数fopen"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">函数fopen()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数fclose"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">函数fclose()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入文件"><span class="nav-number">7.3.2.</span> <span class="nav-text">写入文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取文件内容"><span class="nav-number">7.3.3.</span> <span class="nav-text">读取文件内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数fread"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">函数fread()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数fgets-、fgetc"><span class="nav-number">7.3.3.2.</span> <span class="nav-text">函数fgets()、fgetc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数file"><span class="nav-number">7.3.3.3.</span> <span class="nav-text">函数file()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数readfile"><span class="nav-number">7.3.3.4.</span> <span class="nav-text">函数readfile()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问远程文件"><span class="nav-number">7.3.4.</span> <span class="nav-text">访问远程文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动文件指针"><span class="nav-number">7.3.5.</span> <span class="nav-text">移动文件指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的一些基本操作函数"><span class="nav-number">7.3.5.1.</span> <span class="nav-text">文件的一些基本操作函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的上传和下载"><span class="nav-number">7.4.</span> <span class="nav-text">文件的上传和下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件上传"><span class="nav-number">7.4.1.</span> <span class="nav-text">文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端上传设置"><span class="nav-number">7.4.1.1.</span> <span class="nav-text">客户端上传设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在服务器端通过PHP处理上传"><span class="nav-number">7.4.1.2.</span> <span class="nav-text">在服务器端通过PHP处理上传</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PHP配置文件中与文件上传有关的选项"><span class="nav-number">7.4.1.2.1.</span> <span class="nav-text">PHP配置文件中与文件上传有关的选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局数组-FILES中的元素说明"><span class="nav-number">7.4.1.2.2.</span> <span class="nav-text">全局数组$_FILES中的元素说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理多个文件上传"><span class="nav-number">7.4.2.</span> <span class="nav-text">处理多个文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件下载"><span class="nav-number">7.4.3.</span> <span class="nav-text">文件下载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL数据库设计"><span class="nav-number">8.</span> <span class="nav-text">MySQL数据库设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL数据库管理"><span class="nav-number">8.1.</span> <span class="nav-text">MySQL数据库管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构化查询语句SQL"><span class="nav-number">8.1.1.</span> <span class="nav-text">结构化查询语句SQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL数据库的连接与关闭"><span class="nav-number">8.1.2.</span> <span class="nav-text">MySQL数据库的连接与关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建、选择及查看数据库"><span class="nav-number">8.1.3.</span> <span class="nav-text">创建、选择及查看数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL数据库中数据表的设计"><span class="nav-number">8.2.</span> <span class="nav-text">MySQL数据库中数据表的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据表（Table）"><span class="nav-number">8.2.1.</span> <span class="nav-text">数据表（Table）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据值和列类型"><span class="nav-number">8.2.2.</span> <span class="nav-text">数据值和列类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组类的数据列类型"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">数组类的数据列类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串类数据列类型"><span class="nav-number">8.2.2.2.</span> <span class="nav-text">字符串类数据列类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日期和时间型数据列类型"><span class="nav-number">8.2.2.3.</span> <span class="nav-text">日期和时间型数据列类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NULL值"><span class="nav-number">8.2.2.4.</span> <span class="nav-text">NULL值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据字段属性"><span class="nav-number">8.2.3.</span> <span class="nav-text">数据字段属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UNSIGNED"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">UNSIGNED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZEROFILL"><span class="nav-number">8.2.3.2.</span> <span class="nav-text">ZEROFILL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AUTO-INCREMENT"><span class="nav-number">8.2.3.3.</span> <span class="nav-text">AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NULL和NOT-NULL"><span class="nav-number">8.2.3.4.</span> <span class="nav-text">NULL和NOT NULL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DEFAULT"><span class="nav-number">8.2.3.5.</span> <span class="nav-text">DEFAULT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建、修改及删除表"><span class="nav-number">8.2.4.</span> <span class="nav-text">创建、修改及删除表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建表（CREATE-TABLE）"><span class="nav-number">8.2.4.1.</span> <span class="nav-text">创建表（CREATE TABLE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改表（ALTER-TABLE）"><span class="nav-number">8.2.4.2.</span> <span class="nav-text">修改表（ALTER TABLE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除表（DROP-TABLE）"><span class="nav-number">8.2.4.3.</span> <span class="nav-text">删除表（DROP TABLE）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据表的类型及存储位置"><span class="nav-number">8.2.5.</span> <span class="nav-text">数据表的类型及存储位置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM数据表"><span class="nav-number">8.2.5.1.</span> <span class="nav-text">MyISAM数据表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB数据表"><span class="nav-number">8.2.5.2.</span> <span class="nav-text">InnoDB数据表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM和InnoDB两个表的功能简单对比"><span class="nav-number">8.2.5.3.</span> <span class="nav-text">MyISAM和InnoDB两个表的功能简单对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据表的默认字符集"><span class="nav-number">8.2.6.</span> <span class="nav-text">数据表的默认字符集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建索引"><span class="nav-number">8.2.7.</span> <span class="nav-text">创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主键索引（PRIMARY-KEY）"><span class="nav-number">8.2.7.1.</span> <span class="nav-text">主键索引（PRIMARY KEY）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#唯一索引（UNIQUE）"><span class="nav-number">8.2.7.2.</span> <span class="nav-text">唯一索引（UNIQUE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常规索引（INDEX）"><span class="nav-number">8.2.7.3.</span> <span class="nav-text">常规索引（INDEX）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全文索引（FULLTEXT）"><span class="nav-number">8.2.7.4.</span> <span class="nav-text">全文索引（FULLTEXT）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL语言设计"><span class="nav-number">8.3.</span> <span class="nav-text">SQL语言设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用DML命令操作数据表中的数据记录"><span class="nav-number">8.3.1.</span> <span class="nav-text">使用DML命令操作数据表中的数据记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用INSERT语句想数据表中添加数据"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">使用INSERT语句想数据表中添加数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用UPDATE语句更新数据表中已存在的数据"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">使用UPDATE语句更新数据表中已存在的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用DELETE语句删除数据表中不需要的数据记录"><span class="nav-number">8.3.1.3.</span> <span class="nav-text">使用DELETE语句删除数据表中不需要的数据记录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过DQL命令查询数据表中的数据"><span class="nav-number">8.3.2.</span> <span class="nav-text">通过DQL命令查询数据表中的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#选择特定的字段"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">选择特定的字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用AS子句为字段取别名"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">使用AS子句为字段取别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DISTINCT关键字的使用"><span class="nav-number">8.3.2.3.</span> <span class="nav-text">DISTINCT关键字的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在SELECT语句中使用表达式的列"><span class="nav-number">8.3.2.4.</span> <span class="nav-text">在SELECT语句中使用表达式的列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用WHERE子句按条件检索"><span class="nav-number">8.3.2.5.</span> <span class="nav-text">使用WHERE子句按条件检索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑操作符"><span class="nav-number">8.3.2.5.1.</span> <span class="nav-text">逻辑操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#比较操作符"><span class="nav-number">8.3.2.5.2.</span> <span class="nav-text">比较操作符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据空值（NULL）确定检索条件"><span class="nav-number">8.3.2.6.</span> <span class="nav-text">根据空值（NULL）确定检索条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用BETWEEN-AND进行范围比较查询"><span class="nav-number">8.3.2.7.</span> <span class="nav-text">使用BETWEEN AND进行范围比较查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用IN进行范围比较查询"><span class="nav-number">8.3.2.8.</span> <span class="nav-text">使用IN进行范围比较查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用LIKE进行模糊查询"><span class="nav-number">8.3.2.9.</span> <span class="nav-text">使用LIKE进行模糊查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多表查询（连接查询）"><span class="nav-number">8.3.2.10.</span> <span class="nav-text">多表查询（连接查询）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套查询（子查询）"><span class="nav-number">8.3.2.11.</span> <span class="nav-text">嵌套查询（子查询）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用ORDER-BY对查询结果排序"><span class="nav-number">8.3.2.12.</span> <span class="nav-text">使用ORDER BY对查询结果排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用LIMIT限定结构行数"><span class="nav-number">8.3.2.13.</span> <span class="nav-text">使用LIMIT限定结构行数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用统计函数"><span class="nav-number">8.3.2.14.</span> <span class="nav-text">使用统计函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用GROUP-BY对查询结构分组"><span class="nav-number">8.3.2.15.</span> <span class="nav-text">使用GROUP BY对查询结构分组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用PHP脚本向MySQL服务器发送SQL"><span class="nav-number">8.4.</span> <span class="nav-text">使用PHP脚本向MySQL服务器发送SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在PHP脚本中连接MySQL服务器"><span class="nav-number">8.4.1.</span> <span class="nav-text">在PHP脚本中连接MySQL服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在PHP程序中选择已创建的数据库"><span class="nav-number">8.4.2.</span> <span class="nav-text">在PHP程序中选择已创建的数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行SQL命令"><span class="nav-number">8.4.3.</span> <span class="nav-text">执行SQL命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在PHP脚本中处理SELECT查询结果集"><span class="nav-number">8.4.4.</span> <span class="nav-text">在PHP脚本中处理SELECT查询结果集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP的mysqli扩展"><span class="nav-number">9.</span> <span class="nav-text">PHP的mysqli扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启用mysqli扩展模块"><span class="nav-number">9.1.</span> <span class="nav-text">启用mysqli扩展模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用mysqli类"><span class="nav-number">9.2.</span> <span class="nav-text">使用mysqli类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysqli类中的成员方法"><span class="nav-number">9.2.1.</span> <span class="nav-text">mysqli类中的成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysqli类中的成员属性"><span class="nav-number">9.2.2.</span> <span class="nav-text">mysqli类中的成员属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接MySQL服务器"><span class="nav-number">9.2.3.</span> <span class="nav-text">连接MySQL服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理连接错误报告"><span class="nav-number">9.2.4.</span> <span class="nav-text">处理连接错误报告</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭与MySQL服务器连接"><span class="nav-number">9.2.5.</span> <span class="nav-text">关闭与MySQL服务器连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行SQL命令-1"><span class="nav-number">9.2.6.</span> <span class="nav-text">执行SQL命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用mysqli-result类"><span class="nav-number">9.3.</span> <span class="nav-text">使用mysqli_result类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从结果集中解析数据"><span class="nav-number">9.3.1.</span> <span class="nav-text">从结果集中解析数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#result-gt-fetch-row"><span class="nav-number">9.3.1.1.</span> <span class="nav-text">$result->fetch_row()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#result-gt-fetch-assoc"><span class="nav-number">9.3.1.2.</span> <span class="nav-text">$result->fetch_assoc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#result-gt-fetch-array"><span class="nav-number">9.3.1.3.</span> <span class="nav-text">$result->fetch_array()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#result-gt-fetch-object"><span class="nav-number">9.3.1.4.</span> <span class="nav-text">$result->fetch_object()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从结果集中获取数据列的信息"><span class="nav-number">9.3.2.</span> <span class="nav-text">从结果集中获取数据列的信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库抽象层PDO"><span class="nav-number">10.</span> <span class="nav-text">数据库抽象层PDO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PDO所支持的数据库"><span class="nav-number">10.1.</span> <span class="nav-text">PDO所支持的数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDO的安装"><span class="nav-number">10.2.</span> <span class="nav-text">PDO的安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建PDO对象"><span class="nav-number">10.3.</span> <span class="nav-text">创建PDO对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以多种方法调用构造方法"><span class="nav-number">10.3.1.</span> <span class="nav-text">以多种方法调用构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将参数嵌入到构造函数"><span class="nav-number">10.3.1.1.</span> <span class="nav-text">将参数嵌入到构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将参数存放在文件中"><span class="nav-number">10.3.1.2.</span> <span class="nav-text">将参数存放在文件中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用php-ini"><span class="nav-number">10.3.1.3.</span> <span class="nav-text">引用php.ini</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDO与连接有关选项"><span class="nav-number">10.3.1.4.</span> <span class="nav-text">PDO与连接有关选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PDO对象中的成员方法"><span class="nav-number">10.3.2.</span> <span class="nav-text">PDO对象中的成员方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用PDO对象"><span class="nav-number">10.4.</span> <span class="nav-text">使用PDO对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调整PDO的行为属性"><span class="nav-number">10.4.1.</span> <span class="nav-text">调整PDO的行为属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getAttribute"><span class="nav-number">10.4.1.1.</span> <span class="nav-text">getAttribute()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setAttribute"><span class="nav-number">10.4.1.2.</span> <span class="nav-text">setAttribute()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用PDO执行SQL语句"><span class="nav-number">10.4.2.</span> <span class="nav-text">使用PDO执行SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用PDO-exec-方法"><span class="nav-number">10.4.2.1.</span> <span class="nav-text">使用PDO::exec()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用PDO-query-方法"><span class="nav-number">10.4.2.2.</span> <span class="nav-text">使用PDO::query()方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDO对预处理语句的支持"><span class="nav-number">10.5.</span> <span class="nav-text">PDO对预处理语句的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解PDOStatement对象"><span class="nav-number">10.5.1.</span> <span class="nav-text">了解PDOStatement对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备语句"><span class="nav-number">10.5.2.</span> <span class="nav-text">准备语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定参数"><span class="nav-number">10.5.3.</span> <span class="nav-text">绑定参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行准备好的查询"><span class="nav-number">10.5.4.</span> <span class="nav-text">执行准备好的查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取数据"><span class="nav-number">10.5.5.</span> <span class="nav-text">获取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fetch-方法"><span class="nav-number">10.5.5.1.</span> <span class="nav-text">fetch()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fetchAll-方法"><span class="nav-number">10.5.5.2.</span> <span class="nav-text">fetchAll()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bindColumn-方法"><span class="nav-number">10.5.5.3.</span> <span class="nav-text">bindColumn()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大数据对象的存取"><span class="nav-number">10.5.5.4.</span> <span class="nav-text">大数据对象的存取</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#会话控制"><span class="nav-number">11.</span> <span class="nav-text">会话控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie的应用"><span class="nav-number">11.1.</span> <span class="nav-text">Cookie的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie概述"><span class="nav-number">11.1.1.</span> <span class="nav-text">Cookie概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向客户端电脑中设置Cookie"><span class="nav-number">11.1.2.</span> <span class="nav-text">向客户端电脑中设置Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在PHP脚本中读取Cookie的资料内容"><span class="nav-number">11.1.3.</span> <span class="nav-text">在PHP脚本中读取Cookie的资料内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组形态的Cookie应用"><span class="nav-number">11.1.4.</span> <span class="nav-text">数组形态的Cookie应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除Cookie"><span class="nav-number">11.1.5.</span> <span class="nav-text">删除Cookie</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session的应用"><span class="nav-number">11.2.</span> <span class="nav-text">Session的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">11.2.1.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置Session"><span class="nav-number">11.2.2.</span> <span class="nav-text">配置Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session的声明与使用"><span class="nav-number">11.2.3.</span> <span class="nav-text">Session的声明与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册一个会话变量和读取Session"><span class="nav-number">11.2.4.</span> <span class="nav-text">注册一个会话变量和读取Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注销变量与销毁Session"><span class="nav-number">11.2.5.</span> <span class="nav-text">注销变量与销毁Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递Session-ID"><span class="nav-number">11.2.6.</span> <span class="nav-text">传递Session ID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Cookie传递Session-ID"><span class="nav-number">11.2.6.1.</span> <span class="nav-text">通过Cookie传递Session ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过URL传递Session-ID"><span class="nav-number">11.2.6.2.</span> <span class="nav-text">通过URL传递Session ID</span></a></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">uknow</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3d5fd0365a60ecafb093d2d0df7aaf4c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>


  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>




  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"uknow"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("AxgSweQqwlurwh9jQb8ilgOQ-gzGzoHsz", "ex42kl7W8LVpx0umFqv5YSIa");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  

</body>
</html>
