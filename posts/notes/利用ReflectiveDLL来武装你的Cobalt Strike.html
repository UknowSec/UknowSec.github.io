<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 利用ReflectiveDLL来武装你的Cobalt Strike · Uknow - Stay hungry Stay foolish</title><meta name="description" content="利用ReflectiveDLL来武装你的Cobalt Strike - uknow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/2.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/2.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/uknowsec" target="_blank" class="nav-list-link">GitHub</a></li><li class="nav-list-item"><a href="http://weibo.com/uknowsec" target="_blank" class="nav-list-link">Weibo</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">利用ReflectiveDLL来武装你的Cobalt Strike</h1><div class="post-time">Jul 7, 2020</div><div class="post-content"><h3><span id="前言">前言</span></h3><p>Cobalt Strike已经成了目前工作中经常用渗透工具了，通常我们会通过写一下插件来武装自己的Cobalt Strike，比如我们会用<code>bexecute_assembly</code>来对自己编写的<code>Csharp</code>进行内存加载实现不落地。那么其他语言的呢？同样也提供了<a href="https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn" target="_blank" rel="noopener">bdllspawn</a>来反射DLL。本文章主要讲的就是利用反射DLL来武装自己的Cobalt Strike。</p>
<h3><span id="c-reflectivedll">C++ ReflectiveDLL</span></h3><p>首先将C/C++编写的程序如何进行ReflectiveDLL，Cobalt Strike的bdllspawn是基于项目<a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">ReflectiveDLLInjection</a>实现的。我们只需要把C++编写的功能写到<code>ReflectiveDll.c</code>里即可，这里参考<a href="https://payloads.online/archivers/2020-03-02/1" target="_blank" rel="noopener">倾旋</a>师傅的文章和工具。改写<code>ReflectiveDll.c</code>来实现传参。</p>
<h4><span id="参数转换">参数转换</span></h4><h5><span id="引用与定义">引用与定义</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ReflectiveLoader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shellapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Shell32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> szargs;</span><br><span class="line"><span class="built_in">std</span>::wstring wszargs;</span><br><span class="line"><span class="built_in">std</span>::wstring wsHostFile;</span><br><span class="line"><span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">LPWSTR* argv = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h5><span id="参数类型转换">参数类型转换</span></h5><p>在<code>ReflectiveDll.c</code>里是通过DLLMain函数的<code>lpReserved</code>来当做参数传递，我们可以做一个类型的转换，将<code>lpReserved</code>转换成命令行参数格式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">szargs = (PCHAR)lpReserved;</span><br><span class="line">wszargs = StringToWString(szargs);</span><br><span class="line">argv = CommandLineToArgvW(wszargs.data(), &amp;argc);</span><br></pre></td></tr></table></figure>
<h4><span id="功能编写">功能编写</span></h4><p>在转换参数后，我们就可以把一些C++功能代码写入，我这就简单编写一个参数输出功能，进行测试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hAppInstance = hinstDLL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C++ ReflectiveDLL\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* print some output to the operator */</span></span><br><span class="line"><span class="keyword">if</span> (lpReserved != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		szargs = (PCHAR)lpReserved;</span><br><span class="line">		wszargs = StringToWString(szargs);</span><br><span class="line">		argv = CommandLineToArgvW(wszargs.data(), &amp;argc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+] Error Arguments ! \n"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Args Count : %d \n"</span>, argc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">&#123;</span><br><span class="line">	wprintf(TEXT(<span class="string">"[%d] %s \n"</span>), i, argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* flush STDOUT */</span></span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we're done, so let's exit */</span></span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4><span id="aggressor-script">Aggressor Script</span></h4><p>编译<code>ReflectiveDll.c</code>得到一个dll文件，然后编写一个<code>Aggressor Script</code>脚本来加载它。</p>
<p>Aggressor Script脚本提供了一些关于反射DLL的接口：<a href="https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn" target="_blank" rel="noopener">https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias hello &#123;</span><br><span class="line">	$args = substr($0, 6);</span><br><span class="line">	bdllspawn($1, script_resource(&quot;reflective_dll.dll&quot;),$args, &quot;test dll&quot;, 5000, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="测试效果">测试效果</span></h4><p>这样我们就实现了将c++编写的dll通过ReflectiveDll来实现不落地传参执行了。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\image-20200708130204789.png" alt="image-20200708130204789"></p>
<h3><span id="golang-reflectivedll">Golang ReflectiveDLL</span></h3><p>Golang也成了现在一些安全工作者用得比较多的一种语言了，使用Golang开发的安全工具也越来越多，所以我们也可以通过ReflectiveDLL来对Golang程序进行利用。</p>
<p>这里参考<a href="https://wbglil.github.io/" target="_blank" rel="noopener">WBGlIl</a>师傅的项目<a href="https://github.com/WBGlIl/go-ReflectiveDLL" target="_blank" rel="noopener">go-ReflectiveDLL</a>和国外大佬的文章<a href="https://ethicalchaos.dev/2020/01/26/weaponizing-your-favorite-go-program-for-cobalt-strike/" target="_blank" rel="noopener">Weaponizing your favorite Go program for Cobalt Strike</a>。</p>
<p>特别感谢一下WBGlIl师傅，在我遇到问题的时候给予我的帮助~</p>
<h4><span id="maingo">main.go</span></h4><p>参考WBGlIl师傅的项目，将main.go改成一个传入参数并输出参数的功能，并将test函数设置为导出函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	gsq <span class="string">"github.com/kballard/go-shellquote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(arg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	args, err := gsq.Split(arg)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Golang ReflectiveDLL"</span>)</span><br><span class="line">		os.Args = args</span><br><span class="line">		fmt.Printf(<span class="string">"Args Count %d\n"</span>,<span class="built_in">len</span>(os.Args))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"[%d] %s\n"</span>,i,os.Args[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="dllmainc">dllmain.c</span></h4><p>参考老外文章将<code>lpReserved</code>转换为 <code>GoString</code>，传入到dll的导出函数test里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dllmain.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved)</span>   <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason) &#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        &#123;</span><br><span class="line">            GoString goArgs = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(lpReserved != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                goArgs.p = (<span class="keyword">char</span>*)lpReserved;</span><br><span class="line">                goArgs.n = <span class="built_in">strlen</span>(lpReserved);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                goArgs.p = <span class="string">""</span>;</span><br><span class="line">                goArgs.n = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            test(goArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">// Perform any necessary cleanup.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="comment">// Do thread-specific cleanup.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">		<span class="comment">// Do thread-specific initialization.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE; <span class="comment">// Successful.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行<code>WBGlIl</code>师傅的项目里的<code>x64.bat</code>来进行编译得到dll文件，但是Golang有一个最大的缺点就是编译出来的文件特别大，这里一个简单的输入输出工具生成的dll就有差不多2M。而在Cobalt Strike限制了反射DLL的DLL大小必须在1M以内，所以这里我们不能用Cobalt Strike进行测试。</p>
<h3><span id="injectc修改">Inject.c修改</span></h3><p>​    ReflectiveDLLInjection项目中的inject是不能给DLL进行传参的，所以我们这里需要修改代码来进行传参。</p>
<h4><span id="注入当前进程">注入当前进程</span></h4><p>如果对当前进程进行注入可以修改代码，将输入参数传入到<code>LoadRemoteLibraryR</code>函数的第四个参数即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPVOID lpParameter = argv[<span class="number">3</span>];</span><br><span class="line">hModule = LoadRemoteLibraryR( hProcess, lpBuffer, dwLength, lpParameter);</span><br></pre></td></tr></table></figure>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\image-20200708152051963.png" alt="image-20200708152051963"></p>
<h4><span id="注入到其他进程">注入到其他进程</span></h4><p>如果注入到其他进程的话，需要将参数写入到目标进程得到一个参数指针，再讲这个指针传入<code>LoadRemoteLibraryR</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">lpRemoteMem = arg;</span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">argSize = <span class="built_in">strlen</span>(arg);</span><br><span class="line">lpRemoteMem = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, argSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!lpRemoteMem)</span><br><span class="line">&#123;</span><br><span class="line">	BREAK_WITH_ERROR(<span class="string">"\t\t[!] FAILED to allocate memory in process.\n"</span>);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Memory allocated at : 0x%d in process %d\n"</span>, lpRemoteMem, dwProcessId);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Attempting to write parameter in  process %d \n"</span>, dwProcessId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将参数写入目标进程</span></span><br><span class="line">bWriteSuccess = WriteProcessMemory(hProcess, lpRemoteMem, arg, argSize, &amp;numBytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bWriteSuccess)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[!] FAILED to write parameter. Wrote %d  bytes instead of %d bytes.\n "</span>, numBytes ,argSize);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Wrote parameter in remote process %d memory.\n"</span>, dwProcessId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将参数指针传入</span></span><br><span class="line">hModule = LoadRemoteLibraryR( hProcess, lpBuffer, dwLength, lpRemoteMem);</span><br><span class="line"><span class="keyword">if</span>( !hModule )</span><br><span class="line">	BREAK_WITH_ERROR( <span class="string">"Failed to inject the DLL"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"[+] Injected the '%s' DLL into process %d.\n"</span>, cpDllFile, dwProcessId);</span><br></pre></td></tr></table></figure>
<p>因为这里是注入到了其他进程里，所以当前进程是没有输出的。如果需要输出的话，可以修改DLL文件和Inject.c，即当前进程和DLL注入的进程之间用命名管道进行通信。这里以C++写的DLL为例。</p>
<h5><span id="injectc">inject.c</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收</span></span><br><span class="line"></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>] = <span class="string">""</span>;</span><br><span class="line">DWORD rlen = <span class="number">0</span>;</span><br><span class="line">HANDLE hPipe = CreateNamedPipe(</span><br><span class="line">	TEXT(<span class="string">"\\\\.\\Pipe\\mypipe"</span>),						<span class="comment">//管道名</span></span><br><span class="line">	PIPE_ACCESS_DUPLEX,									<span class="comment">//管道类型 </span></span><br><span class="line">	PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,	<span class="comment">//管道参数</span></span><br><span class="line">	PIPE_UNLIMITED_INSTANCES,							<span class="comment">//管道能创建的最大实例数量</span></span><br><span class="line">	<span class="number">0</span>,													<span class="comment">//输出缓冲区长度 0表示默认</span></span><br><span class="line">	<span class="number">0</span>,													<span class="comment">//输入缓冲区长度 0表示默认</span></span><br><span class="line">	NMPWAIT_WAIT_FOREVER,								<span class="comment">//超时时间</span></span><br><span class="line">	<span class="literal">NULL</span>);													<span class="comment">//指定一个SECURITY_ATTRIBUTES结构,或者传递零值.</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hPipe)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+] Create Pipe Error(%d)\n"</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+] Create Pipe Success\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+] Waiting For Client Connection...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (ConnectNamedPipe(hPipe, <span class="literal">NULL</span>) == <span class="literal">NULL</span>)	<span class="comment">//阻塞等待客户端连接。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+] Connection failed!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+] Connection Success!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+] Data From Pipe :\n\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ReadFile(hPipe, buf, <span class="number">256</span>, &amp;rlen, <span class="literal">NULL</span>)) <span class="comment">//接受客户端发送过来的内容</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\t%s"</span>, buf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n[+] Read Data From Pipe End!\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hPipe);<span class="comment">//关闭管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="reflectivedllcpp">ReflectiveDll.cpp</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用命名管道传输</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line">DWORD wlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">BOOL bRet = WaitNamedPipe(TEXT(<span class="string">"\\\\.\\Pipe\\mypipe"</span>), NMPWAIT_WAIT_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"connect the namedPipe failed!\n"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE hPipe = CreateFile(			<span class="comment">//管道属于一种特殊的文件</span></span><br><span class="line">	TEXT(<span class="string">"\\\\.\\Pipe\\mypipe"</span>),	<span class="comment">//创建的文件名</span></span><br><span class="line">	GENERIC_READ | GENERIC_WRITE,	<span class="comment">//文件模式</span></span><br><span class="line">	<span class="number">0</span>,								<span class="comment">//是否共享</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">//指向一个SECURITY_ATTRIBUTES结构的指针</span></span><br><span class="line">	OPEN_EXISTING,					<span class="comment">//创建参数</span></span><br><span class="line">	FILE_ATTRIBUTE_NORMAL,			<span class="comment">//文件属性(隐藏,只读)NORMAL为默认属性</span></span><br><span class="line">	<span class="literal">NULL</span>);							<span class="comment">//模板创建文件的句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hAppInstance = hinstDLL;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>] = <span class="string">""</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"C++ ReflectiveDLL\n"</span>);</span><br><span class="line">WriteFile(hPipe, buf, <span class="keyword">sizeof</span>(buf), &amp;wlen, <span class="number">0</span>);	<span class="comment">//向服务器发送内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* print some output to the operator */</span></span><br><span class="line"><span class="keyword">if</span> (lpReserved != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	szargs = (PCHAR)lpReserved;</span><br><span class="line">	wszargs = StringToWString(szargs);</span><br><span class="line">	argv = CommandLineToArgvW(wszargs.data(), &amp;argc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">"Hello from test.dll. There is no parameter\n"</span>);</span><br><span class="line">	WriteFile(hPipe, buf, <span class="keyword">sizeof</span>(buf), &amp;wlen, <span class="number">0</span>);	<span class="comment">//向服务器发送内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">"[+] Error Arguments ! \n"</span>);</span><br><span class="line">	WriteFile(hPipe, buf, <span class="keyword">sizeof</span>(buf), &amp;wlen, <span class="number">0</span>);	<span class="comment">//向服务器发送内容</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"[+] Args Count : %d \n"</span>, argc);</span><br><span class="line">WriteFile(hPipe, buf, <span class="keyword">sizeof</span>(buf), &amp;wlen, <span class="number">0</span>);	<span class="comment">//向服务器发送内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">"[%d] %s \n"</span>, i, argv[i]);</span><br><span class="line">	WriteFile(hPipe, buf, <span class="keyword">sizeof</span>(buf), &amp;wlen, <span class="number">0</span>);	<span class="comment">//向服务器发送内容</span></span><br><span class="line">&#125;</span><br><span class="line">	CloseHandle(hPipe);<span class="comment">//关闭管道</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* flush STDOUT */</span></span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we're done, so let's exit */</span></span><br><span class="line">	ExitProcess(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样就可以实现读取注入目标进程的输出了。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\image-20200708152800733.png" alt="image-20200708152800733"></p>
<h3><span id="示例代码">示例代码</span></h3><p><a href="https://github.com/uknowsec/ReflectiveDLLInjection-Notes" target="_blank" rel="noopener">https://github.com/uknowsec/ReflectiveDLLInjection-Notes</a></p>
<h3><span id="结语">结语</span></h3><p>在<code>WBGlIl</code>师傅的帮助下，学习了ReflectiveDLL。本意是想用于Cobalt Strike插件的开发，但是Golang编译后的文件过大，导致Cobalt Strike并不能进行加载反射。有请教过别的师傅如何解决这个问题，方案好像都必须得落地待反射的Golang DLL，效果并不是太好。同时在最近新发布的Cobalt Strike4.1中有了一个新功能Beacon Object File (BOF)，他可以解决文件过大的问题。</p>
<p>在官方文档<a href="https://www.cobaltstrike.com/help-beacon-object-files" target="_blank" rel="noopener">help-beacon-object-files</a>有如下的一段话：</p>
<blockquote>
<p>BOFs are also very small. A UAC bypass privilege escalation Reflective DLL implementation may weigh in at 100KB+. The same exploit, built as a BOF, is &lt;3KB. This can make a big difference when using bandwidth constrained channels, such as DNS.</p>
</blockquote>
<p>所以现在就差一个Cobalt Strike4.1啦~</p>
<h3><span id="references">References</span></h3><p><code>[1]</code> bdllspawn: <em><a href="https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn" target="_blank" rel="noopener">https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn</a></em><br><code>[2]</code> ReflectiveDLLInjection: <em><a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">https://github.com/stephenfewer/ReflectiveDLLInjection</a></em><br><code>[3]</code> 倾旋: <em><a href="https://payloads.online/archivers/2020-03-02/1" target="_blank" rel="noopener">https://payloads.online/archivers/2020-03-02/1</a></em><br><code>[4]</code> WBGlIl: <em><a href="https://wbglil.github.io/" target="_blank" rel="noopener">https://wbglil.github.io/</a></em><br><code>[5]</code> go-ReflectiveDLL: <em><a href="https://github.com/WBGlIl/go-ReflectiveDLL" target="_blank" rel="noopener">https://github.com/WBGlIl/go-ReflectiveDLL</a></em><br><code>[6]</code> Weaponizing your favorite Go program for Cobalt Strike: <em><a href="https://ethicalchaos.dev/2020/01/26/weaponizing-your-favorite-go-program-for-cobalt-strike/" target="_blank" rel="noopener">https://ethicalchaos.dev/2020/01/26/weaponizing-your-favorite-go-program-for-cobalt-strike/</a></em><br><code>[7]</code> help-beacon-object-files: <em><a href="https://www.cobaltstrike.com/help-beacon-object-files" target="_blank" rel="noopener">https://www.cobaltstrike.com/help-beacon-object-files</a></em></p>
</div></article></div></section><footer><div class="paginator"><a href="/posts/notes/frsocks+protoplex+流量重定向实现端口复用.html" class="prev">上一篇</a><a href="/posts/notes/FRP改造计划.html" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2024 <a href="https://uknowsec.cn">uknow</a>  Stay hungry,Stay foolish.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-115504647-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?225ebcce29d319519ac7c7690425d1d4";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>