<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Uknow, uknowsec.cn, uknowsec" />





  <link rel="alternate" href="/atom.xml" title="Uknow’s Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="点击阅读全文">
<meta property="og:type" content="article">
<meta property="og:title" content="《TCP/IP详解 卷1：协议》学习笔记">
<meta property="og:url" content="http://uknowsec.cn/posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html">
<meta property="og:site_name" content="Uknow’s Blog">
<meta property="og:description" content="点击阅读全文">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/141924136983820.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/142117348856117.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/141953434648847.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/141957475736336.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/142010446984287.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/142010578707763.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/142022372296370.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/142028379795759.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/151053134953465.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/151227346352054.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/151336240428797.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/151400284327893.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/151420134957085.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/151428393854765.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/161409216674369.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/161438232606801.png">
<meta property="og:image" content="http://news.edu-chn.com/newsadmin/upload_images/1115277097522.JPG">
<meta property="og:image" content="http://news.edu-chn.com/newsadmin/upload_images/1115277119522.JPG">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/171403295891545.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/171404494796569.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/182021092763762.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/182028596987012.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/182051571674088.png">
<meta property="og:image" content="http://www.vants.org/content/plugins/kl_album/upload/201209/98e326f50f0ae0ca8723ba653376c7c020120914093556873290427.png">
<meta property="og:image" content="http://www.vants.org/content/plugins/kl_album/upload/201209/726cb8dcdc4764f2cc1559c89ffde637201209161035261080797373.png">
<meta property="og:image" content="http://www.vants.org/content/plugins/kl_album/upload/201209/d8007e7cdb19d6455234a654b47ab31b2012091409355588821205.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/192207023854764.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/201851308717804.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/201854533243954.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/201900206052867.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/201922374028201.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/201955518555818.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/202037158396912.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150414163431439">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/uknow4.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/uknow5.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/uknow3.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/uknow.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/uknow1.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170421202212.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170422232852.jpg">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/211857142503378.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/211907360933802.png">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/211955147184376.png">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE2017042317114.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170423172522.jpg">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/212127065468647.png">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424210136.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205607.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205406.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205651.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205746.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205832.jpg">
<meta property="og:image" content="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205918.jpg">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/697266/201504/212155080782897.png">
<meta property="og:updated_time" content="2017-04-24T14:41:27.800Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《TCP/IP详解 卷1：协议》学习笔记">
<meta name="twitter:description" content="点击阅读全文">
<meta name="twitter:image" content="http://images.cnitblog.com/blog2015/697266/201504/141924136983820.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6316725929833924000,
      author: 'Uknow'
    }
  };
</script>

  <title> 《TCP/IP详解 卷1：协议》学习笔记 | Uknow’s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?225ebcce29d319519ac7c7690425d1d4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Uknow’s Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                《TCP/IP详解 卷1：协议》学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-15T21:08:21+08:00" content="2017-04-15">
              2017-04-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/notes/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html" class="leancloud_visitors" data-flag-title="《TCP/IP详解 卷1：协议》学习笔记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>点击阅读全文<br><a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/141924136983820.png" alt=""></p>
<ul>
<li>链路层：处理与电缆（或其他任何传输媒介）的物理接口细节（Telnet,FTP和e-mail等）</li>
<li>网络层：处理分组在网络中的活动，例如分组选路（TCP和UDP）</li>
<li>运输层：为两台主机上的应用程序提供端到端的通讯（IP,ICMP和IGMP）</li>
<li>应用层：处理特定的应用程序细节（设备驱动程序及接口卡）</li>
</ul>
<h2 id="实例：运行FTP的两台主机"><a href="#实例：运行FTP的两台主机" class="headerlink" title="实例：运行FTP的两台主机"></a>实例：运行FTP的两台主机</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/142117348856117.png" alt=""></p>
<ul>
<li>大多数的网络应用程序都被设计成客户-服务器模式</li>
<li>双方都有对应的一个或多个协议进行通讯</li>
<li>应用程序通常是用户进程，而下三层一般在内核执行</li>
<li>应用层关心应用程序的细节，下三层对应用程序一无所知，但它要处理所有的通信细节</li>
</ul>
<h2 id="通过路由器连接的两个网络"><a href="#通过路由器连接的两个网络" class="headerlink" title="通过路由器连接的两个网络"></a>通过路由器连接的两个网络</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/141953434648847.png" alt=""></p>
<ul>
<li>端系统（end system）（两边的两台主机）</li>
<li>中间系统（intermediate system）（中间的路由器）</li>
<li>应用层和运输层使用端到端（end-to-end）协议</li>
<li>网络层提供的是逐跳（hop-to-hop）协议</li>
<li>网络ip提供的是一种不可靠的服务，它只是尽可能快的把分组从源结点送到目的结点，但不提供可靠的运输层</li>
<li>互联网的目的之一就是在应用程序中隐藏所有的屋里细节</li>
</ul>
<h2 id="TCP-IP协议族中不同层次的协议"><a href="#TCP-IP协议族中不同层次的协议" class="headerlink" title="TCP/IP协议族中不同层次的协议"></a>TCP/IP协议族中不同层次的协议</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/141957475736336.png" alt=""></p>
<ul>
<li>TCP使用不可靠的IP服务，并提供一种可靠的运输层服务</li>
<li>UDP为应用程序发送和接受数据报，和TCP不同，UDP是不可靠的。</li>
<li>IP是网络层上的主要协议，同时被TCP和UDP使用</li>
<li>ICMP是IP协议的附属协议</li>
<li>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机</li>
<li>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
</ul>
<h2 id="互联网的地址"><a href="#互联网的地址" class="headerlink" title="互联网的地址"></a>互联网的地址</h2><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32bit。IP地址具有一定的结构，五类不同的互联网地址格式如图1-5所示。<br><img src="http://images.cnitblog.com/blog2015/697266/201504/142010446984287.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/142010578707763.png" alt=""></p>
<p>说明：</p>
<ul>
<li><p>多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。</p>
</li>
<li><p>有三类IP地址：单播地址（目的端为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）。</p>
</li>
</ul>
<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/142022372296370.png" alt=""></p>
<ul>
<li>以太网数据帧的物理特征是其长度必须在46~1500字节之间</li>
<li>以太网的帧首部也有一个16bit的帧类型域（ip,arp,rarp）</li>
<li>IP在首部中存放一个长度为8bit的数值，称作协议域（icmp,igmp,tcp,udp,esp,gre）。1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议</li>
<li>TCP和UDP都用一个16bit的端口号来表示不同的应用程序（ftp,telnet,http）</li>
</ul>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接受数据的上层协议。这个过程称作分用。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/142028379795759.png" alt=""></p>
<h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户-服务器模型"></a>客户-服务器模型</h2><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。服务分为两种类型：重复型和并发型。</p>
<h3 id="重复型服务器"><a href="#重复型服务器" class="headerlink" title="重复型服务器"></a>重复型服务器</h3><p>1）等待一个客户请求的到来。<br>2）处理客户请求。<br>3）发送响应给发送请求的客户。<br>4）返回1）步。</p>
<p>重复型服务器主要的问题发生在2）状态。在这个时候，它不能为其他客户机提供服务。</p>
<h3 id="并发型服务器"><a href="#并发型服务器" class="headerlink" title="并发型服务器"></a>并发型服务器</h3><p>1）等待一个客户请求的到来。<br>2）启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。</p>
<p>3）返回1）步。</p>
<p>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。每个客户都有它自己对应的服务器。如果操作系统允许多任务，那么就可以同时为多个客户服务。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul>
<li>服务器一般都是通过知名端口号来识别的（ftp 21,telnet 23）</li>
<li>客户端端口号又称作临时端口号（即存在时间很短暂）</li>
<li>大多数TCP/IP实现给临时端口分配1024~5000之间的端口号</li>
<li>大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务）</li>
</ul>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>从图1-4可以看出，在TCP/IP协议族中，链路层主要有三个目的：<br><img src="http://images.cnitblog.com/blog2015/697266/201504/151053134953465.png" alt=""></p>
<ul>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答。</li>
<li>为RARP发送RARP请求和接收RARP应答。</li>
</ul>
<p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。</p>
<h2 id="以太网和IEEE-802封装"><a href="#以太网和IEEE-802封装" class="headerlink" title="以太网和IEEE 802封装"></a>以太网和IEEE 802封装</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/151227346352054.png" alt=""></p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li>以太网这个术语一般是指数字设备公司、英特尔公司和Xerox公司在1982年联合公布的一个标准</li>
<li>它采用一种称作CSMA/CD的媒体接入方法。</li>
<li>它的速率为10Mb/s，地址为48bit</li>
</ul>
<h3 id="IEEE-802封装"><a href="#IEEE-802封装" class="headerlink" title="IEEE 802封装"></a>IEEE 802封装</h3><ul>
<li>802.3针对整个CSMA/CD网络</li>
<li>802.4针对令牌总线网络</li>
<li>802.5针对令牌环网络</li>
<li>这三者的共同特性由802.2标准来定义，那就是802网络共有的逻辑链路控制（LLC）</li>
</ul>
<h2 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h2><ul>
<li>两种帧格式都采用48bit(6字节)的目的地址和源地址</li>
<li>ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射</li>
<li>802定义的有效长度值与以太网的有效类型值无一相同，这样就可以对两种帧格式进行区分</li>
<li>母的服务访问点（DSAP）和源服务访问点（SSAP）的值都设为0xaa。Ctr1字段的值设为3.随后的3个字节orgcode都置为0.再接下来的2个字节类型字段和以太网帧格式一样。</li>
<li>802.3规定数据分布必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</li>
</ul>
<h2 id="SLIP：串行线路IP"><a href="#SLIP：串行线路IP" class="headerlink" title="SLIP：串行线路IP"></a>SLIP：串行线路IP</h2><p>SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式。SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。下面的规则描述了SLIP协议定义的帧格式：</p>
<ul>
<li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符。</li>
<li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLI的ESC字符。</li>
<li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li>
</ul>
<p>图2-2中的例子就是含有一个END字符和一个ESC字符的IP报文。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/151336240428797.png" alt=""></p>
<p>SLIP是一种简单的帧封装方法，值得一提的缺陷：</p>
<ul>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输报文被线路噪声影响而发生错误，只能通过上层协议来发现。</li>
</ul>
<p>尽管存在这些缺点，SLIP仍然是一种广泛使用的协议。</p>
<h2 id="PPP：点对点协议"><a href="#PPP：点对点协议" class="headerlink" title="PPP：点对点协议"></a>PPP：点对点协议</h2><p>PPP点对点协议修改了SLIP协议中的所有缺陷。包括三个部分：</p>
<ul>
<li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。</li>
</ul>
<p>图2-3是PPP数据帧的格式。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/151400284327893.png" alt=""></p>
<ul>
<li>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</li>
<li>协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个 IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。</li>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>标志字符0x7e出现在信息字段中时，PPP需要对它进行转义。</li>
</ul>
<p>总的来说，PPP比SLIP具有下面这些优点：</p>
<ul>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。</li>
</ul>
<p>为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</p>
<h2 id="环回接口"><a href="#环回接口" class="headerlink" title="环回接口"></a>环回接口</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/151420134957085.png" alt=""></p>
<ul>
<li>传给换回地址（一般是127.0.0.1）任何数据均作为IP输入（都能ping通）</li>
<li>传给广播地址或多播地址报复制一份传给环回接口，然后送给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身</li>
<li>任何传给该主机IP地址的数据均送到环回接口</li>
</ul>
<h2 id="MTU和路径MTU"><a href="#MTU和路径MTU" class="headerlink" title="MTU和路径MTU"></a>MTU和路径MTU</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/151428393854765.png" alt=""></p>
<ul>
<li>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特征称作MTU，最大传输单元</li>
<li>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片（fragmentation）,把数据报分成若干片，这样每一片都小于MTU</li>
<li>点到点的链路层（如SLIP和PPP）和MTU并非指的是网络媒体的物理特性。相反，它是一个逻辑限制，母的是为交互使用提供足够快的响应时间</li>
<li>两台通信主机路径中的最小MTU。它被称作路径MTU</li>
<li>路径MTU在两个方向上不一定是一致的</li>
<li>MTU是计算出方向的</li>
</ul>
<h2 id="串行线路吞吐量计算"><a href="#串行线路吞吐量计算" class="headerlink" title="串行线路吞吐量计算"></a>串行线路吞吐量计算</h2><p>如果线路速率是9600b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960B/s（字节/秒）。以这个速率传输一个1024字节的分组需要1066ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间（533ms）才能把交互式应用程序的分组数据发送出去。</p>
<p>对于交互应用来说，等待533ms是不能接受的。研究表明，交互响应时间超过100~200ms就被认为是不好的，这是发送一份交互报文出去后，直到接收到响应信息（通常是出现一个回显字符）为止的往返时间。</p>
<p>注意：我们对平均等待时间的计算（传输最大数据帧所需时间的一半）只适用于SLIP链路（或PPP链路）在交互通信和大块数据传输这两种情况下。</p>
<h1 id="IP：网际协议"><a href="#IP：网际协议" class="headerlink" title="IP：网际协议"></a>IP：网际协议</h1><h2 id="IP介绍"><a href="#IP介绍" class="headerlink" title="IP介绍"></a>IP介绍</h2><ul>
<li>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li>
<li>IP提供不可靠、无连接的数据报传送服务</li>
<li>不可靠（unreliable）的意思是它不能保证IP数据报能成功到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）</li>
<li>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是互相独立的。IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，课时选择不同的路线，因此B可能在A到达之前先到达。</li>
</ul>
<h2 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/161409216674369.png" alt=""></p>
<ul>
<li>4个字节的32bit值以下面的次序传输：首先是0~7bit，其次8~15bit，然后16~23bit，最后是24、·31bit。这种传输次序称作big endian字节序。由于TVP|IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序</li>
<li>目前的协议版本号是4，因此IP有时也称作IPv4</li>
<li>首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4bit字段，因此首部最长为60个字节</li>
<li>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS字段和1bit未用位但必须置0</li>
<li>服务类型（TOS）字段包括一个3 bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位，但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。 4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。图3-2列出了对不同应用建议的TOS值。</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/161438232606801.png" alt=""></p>
<p>注意：现在大多数的TCP/IP实现都不支持TOS特性。</p>
<ul>
<li>总长度字段是指整个IP数据报的长度，以字节为单位。由于该字段长16比特，所以IP数据报最长可达65535字节。<br>注意：尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片。而且，主机也要求不能接收超过576字节的数据报。</li>
<li>标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</li>
<li>TTL生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。 TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
<li>协议字段，它可以识别是哪个协议向IP传送数据。</li>
<li>首部检验和字段是根据IP首部计算的检验和码。</li>
<li>如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传</li>
<li>由于路由器经常只修改TTL字段（减1），因为当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算</li>
<li>任选项，是数据报中的一个可变长的可选信息。这些选项很少被使用，并非所有的主机和路由器都支持这些选项。</li>
</ul>
<h2 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h2><h3 id="路由表中的包含信息"><a href="#路由表中的包含信息" class="headerlink" title="路由表中的包含信息"></a>路由表中的包含信息</h3><ul>
<li>目的IP地址。<br>它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。</li>
<li>下一跳路由器的IP地址，或者有直接连接的网络IP地址。<br>下一跳路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一跳路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。</li>
<li>标志。<br>其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一跳路由器是否为真正的下一跳路由器，还是一个直接相连的接口。</li>
<li>为数据报的传输指定一个网络接口。</li>
</ul>
<h3 id="路由选择完成的功能"><a href="#路由选择完成的功能" class="headerlink" title="路由选择完成的功能"></a>路由选择完成的功能</h3><p>IP路由选择是逐跳地进行的。IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。所有的IP路由选择只为数据报传输提供下一跳路由器的IP地址。它假定下一跳路由器比发送数据报的主机更接近目的，而且下一跳路由器与该主机是直接相连的。</p>
<ul>
<li>搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。</li>
<li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li>
<li>搜索路由表，寻找标为“默认”的表目。如果找到，则把报文发送给该表目指定的下一站路由器</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="http://news.edu-chn.com/newsadmin/upload_images/1115277097522.JPG" alt=""></p>
<p><img src="http://news.edu-chn.com/newsadmin/upload_images/1115277119522.JPG" alt=""></p>
<p>对于这个例子需要指出一些关键点：</p>
<ul>
<li>该例子中所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器可以用默认路由来处理任何目的，除非它在本地局域网上</li>
<li>数据报中的目的IP地址始终不发生任何变化。所有的路由选择决策都是基于这个目的IP地址</li>
<li>每个链路层可能具有不同数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网地址的链路层首部，但是SLIP链路没有这样做。以太网地址一般通过ARP获得。</li>
</ul>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>任何主机在引导时进行的部分配置是指定主机IP地址。除了此以外，还需要知道有多少比特用于子网号和多少比特用于主机号。这是在引导过程中通过子网掩码来确定的。子网掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p>
<p>例如：一个B类地址的两种不同的子网掩码格式。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/171403295891545.png" alt=""></p>
<p>第一个例子，子网号和主机号都是8 bit。第二个例子，子网号是10 bit，主机号是6 bit。</p>
<h2 id="特殊情况的IP地址"><a href="#特殊情况的IP地址" class="headerlink" title="特殊情况的IP地址"></a>特殊情况的IP地址</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/171404494796569.png" alt=""></p>
<ul>
<li>0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分</li>
<li>表的头两项是特殊的源地址，中间是特殊的环回地址，最后四项是广播地址</li>
<li>表中的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现</li>
</ul>
<h1 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h1><h2 id="ARP介绍"><a href="#ARP介绍" class="headerlink" title="ARP介绍"></a>ARP介绍</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/182021092763762.png" alt=""></p>
<ul>
<li>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址</li>
<li>地址解析为这两种不同的地址形式提供映射：32bit的IP地址和数据链路层使用的任何类型的地址（FR环境）</li>
<li>ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心</li>
<li>RARP是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或X终端），它需要系统管理员进行手工设置</li>
</ul>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/182028596987012.png" alt=""></p>
<p>当敲入以下命令时：ftp bsdi（主机名），会发生下列步骤：</p>
<ul>
<li>应用程序FTP客户端调用函数gethostbyname把主机名（bsdi）转换成32 bit的IP地址。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts）。</li>
<li>FTP客户端请求TCP用得到的IP地址建立连接。</li>
<li>TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报。</li>
<li>如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。</li>
<li>假定是一个以太网，那么发送端主机必须把32 bit的IP地址变换成48 bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译，这是ARP的功能。</li>
<li>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机，这个过程称作广播。ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</li>
<li>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li>
<li>收到ARP应答后，使ARP进行请求-应答交换的IP数据报现在就可以传送了。</li>
<li>发送IP数据报到目的主机。</li>
</ul>
<p>说明：</p>
<ul>
<li>在ARP背后有一个基本概念，就是网络接口有一个硬件地址（一个48 bit的值，标识不同的以太网或令牌环网络接口）。</li>
<li>在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP/IP有自己的地址：32 bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。</li>
<li>ARP的功能是在32 bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。</li>
<li>点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。像以太网地址这样的硬件地址并不涉及。</li>
</ul>
<h2 id="ARP背后的一个基本概念"><a href="#ARP背后的一个基本概念" class="headerlink" title="ARP背后的一个基本概念"></a>ARP背后的一个基本概念</h2><ul>
<li>在ARP背后有一个概念，那就是网络接口有一个硬件地址（一个48bit的值，标识不同的以太网或令牌环网络接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP|IP有自己的地址：32bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。内核必须知道目的端的硬件地址才能发送数据。ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射</li>
<li>点对点链路不好使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端IP的地址。像以太网地址这样的硬件地址并不涉及</li>
</ul>
<h2 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h2><ul>
<li>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Intern et地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。</li>
<li>可用arp命令来检查ARP高速缓存。-a的意思是显示高速缓存中所有的内容。</li>
<li>48 bit的以太网地址用6个十六进制的数来表示，中间以冒号隔开。</li>
</ul>
<h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arp -a	查看缓存</div><div class="line">arp -d  清除缓存</div></pre></td></tr></table></figure>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">show arp	查看缓存</div><div class="line">clear arp	清除缓存</div></pre></td></tr></table></figure>
<h2 id="ARP的分组格式"><a href="#ARP的分组格式" class="headerlink" title="ARP的分组格式"></a>ARP的分组格式</h2><p>在以太网上解析IP地址时，ARP请求和应答分组的格式如图4-3所示（ARP可以用于其他类型的网络，可以解析IP地址以外的地址。紧跟着帧类型字段的前四个字段指定了最后四个字段的类型和长度）</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/182051571674088.png" alt=""></p>
<h3 id="ARP包字段分析"><a href="#ARP包字段分析" class="headerlink" title="ARP包字段分析"></a>ARP包字段分析</h3><ul>
<li>前两个字段是以太网的源地址和目的地址。目的地址为全1的地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧。</li>
<li>以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。</li>
<li>硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。</li>
<li>协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。</li>
<li>硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。</li>
<li>操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为 3）和RARP应答（值为4）。</li>
</ul>
<h2 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h2><p>ARP代理通俗地说，就是由中间设备代替其他主机响应arp请求。下图展现了ARP代理工作的主要过程：<br>Proxy ARP应该使用主机没有配置默认网关或没有任何路由策略的网络上</p>
<p><img src="http://www.vants.org/content/plugins/kl_album/upload/201209/98e326f50f0ae0ca8723ba653376c7c020120914093556873290427.png" alt=""></p>
<h3 id="ARP代理工作的过程说明"><a href="#ARP代理工作的过程说明" class="headerlink" title="ARP代理工作的过程说明"></a>ARP代理工作的过程说明</h3><ul>
<li>192.168.0.16/16主机向外发送目的主机为192.168.1.3/24的ARP请求报文；</li>
<li>网关收到0.16的ARP请求报文，由于网关开启了ARP代理的功能，因此网关代替1.3向0.16发送ARP响应数据报；</li>
<li>网关向1.0/24网段发送1.3的ARP请求报文；</li>
<li>1.3收到后，发送ARP响应报文。</li>
</ul>
<h3 id="ARP代理带来的问题"><a href="#ARP代理带来的问题" class="headerlink" title="ARP代理带来的问题"></a>ARP代理带来的问题</h3><p>在开启ARP代理功能之后，很可能会导致地址冲突等类似故障的产生，如在下图的网络环境下，将会产生一系列的不稳定的故障现象产生。 </p>
<p><img src="http://www.vants.org/content/plugins/kl_album/upload/201209/726cb8dcdc4764f2cc1559c89ffde637201209161035261080797373.png" alt=""></p>
<p>   正因为如此，我们在实际工作的环境中对于ARP代理功能的应用需要慎重一些，尽量避免针对整个网段使用ARP代理功能，最好只针对需要使用ARP代理功能来实现某些特殊功能需求的少数IP开启。</p>
<h3 id="ARP代理在实际工作中的应用"><a href="#ARP代理在实际工作中的应用" class="headerlink" title="ARP代理在实际工作中的应用"></a>ARP代理在实际工作中的应用</h3><h4 id="AnyIP"><a href="#AnyIP" class="headerlink" title="AnyIP"></a>AnyIP</h4><p>AnyIP是指机器随便使用什么IP地址或网关信息，只要接入网络中都可以实现访问的需求。这个技术被广泛的应用在soho级网关产品中，特别是在宾馆、会议室、广场等公共场所，为网络使用者提供了很大的便利。<br>其工作原理就是利用了ARP代理的功能，在收到非本地IP地址的ARP请求报文时，对其进行ARP响应。这样，那些收到ARP响应的主机就会将相关的数据包发送至网关设备接口处，再由网关设备转发出去，从而实现了上网的功能。   </p>
<h4 id="网关地址映射"><a href="#网关地址映射" class="headerlink" title="网关地址映射"></a>网关地址映射</h4><p>在很多网关设备上，都支持将内网的服务器映射为公网地址对外提供服务，以达到隐藏内部网络的目的，这种地址映射也是利用ARP代理技术来实现的，我们来简单看一下下图所示的地址映射的工作过程： </p>
<p><img src="http://www.vants.org/content/plugins/kl_album/upload/201209/d8007e7cdb19d6455234a654b47ab31b2012091409355588821205.png" alt=""></p>
<p>  在这个过程中，当来自互联网的数据访问产生了对映射外网地址202.102.X.2的ARP请求报文，正常情况下，因为这个地址的真实主机并不存在，发送端是不会收到来自202.102.X.2的ARP响应报文的。但是，由于网关上启用了针对202.102.X.2的ARP代理功能，网关会替代202.102.X.2发送ARP响应报文。从而实现了地址映射访问的需求。</p>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。免费ARP有两个作用：</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误信息“以太网：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。</li>
<li>如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。一个比较著名的ARP协议事实是，如果主机收到某个IP地址ARP请求，而且它已经在接收者的高速缓存中，那么就要用ARP请求中的发送端硬件地址（如以太网地址）对高速缓存中相应的内容进行更新。主机接收到任何ARP请求都要完成这个操作（ARP请求是在网上广播的，因此每次发送ARP请求时网络上的所有主机都要这样做）</li>
<li>通过发送含有备份硬件地址和故障服务器的IP地址的免费ARP请求，使得备份文件服务器可以顺利地接替故障服务器进行工作。这使得所有目的地为故障服务器的报文都被送到备份服务器那里，客户程序不用关心原来的服务器是否出了故障</li>
</ul>
<h1 id="RARP：逆地址解析协议"><a href="#RARP：逆地址解析协议" class="headerlink" title="RARP：逆地址解析协议"></a>RARP：逆地址解析协议</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。<br>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。</p>
<h2 id="RARP的分组格式"><a href="#RARP的分组格式" class="headerlink" title="RARP的分组格式"></a>RARP的分组格式</h2><p>RARP分组的格式与ARP分组基本一致。它们之间主要的差别是RARP请求或应答的帧类型代码为0x8035，且RARP请求的操作代码为3，应答操作代码为4。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/192207023854764.png" alt=""></p>
<p>注意：RARP请求以广播方式传送，应答一般是单播(unicast)传送的。</p>
<h2 id="RARP服务器的设计"><a href="#RARP服务器的设计" class="headerlink" title="RARP服务器的设计"></a>RARP服务器的设计</h2><p>RARP在概念上很简单，但是一个RARP服务器的设计与系统相关而且比较复杂。相反，提供一个ARP服务器很简单，通常是TCP/IP在内核中实现的一部分。由于内核知道IP地址和硬件地址，因此当它收到一个询问IP地址的ARP请求时，只需用相应的硬件地址来提供应答就可以了。</p>
<h3 id="作为用户进程的RARP服务器"><a href="#作为用户进程的RARP服务器" class="headerlink" title="作为用户进程的RARP服务器"></a>作为用户进程的RARP服务器</h3><p>RARP服务器的复杂性在于：</p>
<ul>
<li>服务器一般要为多个主机（网络上所有的无盘系统）提供硬件地址到IP地址的映射，该映射包含在一个磁盘文件中。由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供，而不是作为内核的TCP/IP实现的一部分。</li>
<li>RARP请求是作为一个特殊类型的以太网数据帧来传送的（帧类型字段值为0x8035），说明RARP服务器必须能够发送和接收这种类型的以太网数据帧。</li>
</ul>
<h3 id="每个网络有多个RARP服务器"><a href="#每个网络有多个RARP服务器" class="headerlink" title="每个网络有多个RARP服务器"></a>每个网络有多个RARP服务器</h3><p>RARP服务器实现的一个复杂因素是RARP请求是在硬件层上进行广播的，这意味着它们不经过路由器进行转发。为了让无盘系统在RARP服务器关机的状态下也能引导，通常在一个网络上（例如一根电缆）要提供多个RARP服务器。<br>当服务器的数目增加时（以提供冗余备份），网络流量也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答。（对于ARP，只有一台主机发送ARP应答）。每个RARP服务器同时应答，这样会增加以太网发生冲突的概率。</p>
<h1 id="ICMP：Internet控制报文协议"><a href="#ICMP：Internet控制报文协议" class="headerlink" title="ICMP：Internet控制报文协议"></a>ICMP：Internet控制报文协议</h1><h2 id="ICMP介绍"><a href="#ICMP介绍" class="headerlink" title="ICMP介绍"></a>ICMP介绍</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/201851308717804.png" alt=""><br><img src="http://images.cnitblog.com/blog2015/697266/201504/201854533243954.png" alt=""></p>
<ul>
<li>ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（TCO或UDP）使用。一些ICMP报文把差错报文返回给用户进程</li>
<li>ICMP报文是在IP数据内部被传输的</li>
<li>ICMP报文的格式如图6-2所示。所有报文的前4个字节都是一样的，但是剩下的其他字节则互不相同</li>
<li>类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件</li>
<li>检验和字段覆盖整个ICMP报文。使用的算法与IP首部检验和算法相同。ICMP的检验和是必须的</li>
</ul>
<h2 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/201900206052867.png" alt=""></p>
<ul>
<li>不同类型由报文中的类型字段和代码字段来共同决定。</li>
<li>ICMP是一份查询报文还是一份差错报文。</li>
<li>因为对ICMP差错报文有时需要作特殊处理，因此需要对它们进行区分。例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文（如果没有这个限制规则，可能会遇到一个差错产生另一个差错的情况，而差错再产生差错，这样会无休止地循环下去）。</li>
<li>当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来。</li>
</ul>
<h3 id="下面各种情况都不会导致产生ICMP差错报文"><a href="#下面各种情况都不会导致产生ICMP差错报文" class="headerlink" title="下面各种情况都不会导致产生ICMP差错报文"></a>下面各种情况都不会导致产生ICMP差错报文</h3><ul>
<li>ICMP差错报文（ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址或多播地址的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片。</li>
<li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ul>
<p>这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。</p>
<h2 id="ICMP地址掩码请求与应答"><a href="#ICMP地址掩码请求与应答" class="headerlink" title="ICMP地址掩码请求与应答"></a>ICMP地址掩码请求与应答</h2><p>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。系统广播它的ICMP请求报文，报文格式如图6-4所示：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/201922374028201.png" alt=""></p>
<p>说明：</p>
<ul>
<li>标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配。</li>
<li>广播的定义是指局域网上的所有主机，因此它必须包括发送主机在内。当以太网驱动程序识别出目的地址是广播地址后，它就把分组送到网络上，同时传一份拷贝到环回接口。</li>
<li>通常，应答地址必须是单播地址，除非请求端的源IP地址是0.0.0.0。</li>
</ul>
<h3 id="ICMP时间戳请求与应答"><a href="#ICMP时间戳请求与应答" class="headerlink" title="ICMP时间戳请求与应答"></a>ICMP时间戳请求与应答</h3><p>ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间(Coordinated Universal Time, UTC)。</p>
<p>说明：</p>
<ul>
<li>这种报文的好处是：提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些Unix系统提供的rdate命令）只能提供秒级的分辨率。</li>
<li>缺陷是：返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期。</li>
</ul>
<p>ICMP时间戳请求和应答报文格式如图6-6所示：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/201955518555818.png" alt=""></p>
<p>请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。</p>
<h2 id="ICMP端口不可达差错"><a href="#ICMP端口不可达差错" class="headerlink" title="ICMP端口不可达差错"></a>ICMP端口不可达差错</h2><p>端口不可达报文是一种ICMP差错报文，它是ICMP目的不可到达报文中的一种。ICMP不可达报文的一般格式如图6-10所示。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/202037158396912.png" alt=""></p>
<p>说明：</p>
<ul>
<li>ICMP的一个规则是：ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节。</li>
<li>导致差错的数据报中的IP首部要被送回的原因是因为IP首部中包含了协议字段，使得ICMP可以知道如何解释后面的8个字节。TCP和UDP首部的前8个字节包括源端口和目的端口。</li>
</ul>
<p>ICMP覆盖的范围很广，从致命差错到信息差错，即使在一个给定的系统实现中，对每个ICMP报文的处理都是不相同的。</p>
<h2 id="ICMP报文的4-4BSD处理"><a href="#ICMP报文的4-4BSD处理" class="headerlink" title="ICMP报文的4.4BSD处理"></a>ICMP报文的4.4BSD处理</h2><p>由于ICMP覆盖的范围很广，从致命差错到信息差错，因此即使在一个给定的系统实现中，对每个ICMP报文的处理都是不相同的。<br><img src="http://img.blog.csdn.net/20150414163431439" alt=""></p>
<ul>
<li>如果最后一列标明是“内核”，那么ICMP就由内核来处理</li>
<li>如果最后一列指明是“用户进程”，那么报文就被传送到所有在内核中登记用户进程，以读取收到的ICMP报文</li>
<li>如果不存在任何这样的用户进程，那么报文就悄悄地被丢弃（这些用户进程还会收到所有其它类型的ICMP报文的拷贝，虽然它们应该由内核来处理，当然用户进程只有在内核处理以后才能收到这些报文）。有一些报文完全被忽略</li>
<li>如果最后一列标明的是引号内的一串字符，那么它就是对应的Unix差错。</li>
</ul>
<h1 id="Ping程序"><a href="#Ping程序" class="headerlink" title="Ping程序"></a>Ping程序</h1><h2 id="Ping介绍"><a href="#Ping介绍" class="headerlink" title="Ping介绍"></a>Ping介绍</h2><ul>
<li>“ping”这个名字源于声纳定位操作。Ping程序由Mike Muuss编写，目的是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答</li>
<li>可以用Ping程序来确定问题出在哪里。Ping程序还能测出到这台主机的往返时间，以表明该主机离我们有多远</li>
<li>一台主机的可达性可能不只取决于IP层是否可达，还取决于使用何种协议以及端口号。Ping程序的运行结果可能显示某台主机不可达，但我们可以用Telnet远程登录到该台主机是25号端口</li>
</ul>
<h2 id="Ping程序-1"><a href="#Ping程序-1" class="headerlink" title="Ping程序"></a>Ping程序</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow4.jpg" alt=""></p>
<ul>
<li>称发送回显请求的ping程序为客户，而称被ping的主机为服务器。大多数的TCP|IP实现都在内核中直接支持Ping服务器–这种服务器不是一个用户进程</li>
<li>对于其他类型的ICMP查询报文，服务器应该响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣</li>
<li>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息</li>
<li>在windows下，不管开多个窗口ping的identifier都是相同的，而且每增加一个出去的ping包序列号增加256</li>
</ul>
<h2 id="IP记录路由选项"><a href="#IP记录路由选项" class="headerlink" title="IP记录路由选项"></a>IP记录路由选项</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow5.jpg" alt=""></p>
<ul>
<li>大多数不同版本的ping程序都提供-R选项，以提供记录路由的功能。它使得[ing程序在发送出来的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。当数据报到达目的端时，IP地址清单应该赋值到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当Ping程序收到回显应答时，它就打印出这份IP地址清单</li>
<li>源端主机生成RR选项，中间路由器对RR选项的处理，以及把ICMP回显请求中的RR清单复制到ICMP回显应答中，所有这些都是选项功能。幸运的是，现在的大多数系统都支持这些选项功能，只能有一些系统不把ICMP请求的IP清单赋值到ICMP应答中。</li>
<li>但是，最大的问题是IP首部中只有有限的空间来存放IP地址。IP首部中的首部长度字段只有4bit，因此整个IP首部最长只能包括15个32bit长的字（即60个字节）。由于IP首部固定长度为20字节，RRR选项用去3个字节，这样只剩下37个字节（60-20-3）来存放IP地址清单，也就是说只能存放9个IP地址</li>
</ul>
<h2 id="IP时间戳选项"><a href="#IP时间戳选项" class="headerlink" title="IP时间戳选项"></a>IP时间戳选项</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow3.jpg" alt=""></p>
<ul>
<li>时间戳选项的代码为0x44。其他两个字段len和ptr与记录路由选项相同：选项的总长度（一般为36或40）和指向下一个可用时间的指针（5，9，13等）</li>
<li>接下来的两个字段是4bit的值：OF表示溢出字段，FL表示标志字段。时间戳选项的操作</li>
<li>时间戳的取值一般为自UTC午夜开始计的毫秒数，与ICMP时间戳请求和应答相类似。如果路由器不使用这种格式，它就可以插入任何它使用的时间表示格式，但是必须打开时间戳中的高位以表明为非标准值</li>
<li>与我们遇到的记录路由选项所受到的限制相比，时间戳选项遇到情况要更坏一些。如果我们要同时记录IP地址和时间戳（标志位为1），那么就可以同时存入其中的四对值。只记录时间戳是没有用处的，因为没有标明时间戳与路由器之间的对应关系</li>
</ul>
<h1 id="Traceroute程序"><a href="#Traceroute程序" class="headerlink" title="Traceroute程序"></a>Traceroute程序</h1><ul>
<li>由Van Jacobson编写的Traceroute程序是一个能更深入探索TCP|IP协议的方便可用的工具</li>
<li>Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由</li>
<li>Traceroute程序还可以让我们使用IP源路由选项</li>
</ul>
<h2 id="Traceroute和IP路径记录选项的比较"><a href="#Traceroute和IP路径记录选项的比较" class="headerlink" title="Traceroute和IP路径记录选项的比较"></a>Traceroute和IP路径记录选项的比较</h2><p>我们描述了IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因。</p>
<ul>
<li>首先，原先并不是所有的路由器都支持记录路由选项，因此该选项在某些路径上不能使用（Traceroute程序不需要中间路由器具备任何特殊的或可选的功能）</li>
<li>其次，记录路由一般是单向的选项。发送端设置了该选项，那么接收端不得不从收到的IP首部中提取所有的信息，然后全部返回给发送端.大多数Ping服务器的实现（内核中的ICMP回显应答功能）把接收到的RR清单返回，但是这样使得记录下来的IP地址翻了一番（一来一回）。</li>
<li>最后一个原因也是最主要的原因是，IP首部中留给选项的空间有限，不能存放当前大多数的路径</li>
</ul>
<h2 id="Traceroute程序的操作"><a href="#Traceroute程序的操作" class="headerlink" title="Traceroute程序的操作"></a>Traceroute程序的操作</h2><ul>
<li>Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。TTL字段是由发送端初始设置一个8bit字段。推荐的初始值由分配数字RFC指定，当前值为64.较老版本的系统经常初始化为15或32.发送ICMP回显应答时经常把TTL设为最大值255</li>
<li>每个处理数据报的路由器都需要把TTL的值减1或减去数据报在路由器中停留的秒数。由于大多数的路由器转发数据报的时延都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1</li>
<li>当路由器收到一份IP数据报，如果其TTL字段是0或1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是在通常情况下，系统不应该接收TTL字段为0的数据报）。相反，路由器将该数据报丢弃，并给信源机发一份ICMP“超时”信息。Traceroute程序的关键在于包含这份ICMP信息的IP报文的信源地址是该路由器的IP地址</li>
<li>Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于3000），使目的主机的UDP模块产生一份“端口不可达”错误的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。</li>
</ul>
<h2 id="IP源选路选项"><a href="#IP源选路选项" class="headerlink" title="IP源选路选项"></a>IP源选路选项</h2><p>源站选项（source routing）的思想是由发送者指定路由，它可以采用以下两种形式：</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow.jpg" alt=""></p>
<ul>
<li>严格的源路由选择。发送端指明IP数据报所必须采用的确切路由。如果一个路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源路路由失败”的ICMP差错报文</li>
<li>宽松的源站选路，发送端指明了一个数据报经过的IP地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器</li>
<li>这个格式与记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送IP数据报前填充IP地址清单；而对于记录路由选项，我们需要为IP地址清单分配并清空一些空间，并让路由器填充该清单中各项。同时，对于源站选路，只要为所需要的IP地址数分配空间并进行初始化，通常其数量小于9.而对于记录路由选项来说，必须尽可能地分配空间，以达到9个地址</li>
<li>对于宽松的源站来说，code字段的值是0x83；而对于严格的源站选路，其值为0x89.len和ptr字段与IP首部中的记录路由选项的一般格式是一样的</li>
</ul>
<h2 id="IP源站选路的操作机制"><a href="#IP源站选路的操作机制" class="headerlink" title="IP源站选路的操作机制"></a>IP源站选路的操作机制</h2><p>源站路由选项的实际称呼为“源站及记录路由”（对于宽松的源站选路和严格的源路选路，分别用LSRR和SSRR表示），这是因为在数据报沿路由发送过程中，对IP地址清单进行了更新。下面是其运行过程：</p>
<ul>
<li>发送主机从应用程序接收源站路由清单，将第1个表项去掉（它是数据报的最终目的地址），将剩余的项移到1个项中，并将原来的目的地址作为清单的最后一项。指针仍然指向清单的第1项（即，指针的值为4）</li>
<li>每个处理数据报的路由器检查其是否为数据报的最终地址。如果不是，则正常转发数据报（在这种情况下，必须指明宽松源站选路，否则就不能接收到该数据报）</li>
<li>如果该路由器是最终目的，且指针不大于路径的长度，那么（1）由ptr所指定的清单中的下一个地址就是数据报的最终目的地址；（2）由外接口响应的IP地址取代刚才使用的源地址；（4）指针加4</li>
<li>Host Requirements RFC指明，TCP客户必须能指明源站选路，同时，TCP服务器必须能够接收源站选路，并且对于该TCP连接的所有报文段都能采用反向路由。如果TCP服务器下面接收到一个不同的源站选路，那么新的源路路由将取代旧的源路路由</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow1.jpg" alt=""></p>
<h1 id="IP选路"><a href="#IP选路" class="headerlink" title="IP选路"></a>IP选路</h1><ul>
<li>选路是IP最重要的功能之一</li>
<li>路由守护程序（daemon），通常这是一个用户进程</li>
<li>在Unix系统中，大多数普通的守护程序都是路由程序和网关程序</li>
<li>路由表经常被IP访问，但是它被路由守护程序更新的频度却要低得多</li>
<li>当接收到ICMP重定向报文时，路由表也要被更新</li>
<li><p>用netstat命令来显示路由表</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170421202212.jpg" alt=""></p>
</li>
</ul>
<h2 id="选路的原理"><a href="#选路的原理" class="headerlink" title="选路的原理"></a>选路的原理</h2><p>IP搜索路由表的几个步骤：</p>
<ul>
<li>搜索匹配的主机地址</li>
<li>搜索匹配的网络地址</li>
<li>搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）</li>
<li>CISCO的选路策略（1.明细策略路由 2.明细路由 3.策略默认路由 4.默认路由）</li>
<li>IP执行选路机制，而路由守护程序则一般提供选路策略</li>
</ul>
<h2 id="初始化路由表"><a href="#初始化路由表" class="headerlink" title="初始化路由表"></a>初始化路由表</h2><ul>
<li>每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。对于点对点链路和环回接口来说，路由是到达主机（例如，设置H标志）。对于广播接口来说，如以太网，路由是到达网络</li>
<li>到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">route add default sun 1</div><div class="line">route add slip bsdi 1</div><div class="line">route add 1.1.1.0 mask 255.255.255.0 1.1.1.1</div></pre></td></tr></table></figure>
<ul>
<li>第三个参数（defalut和slip）代表目的端，第四个参数代表网关（路由器），最后一个参数代表路由的度量（metric）.route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志</li>
</ul>
<h2 id="转发或不转发"><a href="#转发或不转发" class="headerlink" title="转发或不转发"></a>转发或不转发</h2><ul>
<li>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用</li>
<li>大多数伯克利派出来的系统都有一个内核变量ipforwarding</li>
<li>SumOS 4.1.x允许该变量可以有三个不同的值：-1表示始终不转发并且始终不改变它的值；0表示默认条件下不转发，但是当打开两个或更多个接口时就把值设为1；1表示始终转发。Solaris 2.x把这个值改为0（始终不转发）’1（始终转发）和2（在打开两个或更多个接口是才转发）</li>
<li>较早版本的4.2BSD主机在默认条件下可以转发数据报，这给没有进行正确配置的系统带来了许多问题。这就是内核选项为什么要设成默认的“始终不转发”的原因，除非系统管理员进行特殊设置</li>
</ul>
<h2 id="ICMP重定向差错"><a href="#ICMP重定向差错" class="headerlink" title="ICMP重定向差错"></a>ICMP重定向差错</h2><ul>
<li>我们假定主机发送一份IP数据报给R1.这种选路决策经常发生，因为R1是该主机的默认路由</li>
<li>R1收到数据报并检查它的路由表，发现R2是发送数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报达到接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索</li>
<li>R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170422232852.jpg" alt=""></p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><ul>
<li>UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据包</li>
<li>这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没什么联系</li>
<li>UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地</li>
<li>应用程序必须关心IP数据报的长度。如果它超过网络的MTU，那么就要对IP数据报进行分片</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/211857142503378.png" alt=""></p>
<h2 id="UDP三大典型运用"><a href="#UDP三大典型运用" class="headerlink" title="UDP三大典型运用"></a>UDP三大典型运用</h2><h3 id="查询类：DNS"><a href="#查询类：DNS" class="headerlink" title="查询类：DNS"></a>查询类：DNS</h3><ul>
<li>没有TCP三次握手包过程，快</li>
<li>多个DNS同时查询</li>
</ul>
<h3 id="数据传输：TFTP"><a href="#数据传输：TFTP" class="headerlink" title="数据传输：TFTP"></a>数据传输：TFTP</h3><ul>
<li>停止等待协议，慢（需运用层确定数据）</li>
<li>适合无盘工作站</li>
</ul>
<h3 id="语言视频流"><a href="#语言视频流" class="headerlink" title="语言视频流"></a>语言视频流</h3><ul>
<li>支持广播和组播</li>
<li>支持丢包，保障效率</li>
</ul>
<h2 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/211907360933802.png" alt=""></p>
<ul>
<li>端口号表示发送进程和接收进程</li>
<li>TCP端口号与UDP端口号是相互独立的。（rsh和syslog=514）</li>
<li>尽管相互独立，如果TCP和UDP同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本事的要求（dns）</li>
<li>UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节</li>
</ul>
<h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h2><ul>
<li>UDP检验和覆盖UDP首部和UDP数据</li>
<li>IP首部的检验和，它只覆盖IP的首部</li>
<li>UDP的检验和是可选的，而TCP的检验和是必需的</li>
<li>IP计算检验和和UDP计算检验和之间存在不同的地方。首先，UDP数据报的长度可以为奇数字节，但检验和算法是把若干个16bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）</li>
<li>UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/211955147184376.png" alt=""></p>
<h2 id="tcpdump输出"><a href="#tcpdump输出" class="headerlink" title="tcpdump输出"></a>tcpdump输出</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE2017042317114.jpg" alt=""></p>
<ul>
<li>三个系统有两个打开了UDP检验和选项</li>
<li>送出的数据报与收到的数据报具有相同的检验和值（第3和第4行，第5和第6行）。从图11-3可以看出，两个IP地址进行了交换，正如两个端口号一样。伪首部和UDP首部中的其他字段都是相同的，就想数据回显一样。这再次表明UDP检验和（事实上，TCP|IP协议簇中所有的检验和）是简单的16bit和。它们检测不出交换两个16bit的差错</li>
</ul>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170423172522.jpg" alt=""></p>
<ul>
<li>在发送第一份数据报之前，发送端和接收端之间没有任何通信</li>
<li>当收到数据时，接收端没有任何确认。在这个例子中，发送端并不知道零一端是否已经收到这些数据报</li>
<li>每次运行程序时，源端的UDP端口号都发生变化。第一次是1108，然后是1110.客户程序使用ephemeral端口号一般在1024~5000之间</li>
</ul>
<h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><ul>
<li>IP把MTU与数据报长度进行比较</li>
<li>如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发送在中间路由器上。</li>
<li>把一份IP数据报分片以后，只有到达目的地才进行重新组装（FR fragment）</li>
<li>重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的</li>
<li>已经分片过的数据报有可能会再次进行分片（可能不止一次）</li>
<li>当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部中有足够的信息让接收端能正确组装这些数据报片</li>
<li>尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报</li>
<li>IP层本身没有超时重传的机制–由更高层来负责超时和重传（TCP有超市和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报。没有办法只能重传数据报中的一个数据报片</li>
<li>如果对数据报分片的是中间路由器，而不是启事端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，要经常避免分片</li>
</ul>
<h3 id="IP分片：注意事项"><a href="#IP分片：注意事项" class="headerlink" title="IP分片：注意事项"></a>IP分片：注意事项</h3><ul>
<li>在分片时，除最后一片外，其他每一片中的数据部分（除IP首部外的其余部分）必须是8字节的整数倍</li>
<li>IP首部被复制到各个片中。但是，端口号在UDP首部，只能在第一片中被发现</li>
<li>需要解释几个术语：IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间的数据单元，一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片</li>
</ul>
<h2 id="ICMP不可达差错（需要分片）"><a href="#ICMP不可达差错（需要分片）" class="headerlink" title="ICMP不可达差错（需要分片）"></a>ICMP不可达差错（需要分片）</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/212127065468647.png" alt=""></p>
<ul>
<li>发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片(DF的标志比特。如果某个程序需要判断到目的端的路途中最小MTU是多少–称作路径MTU发现机制，那么这个差错就可以被该程序使用</li>
<li>如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424210136.jpg" alt=""></p>
<ul>
<li>在点到点的链路中，不要求两个方向的MTU为相同值</li>
<li>在主机sun上运行tcpdump，观察SLIP链路，看什么时候发生分片。开始没有观察到分片，一切都很正常知道ping分组的数据长度从500增加到600字节。可以看到接收到的回显请求（仍然没有分片），但不见回显应答</li>
<li>Ping的时候DF置位（echo设置DF位，echo-reply也会设置DF位）</li>
</ul>
<h2 id="用Traceroute确定路径MTU"><a href="#用Traceroute确定路径MTU" class="headerlink" title="用Traceroute确定路径MTU"></a>用Traceroute确定路径MTU</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205607.jpg" alt=""></p>
<ul>
<li>MTU值的个数是有限的，因此在我们的程序中有些由近似值构成的表，取下一个最小的MTU值来发送</li>
<li>上面的测试中间设备不回送吓一跳的MTU，下面的测试回送了下一跳的MTU</li>
</ul>
<h2 id="采用UDP的路径MTU发现"><a href="#采用UDP的路径MTU发现" class="headerlink" title="采用UDP的路径MTU发现"></a>采用UDP的路径MTU发现</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205406.jpg" alt=""></p>
<ul>
<li>Solaris发送650字节的udp包，并且DF被置位</li>
<li>被bsdi丢弃，但是不回送MTU值</li>
<li>Solaris自以为是的对数据包进行分片（552 106两个片）</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205651.jpg" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205746.jpg" alt=""></p>
<ul>
<li>Solaris自以为是的对数据报进行分片（552 106两个片）造成不优化的再次分片</li>
<li>最好的解决方式是让bsdi回送MTU，Solaris根据这个MTU采取最优化的分片</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205832.jpg" alt=""></p>
<h2 id="UDP和ARP之间的交互作用"><a href="#UDP和ARP之间的交互作用" class="headerlink" title="UDP和ARP之间的交互作用"></a>UDP和ARP之间的交互作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bsdi % arp -a验证ARP高速缓存是空的</div><div class="line">bsdi % sock -u -i -l -w8192 svr4 discard</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205918.jpg" alt=""></p>
<ul>
<li>1.在第一个ARP应答返回以前，总共产生了6个ARP请求</li>
<li>2.在接收第一个ARP应答时（第7行），只发送最后一个数据报片（第9行）</li>
<li>3.在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机</li>
<li>4.另一个无法解释的不正常的现象是，svr4发回7个，而不是6个ARP应答</li>
<li>5.这里我们没有看到ICMP消息的原因有两个。首先，大多数从Berkeley派生的实现从不产生该差错！这些实现会设置定时器，也会在定时器溢出时将数据报片丢弃，但是不生成ICMP差错</li>
<li>6.第二，并未接收到包含UDP首部的偏移量为0的第一个数据报片（这是被ARP所丢弃的5个报文的第一个）除非接收到第一个数据报片，否则并不要求任何实现产生ICMP差错</li>
</ul>
<h2 id="最大UDP数据报长度"><a href="#最大UDP数据报长度" class="headerlink" title="最大UDP数据报长度"></a>最大UDP数据报长度</h2><ul>
<li>IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的</li>
<li>我们将遇到两个限制因素，第一，应用程序可能会收到其程序接口的限制。Socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）</li>
<li>第二个限制来自于TCP|IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节</li>
<li>在SunOS4.1.3下使用环回接口的最大IP数据报长度是32767字节。比它大的值都会发生差错。但是从BSD/386到SunOS4.1.3的情况下，Sun所能接收到最大IP数据报长度为32786字节（即32758字节用户数据）。在Solaris2.2下使用环回接口，最大可收发IP数据报长度为65535字节。从Solaris2.2到AIX3.2.2,发送的最大IP数据报长度可以是65535字节。很显然，这个限制和源端和目的端的实现有关</li>
<li>要求主机必须能够接收最短为576字节的IP数据报，在许多的UDP应用程序的设计中，其应用数据被限制成512字节或更小，因此比这个限制值小</li>
</ul>
<h2 id="ICMP源站抑制差错"><a href="#ICMP源站抑制差错" class="headerlink" title="ICMP源站抑制差错"></a>ICMP源站抑制差错</h2><p>当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，可能产生这个差错。</p>
<p>注意：“可能”产生这个差错。即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/212155080782897.png" alt=""></p>
<h2 id="UDP服务器的设计"><a href="#UDP服务器的设计" class="headerlink" title="UDP服务器的设计"></a>UDP服务器的设计</h2><p>对于服务器来说，它启动后处于休眠状态，等待客户请求的到来。对于UDP来说，当客户数据报到达时，服务器苏醒过来，数据报中可能包含来自客户的某种形式的请求消息。</p>
<ul>
<li><p>（1）客户IP地址及端口号<br>IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端的UDP端口号。当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号。这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。</p>
</li>
<li><p>（2）目的IP地址<br>一些应用程序需要知道数据报是发送给谁的，即目的IP地址。这要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。</p>
</li>
<li><p>（3）UDP输入队列<br>大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。</p>
</li>
</ul>
<p>通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序</p>
<p>排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的。</p>
<p>1）应用程序并不知道其输入队列何时溢出。只是由UDP对超出数据报进行丢弃处理。</p>
<p>2）没有发回任何信息告诉客户其数据报被丢弃。</p>
<ul>
<li>（4）限制本地IP地址<br>大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符(wildcard)的特点。表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它。</li>
</ul>
<p>另一方面，当服务器创建端点时，它可以把其中一个主机本地IP地址包括广播地址指定为端点的本地IP地址。只有当目的IP地址与指定的地址相匹配时，进入的UDP数据报才能被送到这个端点。</p>
<ul>
<li>（5）限制远端IP地址</li>
</ul>
<p>大多数系统都允许UDP端点对远端地址进行限制，即端点将只能接收特定IP地址和端口号的UDP数据报。</p>
<ul>
<li>（6）每个端口有多个接收者</li>
</ul>
<p>大多数系统在某一时刻只允许一个程序端点与某个本地IP地址及UDP端口号相关联。当目的地为该IP地址及端口号的UDP数据报到达主机时，就复制一份传给该端点。</p>
<p>然而，在一个支持多播的系统上，多个端点可以使用同一个IP地址和UDP端口号。</p>
<p>当UDP数据报到达的目的IP地址为广播地址或多播地址，而且在目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制。如果UDP数据报到达的是一个单播地址，那么只向其中一个端点传送一份数据报的复制。选择哪个端点传送数据取决于各个不同的系统实现。</p>
<h1 id="广播与多播"><a href="#广播与多播" class="headerlink" title="广播与多播"></a>广播与多播</h1><ul>
<li>三种IP地址：单播地址、广播地址和多播地址。</li>
<li>广播和多播仅应用于UDP，它们对需要将报文同时传往多个接收者的应用来说十分重要</li>
<li>TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接</li>
<li>有时一个主机要向网上的所有其他主机发送帧，这就是广播。通过ARP和RARP可以看到这一过程</li>
<li>多播处于单播和广播之间：帧仅传送给属于多播组的多个主机</li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/linux/第四周-LinuxLinux各个目录的作用及内容.html" rel="next" title="[第四周]LinuxLinux各个目录的作用及内容">
                <i class="fa fa-chevron-left"></i> [第四周]LinuxLinux各个目录的作用及内容
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/notes/Ubuntu-Server下安装配置Metasploit.html" rel="prev" title="Ubuntu Server下安装配置Metasploit">
                Ubuntu Server下安装配置Metasploit <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html"
           data-title="《TCP/IP详解 卷1：协议》学习笔记" data-url="http://uknowsec.cn/posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161122223514.jpg"
               alt="uknow" />
          <p class="site-author-name" itemprop="name">uknow</p>
          <p class="site-description motion-element" itemprop="description">不忘初心，方得始终</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/uknowsec" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3477219002" target="_blank">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  Others
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分层"><span class="nav-number">1.1.</span> <span class="nav-text">分层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例：运行FTP的两台主机"><span class="nav-number">1.2.</span> <span class="nav-text">实例：运行FTP的两台主机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过路由器连接的两个网络"><span class="nav-number">1.3.</span> <span class="nav-text">通过路由器连接的两个网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP协议族中不同层次的协议"><span class="nav-number">1.4.</span> <span class="nav-text">TCP/IP协议族中不同层次的协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互联网的地址"><span class="nav-number">1.5.</span> <span class="nav-text">互联网的地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#域名系统"><span class="nav-number">1.6.</span> <span class="nav-text">域名系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">1.7.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分用"><span class="nav-number">1.8.</span> <span class="nav-text">分用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户-服务器模型"><span class="nav-number">1.9.</span> <span class="nav-text">客户-服务器模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重复型服务器"><span class="nav-number">1.9.1.</span> <span class="nav-text">重复型服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发型服务器"><span class="nav-number">1.9.2.</span> <span class="nav-text">并发型服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#端口号"><span class="nav-number">1.10.</span> <span class="nav-text">端口号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链路层"><span class="nav-number">2.</span> <span class="nav-text">链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以太网和IEEE-802封装"><span class="nav-number">2.2.</span> <span class="nav-text">以太网和IEEE 802封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以太网"><span class="nav-number">2.2.1.</span> <span class="nav-text">以太网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IEEE-802封装"><span class="nav-number">2.2.2.</span> <span class="nav-text">IEEE 802封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装格式"><span class="nav-number">2.3.</span> <span class="nav-text">封装格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SLIP：串行线路IP"><span class="nav-number">2.4.</span> <span class="nav-text">SLIP：串行线路IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PPP：点对点协议"><span class="nav-number">2.5.</span> <span class="nav-text">PPP：点对点协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环回接口"><span class="nav-number">2.6.</span> <span class="nav-text">环回接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MTU和路径MTU"><span class="nav-number">2.7.</span> <span class="nav-text">MTU和路径MTU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串行线路吞吐量计算"><span class="nav-number">2.8.</span> <span class="nav-text">串行线路吞吐量计算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IP：网际协议"><span class="nav-number">3.</span> <span class="nav-text">IP：网际协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IP介绍"><span class="nav-number">3.1.</span> <span class="nav-text">IP介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP首部"><span class="nav-number">3.2.</span> <span class="nav-text">IP首部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP路由选择"><span class="nav-number">3.3.</span> <span class="nav-text">IP路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路由表中的包含信息"><span class="nav-number">3.3.1.</span> <span class="nav-text">路由表中的包含信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由选择完成的功能"><span class="nav-number">3.3.2.</span> <span class="nav-text">路由选择完成的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">3.3.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子网掩码"><span class="nav-number">3.4.</span> <span class="nav-text">子网掩码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊情况的IP地址"><span class="nav-number">3.5.</span> <span class="nav-text">特殊情况的IP地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARP：地址解析协议"><span class="nav-number">4.</span> <span class="nav-text">ARP：地址解析协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP介绍"><span class="nav-number">4.1.</span> <span class="nav-text">ARP介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个例子"><span class="nav-number">4.2.</span> <span class="nav-text">一个例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP背后的一个基本概念"><span class="nav-number">4.3.</span> <span class="nav-text">ARP背后的一个基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP高速缓存"><span class="nav-number">4.4.</span> <span class="nav-text">ARP高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PC"><span class="nav-number">4.4.1.</span> <span class="nav-text">PC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由器"><span class="nav-number">4.4.2.</span> <span class="nav-text">路由器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP的分组格式"><span class="nav-number">4.5.</span> <span class="nav-text">ARP的分组格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP包字段分析"><span class="nav-number">4.5.1.</span> <span class="nav-text">ARP包字段分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP代理"><span class="nav-number">4.6.</span> <span class="nav-text">ARP代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP代理工作的过程说明"><span class="nav-number">4.6.1.</span> <span class="nav-text">ARP代理工作的过程说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP代理带来的问题"><span class="nav-number">4.6.2.</span> <span class="nav-text">ARP代理带来的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP代理在实际工作中的应用"><span class="nav-number">4.6.3.</span> <span class="nav-text">ARP代理在实际工作中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AnyIP"><span class="nav-number">4.6.3.1.</span> <span class="nav-text">AnyIP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网关地址映射"><span class="nav-number">4.6.3.2.</span> <span class="nav-text">网关地址映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#免费ARP"><span class="nav-number">4.7.</span> <span class="nav-text">免费ARP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RARP：逆地址解析协议"><span class="nav-number">5.</span> <span class="nav-text">RARP：逆地址解析协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-1"><span class="nav-number">5.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RARP的分组格式"><span class="nav-number">5.2.</span> <span class="nav-text">RARP的分组格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RARP服务器的设计"><span class="nav-number">5.3.</span> <span class="nav-text">RARP服务器的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作为用户进程的RARP服务器"><span class="nav-number">5.3.1.</span> <span class="nav-text">作为用户进程的RARP服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#每个网络有多个RARP服务器"><span class="nav-number">5.3.2.</span> <span class="nav-text">每个网络有多个RARP服务器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ICMP：Internet控制报文协议"><span class="nav-number">6.</span> <span class="nav-text">ICMP：Internet控制报文协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP介绍"><span class="nav-number">6.1.</span> <span class="nav-text">ICMP介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP报文的类型"><span class="nav-number">6.2.</span> <span class="nav-text">ICMP报文的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下面各种情况都不会导致产生ICMP差错报文"><span class="nav-number">6.2.1.</span> <span class="nav-text">下面各种情况都不会导致产生ICMP差错报文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP地址掩码请求与应答"><span class="nav-number">6.3.</span> <span class="nav-text">ICMP地址掩码请求与应答</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ICMP时间戳请求与应答"><span class="nav-number">6.3.1.</span> <span class="nav-text">ICMP时间戳请求与应答</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP端口不可达差错"><span class="nav-number">6.4.</span> <span class="nav-text">ICMP端口不可达差错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP报文的4-4BSD处理"><span class="nav-number">6.5.</span> <span class="nav-text">ICMP报文的4.4BSD处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ping程序"><span class="nav-number">7.</span> <span class="nav-text">Ping程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ping介绍"><span class="nav-number">7.1.</span> <span class="nav-text">Ping介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ping程序-1"><span class="nav-number">7.2.</span> <span class="nav-text">Ping程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP记录路由选项"><span class="nav-number">7.3.</span> <span class="nav-text">IP记录路由选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP时间戳选项"><span class="nav-number">7.4.</span> <span class="nav-text">IP时间戳选项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Traceroute程序"><span class="nav-number">8.</span> <span class="nav-text">Traceroute程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Traceroute和IP路径记录选项的比较"><span class="nav-number">8.1.</span> <span class="nav-text">Traceroute和IP路径记录选项的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traceroute程序的操作"><span class="nav-number">8.2.</span> <span class="nav-text">Traceroute程序的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP源选路选项"><span class="nav-number">8.3.</span> <span class="nav-text">IP源选路选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP源站选路的操作机制"><span class="nav-number">8.4.</span> <span class="nav-text">IP源站选路的操作机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IP选路"><span class="nav-number">9.</span> <span class="nav-text">IP选路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选路的原理"><span class="nav-number">9.1.</span> <span class="nav-text">选路的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化路由表"><span class="nav-number">9.2.</span> <span class="nav-text">初始化路由表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转发或不转发"><span class="nav-number">9.3.</span> <span class="nav-text">转发或不转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP重定向差错"><span class="nav-number">9.4.</span> <span class="nav-text">ICMP重定向差错</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDP"><span class="nav-number">10.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP介绍"><span class="nav-number">10.1.</span> <span class="nav-text">UDP介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP三大典型运用"><span class="nav-number">10.2.</span> <span class="nav-text">UDP三大典型运用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询类：DNS"><span class="nav-number">10.2.1.</span> <span class="nav-text">查询类：DNS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据传输：TFTP"><span class="nav-number">10.2.2.</span> <span class="nav-text">数据传输：TFTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语言视频流"><span class="nav-number">10.2.3.</span> <span class="nav-text">语言视频流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP首部"><span class="nav-number">10.3.</span> <span class="nav-text">UDP首部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP检验和"><span class="nav-number">10.4.</span> <span class="nav-text">UDP检验和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcpdump输出"><span class="nav-number">10.5.</span> <span class="nav-text">tcpdump输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的例子"><span class="nav-number">10.6.</span> <span class="nav-text">一个简单的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP分片"><span class="nav-number">10.7.</span> <span class="nav-text">IP分片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP分片：注意事项"><span class="nav-number">10.7.1.</span> <span class="nav-text">IP分片：注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP不可达差错（需要分片）"><span class="nav-number">10.8.</span> <span class="nav-text">ICMP不可达差错（需要分片）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用Traceroute确定路径MTU"><span class="nav-number">10.9.</span> <span class="nav-text">用Traceroute确定路径MTU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#采用UDP的路径MTU发现"><span class="nav-number">10.10.</span> <span class="nav-text">采用UDP的路径MTU发现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP和ARP之间的交互作用"><span class="nav-number">10.11.</span> <span class="nav-text">UDP和ARP之间的交互作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大UDP数据报长度"><span class="nav-number">10.12.</span> <span class="nav-text">最大UDP数据报长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP源站抑制差错"><span class="nav-number">10.13.</span> <span class="nav-text">ICMP源站抑制差错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP服务器的设计"><span class="nav-number">10.14.</span> <span class="nav-text">UDP服务器的设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#广播与多播"><span class="nav-number">11.</span> <span class="nav-text">广播与多播</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">uknow</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3d5fd0365a60ecafb093d2d0df7aaf4c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"uknow"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("AxgSweQqwlurwh9jQb8ilgOQ-gzGzoHsz", "ex42kl7W8LVpx0umFqv5YSIa");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
