<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> frida-hook工具篇 · Uknow - Stay hungry Stay foolish</title><meta name="description" content="frida-hook工具篇 - uknow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/2.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/2.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/uknowsec" target="_blank" class="nav-list-link">GitHub</a></li><li class="nav-list-item"><a href="http://weibo.com/uknowsec" target="_blank" class="nav-list-link">Weibo</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">frida-hook工具篇</h1><div class="post-time">Feb 6, 2020</div><div class="post-content"><h2><span id="brida">Brida</span></h2><h3><span id="brida简介">Brida简介</span></h3><p>Brida是BurpSuite的一个插件，它可以将Burp和Frida结合起来使用，可以在 BurpSuite中直接调用目标应用程序中的加/解密函数，这样就可以根据你的需求修改移动端APP与服务器的通信流量。而不用去逆向它，从而节省测试人员的精力。</p>
<p><a href="https://github.com/federicodotta/Brida" target="_blank" rel="noopener">https://github.com/federicodotta/Brida</a></p>
<h3><span id="brida安装">Brida安装</span></h3><p>Brida目前只支持python 2.7。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br><span class="line">pip install frida-tools</span><br><span class="line">pip install pyro4</span><br></pre></td></tr></table></figure>
<p>Brida可以直接从BurpSuite中安装</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580895376662.png" alt="1580895376662"></p>
<h3><span id="brida功能模块">Brida功能模块</span></h3><h4><span id="brida控制台">Brida控制台</span></h4><p>填好配置项后先点击<code>Start Server</code>然后在点击<code>Spawn application</code>。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580895596968.png" alt="1580895596968"><br>Brida由以下三部分组成：</p>
<ul>
<li><p>Brida.jar为Burpsuite插件；</p>
</li>
<li><p>bridaServicePyro是用于Frida适配到burpsuite上的python脚本，这一部分存储在插件中，在执行brida过程中复制到缓存文件夹中；</p>
</li>
<li><p>script.js是要注入到目标应用程序的javascript脚本，它会通过Frida带有的rpc.exports功能将信息返回到拓展程序中，同时该script.js脚本会被Frida注入到我们在 Brida中指定的进程中所以我们可以直接使用 Frida的API。</p>
</li>
</ul>
<p>  Brida的几个配置参数：</p>
<table>
<thead>
<tr>
<th>配置参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python binary path</td>
<td style="text-align:left">即Python可执行程序路径，用于启动Pyro服务</td>
</tr>
<tr>
<td>Pyro host, Pyro port</td>
<td style="text-align:left">即Pyro 服务的主机以及端口，可以保持默认</td>
</tr>
<tr>
<td>Frida JS file path</td>
<td style="text-align:left">需要注入的Frida脚本存放的位置</td>
</tr>
<tr>
<td>Application ID</td>
<td style="text-align:left">目标进程名(APP的包名)</td>
</tr>
<tr>
<td>Frida Remote”/“Frida Loca</td>
<td style="text-align:left">如果您使用的是Frida USB操作模式，则必须选择“ Frida Local”。如果使用端口转发模式，则必须选择“ Frida Remote”。</td>
</tr>
</tbody>
</table>
<h4><span id="js编辑器">JS编辑器</span></h4><p>  可以实时对hook脚本进行编辑。</p>
<p>  <img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580897477541.png" alt="1580897477541"></p>
<h4><span id="analyze-binary">Analyze Binary</span></h4><p>切换到Analyze Binary，点击Load tree，然后可能会卡一会，因为在加载类列表，加载完点开Java，可以看到这个进程里的所有类，可在下面的搜索框直接搜crypt来找加解密类。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580899345827.png" alt="1580899345827"></p>
<p>其功能和TraceView 相似，我们在操作APP的时候，他会打印出所有加载的类和方法。</p>
<p>点开java下拉找到app包名通过一个一个插桩 然后进行提交测试 看响应框是否会有信息。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580901009778.png" alt="1580901009778"></p>
<p>通过插桩可以看到此方法前后的输入值与返回值，同时可以通过<code>change return value</code>修改方法返回值。</p>
<h4><span id="execute-method">Execute method</span></h4><p>在通用js脚本中的<code>rpc.exports</code>里帮写了四个<code>contextcustom</code>，这四个是给右键菜单预留的，<code>contextcustom1、contextcustom2</code>会出现在<code>repeater</code>等模块中<code>request</code>的右键菜单，<code>contextcustom2、contextcustom3</code>则会出现在<code>response</code>的右键菜单。主要就是为了实现手动加解密的功能。这四个函数接收的参数都是hex形式的，所以返回的时候也要转成hex再传出去。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580901402956.png" alt="1580901402956"></p>
<p>例如：我们掉模块中调用函数contextcustom1返回值为上面代码中的6566。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580901465948.png" alt="1580901465948"></p>
<h4><span id="generate-stubs">Generate stubs</span></h4><p>这里可以生成java/python代码，<code>METHOD_NAME</code>你要调用hook脚本的函数，即如上的contextcustom1，另外一处标红为参数列表。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580902444668.png" alt="1580902444668"></p>
<p>我们要实现的功能只是要让Repeater, Intruder and Scanner模块能对数据进行自动加/解密。</p>
<p>如下代码是brida官方文档给出的通用代码，我们只需修改调用的函数名和参数并对相关的加密解密数据进行处理即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">package burp;</span><br><span class="line"></span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import org.apache.commons.lang3.ArrayUtils;</span><br><span class="line">import net.razorvine.pyro.PyroProxy;</span><br><span class="line">import net.razorvine.pyro.PyroURI;</span><br><span class="line"></span><br><span class="line">public class BurpExtender implements IBurpExtender, IHttpListener &#123;</span><br><span class="line">  private PrintWriter stdout;</span><br><span class="line">  private PrintWriter stderr;	    </span><br><span class="line">  private IBurpExtenderCallbacks callbacks;</span><br><span class="line">  private IExtensionHelpers helpers;</span><br><span class="line">    </span><br><span class="line">  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) &#123;</span><br><span class="line">    // Set the name of the extension</span><br><span class="line">    callbacks.setExtensionName(&quot;Brida Demo Search Plugin&quot;);		</span><br><span class="line">    // Initialize stdout and stderr (configurable from the Extension pane)</span><br><span class="line">    stdout = new PrintWriter(callbacks.getStdout(), true);</span><br><span class="line">    stderr = new PrintWriter(callbacks.getStderr(), true);  </span><br><span class="line">    // Save references to useful objects</span><br><span class="line">    this.callbacks = callbacks;</span><br><span class="line">    this.helpers = callbacks.getHelpers();</span><br><span class="line">    // Register ourselves as an HttpListener, in this way all requests and responses will be forwarded to us</span><br><span class="line">    callbacks.registerHttpListener(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123;</span><br><span class="line">    </span><br><span class="line">    // Process only Repeater, Scanner and Intruder requests</span><br><span class="line">    if(toolFlag == IBurpExtenderCallbacks.TOOL_SCANNER || </span><br><span class="line">       toolFlag == IBurpExtenderCallbacks.TOOL_REPEATER ||		</span><br><span class="line">       toolFlag == IBurpExtenderCallbacks.TOOL_INTRUDER) &#123;</span><br><span class="line">      </span><br><span class="line">      // Modify &quot;test&quot; parameter of Repeater requests			</span><br><span class="line">      if(messageIsRequest) &#123;</span><br><span class="line">        // Get request bytes</span><br><span class="line">        byte[] request = messageInfo.getRequest();</span><br><span class="line">        // Get a IRequestInfo object, useful to work with the request</span><br><span class="line">        IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line">        // Get &quot;test&quot; parameter</span><br><span class="line">        IParameter contentParameter = helpers.getRequestParameter(request, &quot;content&quot;);</span><br><span class="line">        if(contentParameter != null) &#123;</span><br><span class="line">          String urlDecodedContentParameterValue = helpers.urlDecode(contentParameter.getValue());</span><br><span class="line">          String ret = &quot;&quot;;</span><br><span class="line">          // Ask Brida to encrypt our attack vector</span><br><span class="line">          String pyroUrl = &quot;PYRO:BridaServicePyro@localhost:9999&quot;;</span><br><span class="line">          try &#123;</span><br><span class="line">            PyroProxy pp = new PyroProxy(new PyroURI(pyroUrl));</span><br><span class="line">            ret = (String)pp.call(&quot;callexportfunction&quot;,&quot;encryptrequest&quot;,new String[]&#123;urlDecodedContentParameterValue&#125;);</span><br><span class="line">            pp.close();</span><br><span class="line">          &#125; catch(Exception e) &#123;</span><br><span class="line">            stderr.println(e.toString());</span><br><span class="line">            StackTraceElement[] exceptionElements = e.getStackTrace();</span><br><span class="line">            for(int i=0; i&lt; exceptionElements.length; i++) &#123;</span><br><span class="line">              stderr.println(exceptionElements[i].toString());</span><br><span class="line">            &#125;							</span><br><span class="line">          &#125;</span><br><span class="line">          // Create the new parameter</span><br><span class="line">          IParameter newTestParameter = helpers.buildParameter(contentParameter.getName(), helpers.urlEncode(ret), contentParameter.getType());</span><br><span class="line">          // Create the new request with the updated parameter</span><br><span class="line">          byte[] newRequest = helpers.updateParameter(request, newTestParameter);</span><br><span class="line">          // Update the messageInfo object with the modified request (otherwise the request remains the old one)</span><br><span class="line">          messageInfo.setRequest(newRequest);</span><br><span class="line">        &#125;				</span><br><span class="line">      </span><br><span class="line">      // Response</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Get request bytes in order to check if the request contain &quot;content&quot; parameter</span><br><span class="line">        byte[] request = messageInfo.getRequest();				</span><br><span class="line">        IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line">        IParameter contentParameter = helpers.getRequestParameter(request, &quot;content&quot;);</span><br><span class="line">        if(contentParameter != null) &#123;</span><br><span class="line">          // Get response bytes</span><br><span class="line">          byte[] response = messageInfo.getResponse();</span><br><span class="line">          // Get a IResponseInfo object, useful to work with the request</span><br><span class="line">          IResponseInfo responseInfo = helpers.analyzeResponse(response);</span><br><span class="line">          // Get the offset of the body</span><br><span class="line">          int bodyOffset = responseInfo.getBodyOffset();</span><br><span class="line">          // Get the body (byte array and String)</span><br><span class="line">          byte[] body = Arrays.copyOfRange(response, bodyOffset, response.length);</span><br><span class="line">          String bodyString = helpers.bytesToString(body);</span><br><span class="line">          String ret = &quot;&quot;;</span><br><span class="line">          // Ask Brida to decrypt the response</span><br><span class="line">          String pyroUrl = &quot;PYRO:BridaServicePyro@localhost:9999&quot;;</span><br><span class="line">          try &#123;</span><br><span class="line">            PyroProxy pp = new PyroProxy(new PyroURI(pyroUrl));</span><br><span class="line">            ret = (String)pp.call(&quot;callexportfunction&quot;,&quot;decryptresponse&quot;,new String[]&#123;bodyString&#125;);</span><br><span class="line">            pp.close();</span><br><span class="line">          &#125; catch(Exception e) &#123;</span><br><span class="line">            stderr.println(e.toString());</span><br><span class="line">            StackTraceElement[] exceptionElements = e.getStackTrace();</span><br><span class="line">            for(int i=0; i&lt; exceptionElements.length; i++) &#123;</span><br><span class="line">              stderr.println(exceptionElements[i].toString());</span><br><span class="line">            &#125;							</span><br><span class="line">          &#125;</span><br><span class="line">          // Update the messageInfo object with the modified request (otherwise the request remains the old one)</span><br><span class="line">          byte[] newResponse = ArrayUtils.addAll(Arrays.copyOfRange(response, 0, bodyOffset),ret.getBytes());</span><br><span class="line">          messageInfo.setResponse(newResponse);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="实战">实战</span></h3><p>如图app对数据进行了加密。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580902822525.png" alt="1580902822525"></p>
<p>这里我们可以通过直接分析APK或者通过Hook来看他是使用的什么加密，且调用的是那个类的那个方法。</p>
<p>逆向APP可以知道调用的类和方法。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580903281942.png" alt="1580903281942"></p>
<p>同时得到加密密钥为：<code>9876543210123456</code></p>
<p>我们可以利用Execute method模块进行函数调用测试。修改contextcustom1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contextcustom1: function(message) &#123;</span><br><span class="line">        console.log(&quot;Brida  Java Starting script ----&gt;ok&quot;);</span><br><span class="line">        var enc;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                var key = &quot;9876543210123456&quot;;</span><br><span class="line">                var text = &quot;admin&quot;;</span><br><span class="line">                //hook class</span><br><span class="line">                var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">                console.log(&quot;Brida start : encrypt before---&gt;&quot;+text);</span><br><span class="line">                //hook method</span><br><span class="line">                enc = AesEncryptionBase64.encrypt(key,text);</span><br><span class="line">                console.log(&quot;Brida start : encrypt after---&gt;&quot;+enc);</span><br><span class="line"></span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">                console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return enc;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580903583962.png" alt="1580903583962"></p>
<p>如上是hook<code>com.ese.http.encrypt.AesEncryptionBase64</code>类的<code>encrypt</code>方法，并传入key值和加密内容。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580904137989.png" alt="1580904137989"></p>
<p>可得到加密后的密文。</p>
<p>4个方法与请求数据包与返回数据包相互一 一对应：</p>
<ul>
<li>Brida Custom 1：通过右键菜单进行访问，它会调用contextcustom1 JS脚本；</li>
<li>Brida Custom 2：通过右键菜单进行访问，它会调用contextcustom2 JS脚本；</li>
<li>Brida Custom 3：通过右键菜单进行访问，它会调用contextcustom3 JS脚本；</li>
<li>Brida Custom 4：通过右键菜单进行访问，它会调用contextcustom4 JS脚本。</li>
</ul>
<p>编写加密解密脚本：（函数接收的参数和返回的数据都是以 16进制编码的，所以我们使用时要先对他们进行16进制解码，然后返回的时候在进行16进制编码。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//AesEncryptionBase64 encrypt</span><br><span class="line">contextcustom1: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var enc;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var text = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : encrypt before---&gt;&quot;+text);</span><br><span class="line">            //hook method</span><br><span class="line">            enc = AesEncryptionBase64.encrypt(key,text);</span><br><span class="line">            console.log(&quot;Brida start : encrypt after---&gt;&quot;+enc);</span><br><span class="line"></span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return stringToHex(enc);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//AesEncryptionBase64 decrypt</span><br><span class="line">contextcustom2: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var text;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var enc = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : decrypt before---&gt;&quot;+enc);</span><br><span class="line">            //hook method</span><br><span class="line">            text = AesEncryptionBase64.decrypt(key,enc);</span><br><span class="line">            console.log(&quot;Brida start : decrypt after---&gt;&quot;+text);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;Brida start : decrypt after---&gt;&quot;+stringToHex(text));</span><br><span class="line">    return stringToHex(text);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//AesEncryptionBase64 encrypt</span><br><span class="line">contextcustom3: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var enc;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var text = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : encrypt before---&gt;&quot;+text);</span><br><span class="line">            //hook method</span><br><span class="line">            enc = AesEncryptionBase64.encrypt(key,text);</span><br><span class="line">            console.log(&quot;Brida start : encrypt after---&gt;&quot;+enc);</span><br><span class="line"></span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return stringToHex(enc);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//AesEncryptionBase64 decrypt</span><br><span class="line">contextcustom4: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var text;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var enc = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : decrypt before---&gt;&quot;+enc);</span><br><span class="line">            //hook method</span><br><span class="line">            text = AesEncryptionBase64.decrypt(key,enc);</span><br><span class="line">            console.log(&quot;Brida start : decrypt after---&gt;&quot;+text);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;Brida start : decrypt after---&gt;&quot;+stringToHex(text));</span><br><span class="line">    return stringToHex(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换脚本里的contextcustom函数。</p>
<p>这样就能在burpsuite中进行右键菜单转换了。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111111111.gif" alt="1580905769487"></p>
<p>接下来实现自定义插件实现在<code>reperter</code>、<code>scanner</code>、<code>intruder</code>模板中自动加密请求包和解密返回包。</p>
<p>为了让处理加解密数据更方便，所以就改变了一下服务端加解密的方式。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580972196130.png" alt="1580972196130"></p>
<p>这里我用的python编写插件。所以需要安装jython</p>
<p>推荐安装最新版的<code>jython-installer-2.7.2b3.jar</code></p>
<p><a href="https://repo1.maven.org/maven2/org/python/jython-installer/2.7.2b3/jython-installer-2.7.2b3.jar" target="_blank" rel="noopener">https://repo1.maven.org/maven2/org/python/jython-installer/2.7.2b3/jython-installer-2.7.2b3.jar</a></p>
<p>同时使用jython自带的pip安装Pyro4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyro4</span><br></pre></td></tr></table></figure>
<p>burp中配置最新安装好pyro4的路径。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580969785849.png" alt="1580969785849"></p>
<p>然后用python编写burp插件。</p>
<p>申明一个类，继承于<code>IBurpExtender</code>和<code>IHttpListener</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`class` `BurpExtender(IBurpExtender, IHttpListener)`</span><br></pre></td></tr></table></figure>
<p>重写<code>registerExtenderCallbacks</code>和<code>processHttpMessage</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def registerExtenderCallbacks(self, callbacks):</span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers = callbacks.getHelpers()</span><br><span class="line">        self._callbacks.setExtensionName(&quot;fuck encrypt by Uknow!&quot;)</span><br><span class="line">        callbacks.registerHttpListener(self)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):</span><br><span class="line">    # tool https://portswigger.net/burp/extender/api/constant-values.html#burp.IBurpExtenderCallbacks</span><br><span class="line">    if toolFlag == 64 or toolFlag == 16 or toolFlag == 32: # TOOL_REPEATER     TOOL_SCANNER     TOOL_INTRUDER</span><br><span class="line">        request = messageInfo.getRequest()</span><br><span class="line">        analyzedRequest = self._helpers.analyzeRequest(request)</span><br><span class="line">        headers = analyzedRequest.getHeaders()</span><br><span class="line">        if not messageIsRequest:</span><br><span class="line">            response = messageInfo.getResponse()</span><br><span class="line">            analyzedResponse = self._helpers.analyzeResponse(response)</span><br><span class="line">            messageInfo.setResponse(self.decrypt(analyzedResponse, response))</span><br><span class="line">        # elif toolFlag != 4:</span><br><span class="line">        else:</span><br><span class="line">            messageInfo.setRequest(self.encrypt(analyzedRequest, request))</span><br></pre></td></tr></table></figure>
<p>对着toolFlag一顿if是为了过滤Burp的模块，判断他是从哪过来的，这里是过滤了三个：<code>reperter</code>、<code>scanner</code>、<code>intruder</code>，抓包过来的无需处理，如果你处理了那APP就不能正常收发数据了。<br><code>self.decrypt</code>和<code>self.encrypt</code>就是去跟<code>Brida</code>开的端口交换数据，处理加解密：</p>
<pre><code>def decrypt(self, RequestOrResponse,raw):
    uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;
    pp = Pyro4.Proxy(uri)
    body = raw[RequestOrResponse.getBodyOffset():]
    newbody = body.tostring()
    args = []
    args.append(newbody.encode(&apos;hex&apos;))
    ret = pp.callexportfunction(&apos;contextcustom4&apos;,args)
    ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)
    return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)

def encrypt(self, RequestOrResponse,raw):
    uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;
    pp = Pyro4.Proxy(uri)
    body = raw[RequestOrResponse.getBodyOffset():]
    newbody = body.tostring()
    args = []
    args.append(newbody.encode(&apos;hex&apos;))
    ret = pp.callexportfunction(&apos;contextcustom1&apos;,args)
    ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)
    return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)
</code></pre><p>用<code>callexportfunction</code>来调用你刚才js脚本里<code>rpc.exports</code>里的函数，参数是函数名和参数列表。</p>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from burp import IBurpExtender</span><br><span class="line">from burp import IHttpListener</span><br><span class="line">from burp import IHttpRequestResponse</span><br><span class="line">from burp import IResponseInfo</span><br><span class="line">from burp import IProxyListener</span><br><span class="line">import Pyro4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &apos;uknowsec.cn&apos;</span><br><span class="line"></span><br><span class="line">class BurpExtender(IBurpExtender,IHttpListener,IHttpRequestResponse, IProxyListener):</span><br><span class="line">    def registerExtenderCallbacks(self, callbacks):</span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers = callbacks.getHelpers()</span><br><span class="line">        self._callbacks.setExtensionName(&quot;fuck encrypt by Uknow!&quot;)</span><br><span class="line">        callbacks.registerHttpListener(self)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, RequestOrResponse,raw):</span><br><span class="line">        uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;</span><br><span class="line">        pp = Pyro4.Proxy(uri)</span><br><span class="line">        body = raw[RequestOrResponse.getBodyOffset():]</span><br><span class="line">        newbody = body.tostring()</span><br><span class="line">        args = []</span><br><span class="line">        args.append(newbody.encode(&apos;hex&apos;))</span><br><span class="line">        ret = pp.callexportfunction(&apos;contextcustom4&apos;,args)</span><br><span class="line">        ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)</span><br><span class="line">        return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)</span><br><span class="line"> </span><br><span class="line">    def encrypt(self, RequestOrResponse,raw):</span><br><span class="line">        uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;</span><br><span class="line">        pp = Pyro4.Proxy(uri)</span><br><span class="line">        body = raw[RequestOrResponse.getBodyOffset():]</span><br><span class="line">        newbody = body.tostring()</span><br><span class="line">        args = []</span><br><span class="line">        args.append(newbody.encode(&apos;hex&apos;))</span><br><span class="line">        ret = pp.callexportfunction(&apos;contextcustom1&apos;,args)</span><br><span class="line">        ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)</span><br><span class="line">        return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)</span><br><span class="line"></span><br><span class="line">    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):</span><br><span class="line">        # tool https://portswigger.net/burp/extender/api/constant-values.html#burp.IBurpExtenderCallbacks</span><br><span class="line">        if toolFlag == 64 or toolFlag == 16 or toolFlag == 32: # TOOL_REPEATER     TOOL_SCANNER     TOOL_INTRUDER</span><br><span class="line">            request = messageInfo.getRequest()</span><br><span class="line">            analyzedRequest = self._helpers.analyzeRequest(request)</span><br><span class="line">            headers = analyzedRequest.getHeaders()</span><br><span class="line">            if not messageIsRequest:</span><br><span class="line">                response = messageInfo.getResponse()</span><br><span class="line">                analyzedResponse = self._helpers.analyzeResponse(response)</span><br><span class="line">                messageInfo.setResponse(self.decrypt(analyzedResponse, response))</span><br><span class="line">            # elif toolFlag != 4:</span><br><span class="line">            else:</span><br><span class="line">                messageInfo.setRequest(self.encrypt(analyzedRequest, request))</span><br></pre></td></tr></table></figure>
<p>然后加载就可以在<code>reperter</code>、<code>scanner</code>、<code>intruder</code>模块中实现自动加密解密了。操作如下图。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111211111.gif" alt="1580905769487"></p>
<p>比如如上场景可直接进行爆破。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111311111.gif" alt="1580905769487"></p>
<p>自动以插件也可以使用Java编写，可以根据文章前文给出的官方文档给出的示例进行修改。</p>
<h2><span id="lxhtoolhttpdecrypt">lxhToolHTTPDecrypt</span></h2><p><a href="https://github.com/lyxhh/lxhToolHTTPDecrypt" target="_blank" rel="noopener">https://github.com/lyxhh/lxhToolHTTPDecrypt</a></p>
<p>HTTP Decrypt 提供了Finds Hooks模块，可以在不逆向不脱壳的情况下快速的找到APP所使用的加解密算法，而toBurp模块提供了直接使用APP内的方法进行加解密，而不需自己动手敲代码，对于整体POST加密更是提供了自动化加解密功能，可以实现Burp一条龙，Burp Scanner ，Intruder自动加解密。</p>
<ol>
<li>python3 app.py</li>
<li>Android_frida_server 运行</li>
<li>转发frida端口。</li>
<li>打开HTTP Decrypt页面，如果在Start界面出现应用包名列表信息则可正常使用其他功能，如果不行，刷新一下看看控制台出现的信息。</li>
</ol>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580977948133.png" alt="1580977948133"></p>
<h3><span id="hooks">Hooks</span></h3><p>填写字符串，将类名与你填写的字符串匹配，并Hooks类下的所有方法，hook多个类名，回车换行。</p>
<p>在APP中进行操作，尽量进行多次操作，让脚本hook到所有方法。</p>
<p>如下图，这里找到了加密方法为<code>com.ese.http.encrypt.AesEncryptionBase64.encrypt</code></p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580978070314.png" alt="1580978070314"></p>
<h3><span id="stack">Stack</span></h3><p>像Brida一样也可以显示Hooks打印的堆栈。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580978156034.png" alt="1580978156034"></p>
<h3><span id="finds">Finds</span></h3><p>根据字符串，查找类，匹配到类，将类下的方法都打印出来。多个查找回车换行继续写。提供了过滤机制。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580979123411.png" alt="1580979123411"></p>
<p>匹配的不是很准确，可能是我姿势有问题，但是我们可以自己去反编译或者通过hook来判断哪个是加解密方法。</p>
<h3><span id="toburp">toBurp</span></h3><p>添入我们得到加解密方法。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580979268369.png" alt="1580979268369"></p>
<p>然后点击Confirm按钮，之后再点击Add按钮，将方法的信息添加到左边的info里面去，因为加解密方法有两个参数，无法使用HTTPDecrypt自动的生成的脚本（自动生成的脚本只能适应一个参数），所以 我们需要自己写一些代码，接下来我们点击Generate export static script按钮。（因为方法类型是静态的所以选择static按钮，动态的选择instance，如果你很熟悉frida，点哪个都无所谓。）</p>
<p>HTTPDecrypt会将一些代码生成在Custom选项卡中，如下：</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580979877144.png" alt="1580979877144"></p>
<p>像Brida修改代码，添加key值。encrypt方法的第一个参数是一个固定值key，通过反编译和hook分析可以得到。第二个参数为加密内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var rpc_result = null;</span><br><span class="line">var rpc_result_ios = null;</span><br><span class="line">rpc.exports = &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">tag3c57a19c2806a2b4d3f028f23c7d2f4f02: function(arg0, arg1)&#123;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                var key = &quot;9876543210123456&quot;;</span><br><span class="line">				// var context = Java.use(&apos;android.app.ActivityThread&apos;).currentApplication().getApplicationContext();</span><br><span class="line">                var AesEncryptionBase64bc9333b9adb0ceb7cc6c929d900e3365 = Java.use(&quot;com.ese.http.encrypt.AesEncryptionBase64&quot;);</span><br><span class="line">                rpc_result = AesEncryptionBase64bc9333b9adb0ceb7cc6c929d900e3365.encrypt(key, arg0);</span><br><span class="line">                // send(JSON.stringify(&#123;&quot;aa&quot;:&quot;bb&quot;,&quot;aa1&quot;:&quot;bbb&quot;&#125;)+&apos;-cusoto0oom0sc0ri0pt-&apos;)</span><br><span class="line">            &#125;catch(e)&#123;send(&quot;tag3c57a19c2806a2b4d3f028f23c7d2f4f02, &quot; + e + &quot;-er00roo000r-&quot;)&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return rpc_result;</span><br><span class="line">    &#125;,</span><br><span class="line">// Added Function </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的方法修改解密方法。如图</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580981397792.png" alt="1580981397792"></p>
<p>loadscript加载脚本。</p>
<p>这样我们可以得到两个方法名，和brida中的contextcustom一样。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580981451928.png" alt="1580981451928"></p>
<p>然后我们将这两个方法名添入burp插件配置项里</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580981619949.png" alt="1580981619949"></p>
<p>同样就可以通过右键菜单栏进行加解密了。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111411111.gif" alt="1580905769487"></p>
<p>他也具有自动加解密的功能，但是目前只能对整个请求包进行加解密不能匹配到需要加解密的数据。</p>
<p>通过burp发给服务端的数据可以看到，在看起自动加解密后他把整个请求body进行了加密，跟服务端验证不符合，所以存在一定的局限性。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580982022808.png" alt="1580982022808"></p>
<p>通过修改服务端代码，和请求包格式。</p>
<p>我们改成客户端把整个请求包body进行加密，给后端验证的方法。体验一下自动加解密。</p>
<p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111511111.gif" alt="1580905769487"></p>
<h2><span id="对比总结">对比总结</span></h2><ul>
<li>Brida的插桩功能好像有点不好使，lxhToolHTTPDecrypt的hook功能对APP进行多次操作后，效果还是挺好的。但定位加解密方法还是要人工的去分析，工具只是辅助作用。</li>
<li>Brida和lxhToolHTTPDecrypt的右键菜单功能其实是相同的原理，绑定函数去调用函数进行加解密得到返回值</li>
<li>Brida灵活性强一点，可以自定义编写插件。但是这也是比较麻烦的一点，对于不熟悉BURP插件编写的使用者是一个难点，lxhToolHTTPDecrypt方便一点，他不需要自己去写插件对数据进行处理，但是他只能对整个body进行自动加解密，存在一定局限性。而在Brida中可以在编写脚本的过程中对需要加解密的内容进行灵活的操作，lxhToolHTTPDecrypt目前还在不断的更新，可能作者后面会解决这个问题。</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/posts/notes/加载远程XSL文件的宏免杀方法.html" class="prev">上一篇</a><a href="/posts/notes/frida-hook实战二.html" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2024 <a href="https://uknowsec.cn">uknow</a>  Stay hungry,Stay foolish.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-115504647-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?225ebcce29d319519ac7c7690425d1d4";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>